<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="###  0x25  推箱子。。。。。。。 是真的写废了。。。。 矩阵距离这个就是常见点 一开始就把多元点 放入队列的写法 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int maxn = 1005; const int dx[] = {1, 0, -1, 0}; const int dy[] = {0, 1, 0, -1};">
<meta property="og:type" content="article">
<meta property="og:title" content="《算法竞赛进阶指南》 0x25 ~ 0x28 代码 + 杂谈">
<meta property="og:url" content="http://zhxu98.github.io/2019/08/04/《算法竞赛进阶指南》 0x25 ~ 0x28 代码 + 杂谈/index.html">
<meta property="og:site_name" content="蒟蒻最后的倔强">
<meta property="og:description" content="###  0x25  推箱子。。。。。。。 是真的写废了。。。。 矩阵距离这个就是常见点 一开始就把多元点 放入队列的写法 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int maxn = 1005; const int dx[] = {1, 0, -1, 0}; const int dy[] = {0, 1, 0, -1};">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-08-28T05:51:12.452Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《算法竞赛进阶指南》 0x25 ~ 0x28 代码 + 杂谈">
<meta name="twitter:description" content="###  0x25  推箱子。。。。。。。 是真的写废了。。。。 矩阵距离这个就是常见点 一开始就把多元点 放入队列的写法 #include &amp;lt;bits/stdc++.h&amp;gt; using namespace std; const int maxn = 1005; const int dx[] = {1, 0, -1, 0}; const int dy[] = {0, 1, 0, -1};">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://zhxu98.github.io/2019/08/04/《算法竞赛进阶指南》 0x25 ~ 0x28 代码 + 杂谈/">





  <title>《算法竞赛进阶指南》 0x25 ~ 0x28 代码 + 杂谈 | 蒟蒻最后的倔强</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?58b7e016a3433eb1162126ec13ec1dbf";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蒟蒻最后的倔强</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">by-zhxu98</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/04/《算法竞赛进阶指南》 0x25 ~ 0x28 代码 + 杂谈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《算法竞赛进阶指南》 0x25 ~ 0x28 代码 + 杂谈</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-04T19:09:34+08:00">
                2019-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/题集/" itemprop="url" rel="index">
                    <span itemprop="name">题集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <a id="more"></a>###  0x25

<p>推箱子。。。。。。。 是真的写废了。。。。</p>
<h4 id="矩阵距离"><a href="#矩阵距离" class="headerlink" title="矩阵距离"></a>矩阵距离</h4><p>这个就是常见点 一开始就把多元点 放入队列的写法</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1005;
const int dx[] = {1, 0, -1, 0};
const int dy[] = {0, 1, 0, -1};
typedef pair&lt;int, int&gt; P;

int n, m;
int ans[maxn][maxn];
struct node{
    int x, y, st;
};

queue&lt;node&gt; que;

bool chk(int x, int y) {
    return (x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; m || ans[x][y] != -1);
}

void bfs(){
    while(!que.empty()){
        node p = que.front(); que.pop();
        for(int i = 0; i &lt; 4; i ++) {
            int nx = p.x + dx[i];
            int ny = p.y + dy[i];
            if(chk(nx, ny)) continue;
            ans[nx][ny] = p.st + 1;
            que.push(node{nx, ny, p.st + 1});
        }
    }

}

int main(){
    memset(ans, -1, sizeof ans);
    cin &gt;&gt; n &gt;&gt; m;
    string str;
    for(int i = 1;i &lt;= n; i ++) {
        cin &gt;&gt; str;
        for(int j = 1; j &lt;= m; j ++) {
            if(str[j - 1] == &apos;1&apos;) ans[i][j] = 0, que.push(node{i, j, 0});
        }
    }
    bfs();
    for(int i = 1; i &lt;= n; i++){
        for(int j = 1; j &lt;= m; j ++) cout &lt;&lt; ans[i][j] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    } 
    return 0;
}</code></pre><h3 id="0x26"><a href="#0x26" class="headerlink" title="0x26"></a>0x26</h3><p>双端队列BFS<br>电路维修 权值只有 0 1 0 放前面提前出 1 放后面 以此减低复杂度<br>注意 每个点 对应的权值 改了好就</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; P;
const int maxn = 505;

const int dx[] = {1, -1, -1, 1};
const int dy[] = {1, -1, 1, -1};
const int ndx[] = {1, 0, 0, 1};
const int ndy[] = {1, 0, 1, 0};

int n, m;
char str[maxn][maxn];
bool vis[maxn][maxn];
int dis[maxn][maxn];

struct node{
    int x, y;
};

bool check(int x, int y) {return x &gt;= 0 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= m;}

void bfs(){
    deque&lt;node&gt; que;
    que.push_back(node{0, 0});
    memset(dis, 0x3f, sizeof dis);
    memset(vis, 0, sizeof vis);
    vis[0][0] = 1;
    dis[0][0] = 0;
    while(!que.empty()) {
        node p = que.front(); que.pop_front();
        for(int i = 0, t; i &lt; 4; i ++) {
            int nx = p.x + ndx[i], tx = p.x + dx[i];
            int ny = p.y + ndy[i], ty = p.y + dy[i];
            if(i &lt; 2) t = str[nx][ny] == &apos;/&apos; ? 1 : 0;
            else t = str[nx][ny] == &apos;/&apos; ? 0 : 1;
            if(check(tx, ty) &amp;&amp; !vis[tx][ty] &amp;&amp; dis[tx][ty] &gt; dis[p.x][p.y] + t){
                dis[tx][ty] = dis[p.x][p.y] + t;
                if(t) que.push_back(node{tx, ty});
                else que.push_front(node{tx, ty});
            }
        }
    }
    if(dis[n][m] != 0x3f3f3f3f) cout &lt;&lt; dis[n][m] &lt;&lt; endl;
    else cout &lt;&lt; &quot;NO SOLUTION&quot; &lt;&lt; endl;
}

int main(){
    int t;
    cin &gt;&gt; t;
    while(t--){
        cin &gt;&gt; n &gt;&gt; m;
        for(int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; (str[i] + 1);
        bfs();
        // for(int i = 0; i &lt;= n; i ++) {
        //     for(int j = 0; j &lt;= m; j++) {
        //         cout &lt;&lt; dis[i][j] &lt;&lt; &quot; &quot;;
        //     }cout &lt;&lt; endl;
        // }
    }
    return 0;
}</code></pre><h4 id="优先队列BFS"><a href="#优先队列BFS" class="headerlink" title="优先队列BFS"></a>优先队列BFS</h4><p>我想起了DJ最短路。。</p>
<h5 id="Full-Tank"><a href="#Full-Tank" class="headerlink" title="Full Tank"></a>Full Tank</h5><p>这个 也是常见的 很像最短路 分层图一个写法</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e4 + 5;

int head[maxn], fcst[maxn], cnt;
int nxt[maxn * 20], to[maxn * 20], dis[maxn * 20];
bool vis[maxn][105];

struct node{
    int u, f, cst;
    bool operator &lt; (const node &amp; a) const {
        return cst &gt; a.cst;
    }
};

void ade(int a, int b, int v) {
    to[++cnt] = b, dis[cnt] = v;
    nxt[cnt] = head[a], head[a] = cnt;
    to[++cnt] = a, dis[cnt] = v;
    nxt[cnt] = head[b], head[b] = cnt;
}

int dj(int c, int s, int t){
    priority_queue&lt;node&gt; que;
    memset(vis, 0, sizeof vis);
    que.push(node{s, 0, 0});
    while(!que.empty()) {
        node p = que.top(); que.pop();
        if(p.u == t) return p.cst;
        if(vis[p.u][p.f]) continue;
        vis[p.u][p.f] = 1;
        if(p.f &lt; c &amp;&amp; !vis[p.u][p.f + 1]) {
            que.push(node{p.u, p.f + 1, p.cst + fcst[p.u]});
        }
        for(int i = head[p.u]; i; i = nxt[i]) {
            int v = to[i];
            if(p.f &gt;= dis[i] &amp;&amp; !vis[v][p.f - dis[i]]) {
                que.push(node{v, p.f - dis[i], p.cst});
            }
        }
    }
    return -1;
}

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; n; i ++) cin &gt;&gt; fcst[i];
    for(int i = 1, a, b, c; i &lt;= m; i ++) 
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, ade(a, b, c);
    cin &gt;&gt; m;
    for(int i = 1, c, s, t; i &lt;= m; i ++) {
        cin &gt;&gt; c &gt;&gt; s &gt;&gt; t;
        int ans = dj(c, s, t);
        if(ans == -1) cout &lt;&lt; &quot;impossible\n&quot;;
        else cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}</code></pre><h4 id="双向BFS"><a href="#双向BFS" class="headerlink" title="双向BFS"></a>双向BFS</h4><h5 id="噩梦"><a href="#噩梦" class="headerlink" title="噩梦"></a>噩梦</h5><p>对着3个会动的分别极限BFS 每个人论者进行一次 鬼先走<br>省去去 一起跑 状态太多的存储 也是BFS一个有效方法</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int maxn = 800 + 5;
const int INF = 0x3f3f3f3;
const int cx[] = {-1, 0, 1, 0};
const int cy[] = {0, 1, 0, -1};
string str;
int n, m, cas;
char mp[maxn][maxn];

struct node{
    int x, y, sp;
    node(int _x, int _y, int _sp){
        x = _x, y = _y, sp = _sp;
    }
};
queue&lt;node&gt; G, Z, M;

bool chkZ(int x, int y) {
    return (x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; m || mp[x][y] == &apos;Z&apos;);
}

bool chkH(int x, int y) {
    if((x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; m)) return 1;
    if(mp[x][y] == &apos;X&apos; || mp[x][y] == &apos;Z&apos;) return 1;
    return 0; 
}

void pt(){
    for(int i = 1; i &lt;= n; i++) {
        for(int j = 1; j &lt;= m; j ++) {
            cout &lt;&lt; mp[i][j] &lt;&lt; &quot; &quot;;
        }cout &lt;&lt; endl;
    }
}

int sol(){
    while(Z.size()) {
        int time = Z.front().sp;
    //    cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl;pt();cout &lt;&lt; endl;
        while(!Z.empty() &amp;&amp; Z.front().sp &lt; time + 2) {
            node p = Z.front(); Z.pop();
            for(int i = 0; i &lt; 4; i ++) {
                int nx = p.x + cx[i], ny = p.y + cy[i];
                if(chkZ(nx, ny)) continue;
                mp[nx][ny] = &apos;Z&apos;;
                Z.push(node(nx, ny, p.sp + 1));
             }
        }
    //    pt();cout &lt;&lt; endl;
        time = M.front().sp;
        while(!M.empty() &amp;&amp; M.front().sp &lt; time + 3) {
            node p = M.front(); M.pop();
            if(mp[p.x][p.y] == &apos;Z&apos;) continue;
            for(int i = 0; i &lt; 4; i ++) {
                int nx = p.x + cx[i], ny = p.y + cy[i];
                if(chkH(nx, ny)) continue;
                if(mp[nx][ny] == &apos;M&apos;) continue;
                if(mp[nx][ny] == &apos;G&apos;) return p.sp / 3 + 1;
                mp[nx][ny] = &apos;M&apos;;
                M.push(node(nx, ny, p.sp + 1));
             }
        }
        //    pt();cout &lt;&lt; endl;
        time = G.front().sp;
        while(!G.empty() &amp;&amp; G.front().sp &lt; time + 1) {
            node p = G.front(); G.pop();
            if(mp[p.x][p.y] == &apos;Z&apos;) continue;
            for(int i = 0; i &lt; 4; i ++) {
                int nx = p.x + cx[i], ny = p.y + cy[i];
                if(chkH(nx, ny)) continue;
                if(mp[nx][ny] == &apos;G&apos;) continue;
                if(mp[nx][ny] == &apos;M&apos;) return p.sp + 1;
                mp[nx][ny] = &apos;G&apos;;
                G.push(node(nx, ny, p.sp + 1));
             }
        }
        //    pt();cout &lt;&lt; endl;
    } 
    return -1;
}

signed main(){
    cin &gt;&gt; cas;
    while(cas --) {
        while(!Z.empty()) Z.pop();
        while(!G.empty()) G.pop();
        while(!M.empty()) M.pop();
        cin &gt;&gt; n &gt;&gt; m;
        for(int i = 1; i &lt;= n; i ++) {
            cin &gt;&gt; str;
            for(int j = 1; j &lt;= m; j ++){
                mp[i][j] = str[j - 1];
                if(str[j - 1] == &apos;G&apos;) G.push(node(i, j, 0));
                if(str[j - 1] == &apos;Z&apos;) Z.push(node(i, j, 0));
                if(str[j - 1] == &apos;M&apos;) M.push(node(i, j, 0));
            }
        }
        cout &lt;&lt; sol() &lt;&lt; endl;
    }
    return 0; 
}</code></pre><h2 id="Astar"><a href="#Astar" class="headerlink" title="Astar"></a>Astar</h2><p>加上估值函数的 BFS A*  
估值函数不能大于实际价值就好<br>估的越好 我们越能从队列里取出 最优的状态 减低复杂度</p>
<h4 id="第K短路"><a href="#第K短路" class="headerlink" title="第K短路"></a>第K短路</h4><p>正常跑最短路 如果补终止 那么 这个点 第几次出现 就是第K短路上的路径和</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
//#define int long long
using namespace std;
const int maxn = 1000 + 10;
const int maxe = 1e5 + 10;
const int INF = 0x3f3f3f3;
typedef pair&lt;int, int&gt; P;

int n, m, s, t, k;
int head[maxn], cnt;
int nxt[maxe &lt;&lt; 1], to[maxe &lt;&lt; 1], dis[maxe &lt;&lt; 1];
void ade(int a, int b, int v) {
    to[++ cnt] = b, dis[cnt] = v;
    nxt[cnt] = head[a], head[a] = cnt;
}

int rhead[maxn], rcnt;
int rnxt[maxe &lt;&lt; 1], rto[maxe &lt;&lt; 1], rdis[maxe &lt;&lt; 1];
void rade(int a, int b, int v) {
    rto[++ rcnt] = b, rdis[rcnt] = v;
    rnxt[rcnt] = rhead[a], rhead[a] = rcnt;
}

int f[maxn];
bool vis[maxn];
void dj(int s, int t) {
    memset(f, 0x3f, sizeof f);
    f[s] = 0;
    priority_queue&lt;P&gt; que;
    que.push(P(0, s));
    while(!que.empty()) {
        P p = que.top(); que.pop();
        int u = p.second;
        if(vis[u]) continue;
        vis[u] = 1;
        for(int i = rhead[u]; i; i = rnxt[i]) {
            int v = rto[i];
            if(f[v] &gt; f[u] + rdis[i]) {
                f[v] = f[u] + rdis[i];
                que.push(P(-f[v], v));
            } 
        }
    }
}

struct node{
    int u, f, g;
    bool operator &lt; (const node &amp; a) const {
        return f + g &gt; a.f + a.g;
    }
};

int Astar(int s, int t, int k) {
    int counts = 0;
    priority_queue&lt;node&gt; que;
    if(s == t) k ++;
    que.push(node{s, 0, 0});
    while(!que.empty()) {
        node p = que.top(); que.pop();
        int u = p.u;
        if(u == t) counts++;
        if(counts == k) return p.g;
        for(int i = head[u]; i; i = nxt[i]) {
            int v = to[i];
            que.push(node{v, 0, dis[i] + p.g});
        }
    }
    return -1;
}

signed main() {
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1, a, b, c; i &lt;= m; i ++) {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        ade(a, b, c), rade(b, a, c);
    }
    cin &gt;&gt; s &gt;&gt; t &gt;&gt; k;
    dj(t, s);
//    for(int i = 1; i &lt;= n; i ++) cout &lt;&lt; f[i] &lt;&lt; &quot; &quot; ; cout &lt;&lt; endl;
    cout &lt;&lt; Astar(s, t, k) &lt;&lt; endl;
    return 0;
}</code></pre><h3 id="八数码-问题"><a href="#八数码-问题" class="headerlink" title="八数码 问题"></a>八数码 问题</h3><p>其实 这里还可以加上 逆序对优化 排除一些无解的情况</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 362880 + 100;
const int fac[] = {1,1,2,6,24,120,720,5040,40320,362880};

bool vis[maxn];
const int cx[] = {-1, 1, 0, 0};
const int cy[] = {0, 0, -1, 1};
const char op[] = {&apos;u&apos;,&apos;d&apos;,&apos;l&apos;,&apos;r&apos;};
const int endsta = 0;
char path[maxn];
int pre[maxn];

struct node {
    int sta, g, f;
    int s[9], loc;
    bool operator &lt; (const node&amp; a) const {
        return g + f &gt; a.g + a.f;
    }
};

int cantor(int *a) {
    int x = 0;
    for (int i = 0; i &lt; 9; ++i) {
        int tmp = 0;
        for (int j = i + 1; j &lt; 9; ++j)
            if (a[j] &lt; a[i])
                tmp++;
        x += fac[9 - i - 1] * tmp;
    }
    return x;
}

int dis_f(int *s) {
    int res = 0;
    for(int i = 0; i &lt; 9; i ++)
        if(s[i] != 9) {
            int x = i/3, y = i%3;
            int xx = (s[i] - 1)/3, yy = (s[i]  - 1)%3;
            res += abs(x - xx) + abs(y - yy);
        }
    return res;
}

priority_queue&lt;node&gt;que;
bool astar(node begins) {
    begins.sta = cantor(begins.s);
    begins.g = 0, begins.f = dis_f(begins.s);
    pre[begins.sta] = -1;
    vis[begins.sta] = 1;
    que.push(begins);
    node tmp,now;
    while(!que.empty()) {
        node now = que.top();
        que.pop();
        if(now.sta == endsta) return 1;
        int x = now.loc / 3, y = now.loc % 3;
        for(int i = 0; i &lt; 4; i ++) {
            int nx = x + cx[i];
            int ny = y + cy[i];
            if(nx &lt; 0 || nx &gt; 2 || ny &lt; 0 || ny &gt; 2) continue;
            tmp = now;
            tmp.s[x * 3 + y] = tmp.s[nx * 3 + ny];
            tmp.s[nx * 3 + ny] = 9;
            tmp.sta = cantor(tmp.s);
            if(vis[tmp.sta]) continue;
            vis[tmp.sta] = 1;
            tmp.loc = nx * 3 + ny;
            tmp.g ++;
            tmp.f = dis_f(tmp.s);
            pre[tmp.sta] = now.sta;
            path[tmp.sta] = op[i];
            que.push(tmp);
        }
    }
    return 0;
}

void print(int sta) {
    if(pre[sta] == -1) return ;
    print(pre[sta]);
    printf(&quot;%c&quot;, path[sta]);
}

int main() {
    node begins;
    char pt;
    for(int i = 0; i &lt; 9; i ++ ) {
        scanf(&quot; %c&quot;, &amp;pt);
        if(pt == &apos;x&apos;) begins.s[i] = 9, begins.loc = i;
        else begins.s[i] = pt - &apos;0&apos;;
    }
    if(!astar(begins)) puts(&quot;unsolvable&quot;);
    else print(endsta), puts(&quot;&quot;);
    return 0;
}</code></pre><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA*"></a>IDA*</h2><h4 id="排书"><a href="#排书" class="headerlink" title="排书"></a>排书</h4><p>这个估值函数 我一开始写的不太对了 一直T 跪了 有点难</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
const int maxn = 25;
int n;

struct node{
    int a[maxn];
    int reh(){
        int cnt = 0;
        if ( a[1] != 1 ) ++cnt;
        if ( a[n] != n ) ++cnt;
        for ( int i = 1; i &lt; n; ++i )
                if ( a[i] + 1 != a[i + 1] ) ++cnt;
        return ceil( cnt / 3.0 );
    }

    bool chk() {
        for(int i = 1; i &lt; n; i ++) 
            if(a[i] + 1 != a[i + 1]) return 0;
        return 1;
    }

    node move(int l, int r, int len) {
        node b = *this;
        for(int i = len + l; i &lt;= r; i ++) b.a[i - len] = b.a[i]; 
        for(int i = r - len + 1; i &lt;= r; i ++) b.a[i] = a[i + l - r + len - 1];
        return b;
   }
}ts;

int flag;

void dfs(node x, int h,int limit) {
    if(flag || x.reh() + h &gt; limit) return;
    if(x.chk()) {flag = 1; return ;}
    for(int len = 1; len &lt; n; len ++) 
        for(int i = 1; i + len - 1 &lt;= n; i ++) 
            for(int j = i + len; j &lt;= n; j ++) 
            dfs(x.move(i, j, len), h + 1, limit);
}

int main() {
    int t; cin &gt;&gt; t;
    while(t --) {
        cin &gt;&gt; n;
        for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; ts.a[i];
        flag = 0;
        for(int i = 0; i &lt; 5; i ++) {
            dfs(ts, 0, i);
            if(flag) {
                cout &lt;&lt; i &lt;&lt; endl;
                break;
            }
        }
        if(!flag) cout &lt;&lt; &quot;5 or more&quot; &lt;&lt; endl;
    }
    return 0;
}</code></pre><p>待续。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/08/04/《算法竞赛进阶指南》 0x68 ~ 0x67 代码 + 杂谈/" rel="next" title="《算法竞赛进阶指南》 0x68 ~ 0x67 代码 + 杂谈">
                <i class="fa fa-chevron-left"></i> 《算法竞赛进阶指南》 0x68 ~ 0x67 代码 + 杂谈
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/05/2019牛客暑期多校(第五场) 写题记录/" rel="prev" title="2019牛客暑期多校(第五场) 写题记录">
                2019牛客暑期多校(第五场) 写题记录 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="ZHXU1998">
            
              <p class="site-author-name" itemprop="name">ZHXU1998</p>
              <p class="site-description motion-element" itemprop="description">等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">150</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#矩阵距离"><span class="nav-number">1.</span> <span class="nav-text">矩阵距离</span></a></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#0x26"><span class="nav-number"></span> <span class="nav-text">0x26</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优先队列BFS"><span class="nav-number">1.</span> <span class="nav-text">优先队列BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Full-Tank"><span class="nav-number">1.1.</span> <span class="nav-text">Full Tank</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双向BFS"><span class="nav-number">2.</span> <span class="nav-text">双向BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#噩梦"><span class="nav-number">2.1.</span> <span class="nav-text">噩梦</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Astar"><span class="nav-number"></span> <span class="nav-text">Astar</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第K短路"><span class="nav-number">1.</span> <span class="nav-text">第K短路</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#八数码-问题"><span class="nav-number"></span> <span class="nav-text">八数码 问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IDA"><span class="nav-number"></span> <span class="nav-text">IDA*</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#排书"><span class="nav-number">1.</span> <span class="nav-text">排书</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZHXU1998</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
