<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢">
<meta property="og:type" content="website">
<meta property="og:title" content="蒟蒻最后的倔强">
<meta property="og:url" content="http://zhxu98.github.io/page/5/index.html">
<meta property="og:site_name" content="蒟蒻最后的倔强">
<meta property="og:description" content="等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蒟蒻最后的倔强">
<meta name="twitter:description" content="等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://zhxu98.github.io/page/5/">





  <title>蒟蒻最后的倔强</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?58b7e016a3433eb1162126ec13ec1dbf";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蒟蒻最后的倔强</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">by-zhxu98</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/07/30/2019 杭电多校 E - Everything Is Generated In Equal Probability HDU 6595 数学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/30/2019 杭电多校 E - Everything Is Generated In Equal Probability HDU 6595 数学/" itemprop="url">2019 杭电多校 E - Everything Is Generated In Equal Probability HDU 6595 数学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-30T08:57:30+08:00">
                2019-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数学/" itemprop="url" rel="index">
                    <span itemprop="name">数学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>给了你一个程序<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190730084116806.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190730084116806.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)<br>程序 S1 将传入的 数组 返回一个随机子序列(不一定连续)<br>程序 S2 算这个数组 逆序对数量<br>程序 S3 算这个数组 经过S1 之后 用S2算逆序对数量</p>
<p>到这里 我们知道了 这个程序是在算 一个序列 包括它子序列 随机排列 最后 逆序对期望值</p>
<p>首先 我们知道 一个长度为n的 它随机排列的逆序对期望 C(n, 2) 可以产生多少逆序对 每个 逆序对的存在概率是/2<br>所以 是C（n, 2）/ 2<br>知道这个后面 我们就好算 算 它子序列的逆序对期望了 ![在这里插入图片描述](<a href="https://img-" target="_blank" rel="noopener">https://img-</a><br>blog.csdnimg.cn/20190730085322270.gif)<br>移向之后 我们就算出 i 子序列的个数了 在 + 上 它自身期望<br>答案 问的是 n 之内 的 期望 所以 我们 sum (f 1 ~ n) / n 就是答案<br>n^2 打表处理</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 3005;
const int mod = 998244353;
int n;
int c[maxn][maxn], mi[maxn];
int f[maxn], ans[maxn];

int q_mod(int a, int b) {
    int res = 1;
    for(; b; b &gt;&gt;= 1) {
        if(b &amp; 1) res = 1ll * res * a % mod;
        a = 1ll * a * a % mod;
    }
    return res;
}

void init(){
    mi[0] = 1;
    for(int i = 1; i &lt; maxn; i++) {
        mi[i] = (mi[i - 1] &lt;&lt; 1) % mod;
        c[i][i] = 1, c[i][0] =1;
        for(int j = 1; j &lt; i; j++)
            c[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod;
    }

    f[0] = 0, f[1] = 0;
    for(int i = 2; i &lt; maxn; i++) {
        int fz = 0;
        for(int j = 0; j &lt; i; j++)
            fz = (1ll * fz + (1ll * c[i][j] * f[j]) % mod) % mod;
        fz = (1ll * fz + 1ll * c[i][2] * mi[i-1]) % mod;
        f[i] = (1ll * fz * q_mod(mi[i] - 1 , mod - 2)) % mod;
       // cout &lt;&lt; f[i] &lt;&lt; &quot; &quot; &lt;&lt; fz &lt;&lt; endl;
    }

    for(int i = 1; i &lt; maxn; i ++) {
        int res = 0;
        for(int j = 1; j &lt;= i; j ++) 
            res = (1ll * res + f[j]) % mod;
        res = (1ll * res * q_mod(i, mod - 2) % mod);
        ans[i] = res;
    } 

}

signed main(){
    init();
    while(cin &gt;&gt; n) {
        cout &lt;&lt; ans[n] &lt;&lt; endl;
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/07/30/2019杭电多校第二场 K Keen On Everything But Triangle HDU 6601 主席树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/30/2019杭电多校第二场 K Keen On Everything But Triangle HDU 6601 主席树/" itemprop="url">2019杭电多校第二场 K Keen On Everything But Triangle HDU 6601 主席树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-30T08:37:24+08:00">
                2019-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>给了长度为n得序列<br>问 l r 区间最大得三角形周长<br>首先 ai 在 1e9 之内 所以最多跑50 个边就确定是否存在 合法三角形了<br>所以这里建主席树维护区间k值就好 记得主席树初始化除了建树 还要 tot = 0</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e5 + 5;

int n, m;
int a[maxn], b[maxn];
struct node {
    int lc,rc;
    int val;
} tree[maxn * 20];
int tot,root[maxn];

int build(int l, int r) {
    int p = ++ tot;
    if(l == r) {
        tree[p].val = 0;
        return p;
    }
    int mid = l + r &gt;&gt; 1;
    tree[p].lc = build(l, mid);
    tree[p].rc = build(mid + 1, r);
    tree[p].val = tree[tree[p].lc].val + tree[tree[p].rc].val;
    return p;
}

int ins(int now, int l, int r, int x, int val) {
    int p = ++ tot;
    tree[p] = tree[now];
    if(l == r) {
        tree[p].val += val ;
        return p;
    }
    int mid = l + r &gt;&gt; 1;
    if(x &lt;= mid) 
        tree[p].lc = ins(tree[now].lc, l, mid, x, val);
    else 
        tree[p].rc = ins(tree[now].rc, mid + 1, r, x, val);
    tree[p].val = tree[tree[p].lc].val + tree[tree[p].rc].val;
    return p;
}

int ask(int p, int q, int l, int r, int k) {
    if(l == r) {
        return l;
    }
    int mid = l + r &gt;&gt; 1;
    int cnt = tree[tree[p].lc].val - tree[tree[q].lc].val ;
    if(k &lt;= cnt) 
        return ask(tree[p].lc, tree[q].lc, l, mid, k);
    else 
        return ask(tree[p].rc, tree[q].rc ,mid + 1, r, k - cnt);
}

signed main(){
    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m)){
        tot = 0;
        for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]), b[i] = a[i];
        sort(b + 1, b + 1 + n);
        int cnt = unique(b + 1, b + 1 + n) - b - 1;
        root[0] = build(1, cnt);
        for(int i = 1; i &lt;= n; i++) {
            int pos = lower_bound(b + 1, b + 1 + cnt, a[i]) - b;
            root[i] = ins(root[i - 1], 1, cnt, pos, 1);
        }
        while(m -- ){
            int l, r;
            scanf(&quot;%d %d&quot;, &amp;l, &amp;r);
            int num = r - l + 1;
            if(num &lt; 3) {
                printf(&quot;-1\n&quot;);
                continue;
            }
            long long ans = -1;
            for(int i = num; i &gt;= max(3, num - 45); i -- ){
                int a1 = b[ask(root[r], root[l - 1], 1, cnt, i)];
                int b1 = b[ask(root[r], root[l - 1], 1, cnt, i - 1)];
                int c1 = b[ask(root[r], root[l - 1], 1, cnt, i - 2)];
                if(1ll * a1 + b1 &gt; c1 &amp;&amp; 1ll * a1 - b1 &lt; c1) {
                    ans = 1ll * a1 + b1 + c1;
                    break;
                }
            }
            printf(&quot;%lld\n&quot;, ans);
        }
    } 
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/07/28/2019牛客暑期多校(第四场) 写题记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/28/2019牛客暑期多校(第四场) 写题记录/" itemprop="url">2019牛客暑期多校(第四场) 写题记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-28T11:39:02+08:00">
                2019-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/题集/" itemprop="url" rel="index">
                    <span itemprop="name">题集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="A-meeting"><a href="#A-meeting" class="headerlink" title="A meeting"></a>A meeting</h3><p>给了些关键点 在一棵树上 选取一个点让他们相聚 时间最短<br>其实就是求树直径 不过这次dfs完 我们找最远点的时候只看标记点 第二次dfs完也一样</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e5 + 5;

int n, m, cnt;
int head[maxn], d[maxn];
int to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1];
bool v[maxn];

void ade(int a, int b) {
    to[++ cnt] = b;
    nxt[cnt] = head[a];
    head[a] = cnt;
}

void dfs(int x, int pre) {
    for(int i = head[x]; i; i = nxt[i]){
        int y = to[i];
        if(y == pre) continue;
        d[y] = d[x] + 1;
        dfs(y, x);
    }
}

int main(){
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1, a, b; i &lt; n; i ++) {
        cin &gt;&gt; a &gt;&gt; b;
        ade(a, b), ade(b, a);
    }

    for(int i = 1, a; i &lt;= m; i ++) cin &gt;&gt; a, v[a] = 1;
    d[1] = 0,dfs(1, -1);
    int rt = -1, tmp = -1, ans = -1;
    for(int i = 1; i &lt;= n; i++ ) if(v[i] &amp;&amp; d[i] &gt; tmp) {
        tmp = d[i];
        rt = i;
    }
    d[rt] = 0, dfs(rt, -1);
    for(int i = 1; i &lt;= n; i ++ ) if(v[i] &amp;&amp; d[i] &gt; ans) 
        ans = d[i];
    cout &lt;&lt; (ans + 1) / 2 &lt;&lt; endl;
    return 0;
}</code></pre><h3 id="C-sequence"><a href="#C-sequence" class="headerlink" title="C sequence"></a>C sequence</h3><p>on 是什么做法啊orz<br>给你一个长度n的序列 选取一个数字 和b包含它区间(而且它必须是这个区间的最小值) 使a[i]*(这一区间的和) 最大<br>首先单调栈 处理每个a[ i ] 管理区间(没有比它小的最大连续区间)<br>然后 对 a[ i ] 分2种情况 正负来考虑</p>
<p>大于 0 的情况 显然是 它 管理的区间和 *a[ i ] 因为a[i]&gt;0 同时它肯定是这区间最低点 该区间越长和越大<br>小于 0 的情况 不妨我们维护一个 前缀和 既然它是负数 我们 当前i 到R[ i ]前缀和最好越小越好 而L[ i ] 到 i得和越大越好</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
//#define int long long
using namespace std;
typedef long long ll;
const long long INF = 0x3f3f3f3f3f3f3f3f ;
const int maxn = 3e6 + 5 ;

int n;
ll a[maxn],sum[maxn], b[maxn];
int L[maxn],R[maxn];

struct node {
    ll minsum,maxsum;
} tr[maxn&lt;&lt;2];

void pushup(int rt) {
    tr[rt].minsum=min(tr[rt&lt;&lt;1].minsum,tr[rt&lt;&lt;1|1].minsum);
    tr[rt].maxsum=max(tr[rt&lt;&lt;1].maxsum,tr[rt&lt;&lt;1|1].maxsum);
}

void build(int l,int r,int rt) {
    if(l==r) {
        tr[rt]={sum[l],sum[l]};
        return ;
    }
    int mid=(l+r)&gt;&gt;1;
    build(l,mid,rt&lt;&lt;1);
    build(mid+1,r,rt&lt;&lt;1|1);
    pushup(rt);
}

ll maxquery(int L,int R,int l,int r,int rt){
    if(L&lt;=l&amp;&amp;r&lt;=R){
        return tr[rt].maxsum;
    }
    int mid=(l+r)&gt;&gt;1;
    ll res=-INF;
    if(L&lt;=mid) res=max(res,maxquery(L,R,l,mid,rt&lt;&lt;1));
    if(R&gt;mid) res=max(res,maxquery(L,R,mid+1,r,rt&lt;&lt;1|1));
    return res;
}

ll minquery(int L,int R,int l,int r,int rt){
    if(L&lt;=l&amp;&amp;r&lt;=R){
        return tr[rt].minsum;
    }
    int mid=(l+r)&gt;&gt;1;
    ll res=INF;
    if(L&lt;=mid) res=min(res,minquery(L,R,l,mid,rt&lt;&lt;1));
    if(R&gt;mid) res=min(res,minquery(L,R,mid+1,r,rt&lt;&lt;1|1));
    return res;
}

void solLR() {
    stack&lt;int&gt; s;
    for(int i=1; i&lt;=n; i++) {
        while(!s.empty()&amp;&amp;a[s.top()]&gt;=a[i]) s.pop();
        L[i]=(s.empty())?0:s.top();
        s.push(i);
    }
    while(!s.empty()) s.pop();
    for(int i=n; i&gt;=1; i--) {
        while(!s.empty()&amp;&amp;a[s.top()]&gt;=a[i]) s.pop();
        R[i]=(s.empty())?(n+1):s.top();
        s.push(i);
    }
}

signed main() {
    scanf(&quot;%lld&quot;,&amp;n);
    for(int i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]);
    for(int i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;b[i]),sum[i]=sum[i-1]+b[i];

    solLR();
    build(1,n,1);
    ll ans=-INF;
    ll rmin,lmax;
    for(int i=1; i&lt;=n; i++) {
        if(a[i]&lt;0) {
            rmin=minquery(i,R[i]-1,1,n,1);
            lmax=maxquery(L[i]+1,i,1,n,1);
            ans=max(ans,a[i]*(rmin-lmax));
        } else {
            ans=max(ans,a[i]*(sum[R[i]-1]-sum[L[i]]));
        }
    }
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}</code></pre><h4 id="D-triples-I"><a href="#D-triples-I" class="headerlink" title="D triples I"></a>D triples I</h4><p>把这个数据拆成 21212121 的样子<br>n % 3 == 0 直接输出<br>n % 3 == 1 我们考虑 如果 补 1 够 2个 我们直接 n - b[1] n - b[0];<br>如果 二进制中贡献 1 的只有一个 我们选择 b[0] + c[0] 和 n - b[0];<br>else 我们选择 用 2位置补成3倍数 c[0] + c[1] + c[2] 和 n - c[0] - c[1];</p>
<p>n % 3 == 2 与上面相反</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
typedef long long ll;
using namespace std;
vector&lt;ll&gt; b, c;
int main(){
    int cas;
    cin &gt;&gt; cas;
    while(cas --) {
        ll n;
        cin &gt;&gt; n;
        b.clear(), c.clear();
        if(n % 3 == 0) {
            cout &lt;&lt; 1 &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl;
        } else {
            ll x = 1;
            ll i;
            for(i = 0; x &lt;= n; i ++) {
                if((n &gt;&gt; i) &amp; 1) {
                    if(x % 3 == 1) b.push_back(x);
                    else c.push_back(x);
                }
                x &lt;&lt;= 1;
            }

            if(n % 3 == 1) {
                if(b.size() &gt;= 2) cout &lt;&lt; 2 &lt;&lt; &quot; &quot; &lt;&lt; n - b[1] &lt;&lt; &quot; &quot; &lt;&lt; n - b[0] &lt;&lt; endl;
                else if(b.size() == 1) cout &lt;&lt; 2 &lt;&lt; &quot; &quot; &lt;&lt; b[0] + c[0] &lt;&lt; &quot; &quot; &lt;&lt; n - b[0] &lt;&lt; endl;
                else cout &lt;&lt; 2 &lt;&lt; &quot; &quot; &lt;&lt; c[0] + c[1] + c[2] &lt;&lt; &quot; &quot; &lt;&lt; n - c[0] - c[1] &lt;&lt; endl;
            } else {
                if(c.size() &gt;= 2) cout &lt;&lt; 2 &lt;&lt; &quot; &quot; &lt;&lt; n - c[1] &lt;&lt; &quot; &quot; &lt;&lt; n - c[0] &lt;&lt; endl;
                else if(c.size() == 1) cout &lt;&lt; 2 &lt;&lt; &quot; &quot; &lt;&lt; b[0] + c[0] &lt;&lt; &quot; &quot; &lt;&lt; n - c[0] &lt;&lt; endl;
                else cout &lt;&lt; 2 &lt;&lt; &quot; &quot; &lt;&lt; b[0] + b[1] + b[2] &lt;&lt; &quot; &quot; &lt;&lt; n - b[0] - b[1] &lt;&lt; endl;
            }
        }
    }
    return 0;
}</code></pre><h4 id="J-free"><a href="#J-free" class="headerlink" title="J free"></a>J free</h4><p>老题 分层图dj水过</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define A first
#define B second
using namespace std;
const int maxn = 1e3 + 10;

int head[maxn], cnt;
int nxt[maxn &lt;&lt; 1], d[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1];

int n, m, s, t, k;

void ade(int a, int b, int c) {
    to[++cnt] = b;
    d[cnt] = c;
    nxt[cnt] = head[a];
    head[a] = cnt;
}
typedef pair&lt;int, int&gt; P;
typedef pair&lt;int, pair&lt;int, int&gt;&gt; PP;
priority_queue&lt;PP, vector&lt;PP&gt;,greater&lt;PP&gt; &gt; que;

int dis[maxn][maxn];
bool vis[maxn][maxn];

void dj(){
    memset(dis, 0x3f,sizeof (dis));
    dis[s][0] = 0;
    que.push(PP(0, P(s, 0))); /// DIS  POS, K
    while(!que.empty()){
        P u = que.top().B; que.pop();
        if(vis[u.A][u.B]) continue;
        vis[u.A][u.B] = 1;
        for(int i = head[u.A]; i; i = nxt[i]) {
            int v = to[i];
            if(dis[v][u.B] &gt; dis[u.A][u.B] + d[i]) {
                dis[v][u.B] = dis[u.A][u.B] + d[i];
                que.push(PP(dis[v][u.B],P(v, u.B)));
            }
            if(u.B &lt; k &amp;&amp; dis[v][u.B + 1] &gt; dis[u.A][u.B] ) {
                 dis[v][u.B + 1] = dis[u.A][u.B] ;
                 que.push(PP(dis[v][u.B + 1],P(v, u.B + 1)));
            }
        }
    }
}

signed main() {

    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t &gt;&gt; k;
    for(int i = 1, a, b, c; i &lt;= m; i ++) {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        ade(a, b, c), ade(b, a, c);
    }
    dj();
    cout &lt;&lt; dis[t][k] &lt;&lt; endl;
    return 0;
}</code></pre><h4 id="K-number"><a href="#K-number" class="headerlink" title="K number"></a>K number</h4><p>比如说 123400<br>我们先统计单个0<br>ans += 2;</p>
<p>然后前缀和 123400  </p>
<p>#… .% 3后 100111<br>我们可以整除300 的地方 只有 3 和 100 的倍数<br>也就是 2个0已经出现 0 对应的1 之前 第一个 1 之后的数据 就可以整除 300 记录余数 每次遇到便加上</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e5 + 10;

int sum[maxn], cnt[5];
char str[maxn];

int main(){
    long long ans = 0;
    cin &gt;&gt; (str + 1);
    cnt[0] = 1;
    int len = strlen(str + 1);
    for(int i = 1; i &lt;= len; i ++){
        sum[i] = (sum[i - 1] + str[i] - &apos;0&apos;) % 3;
        if((str[i] - &apos;0&apos;) == 0) ans += cnt[0];  
    }

    for(int i = 1; i &lt;= len; i ++ ) {
        if(i + 1 &lt;= len &amp;&amp; str[i] == &apos;0&apos; &amp;&amp; str[i + 1] == &apos;0&apos;) ans += cnt[sum[i]];
        cnt[sum[i]] ++;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/07/26/2019牛客暑期多校(第二场) 写题记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/26/2019牛客暑期多校(第二场) 写题记录/" itemprop="url">2019牛客暑期多校(第二场) 写题记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-26T21:25:51+08:00">
                2019-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/题集/" itemprop="url" rel="index">
                    <span itemprop="name">题集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="A-Eddy-Walker"><a href="#A-Eddy-Walker" class="headerlink" title="A Eddy Walker"></a>A Eddy Walker</h3><p>你有n个点（0～n-1），按顺序形成一个环，初始时你在0的位子，你随机顺时针走一步或者逆时针走一步<br>问你全部路过完时停在哪里的概率 除了 0 点 其他是等可能的 特判 一个点 就好</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define fastio ios::sync_with_stdio(false);cin.tie(0);
typedef long long ll;
const int maxn = 1000 + 5;
const int mod = 1e9 + 7;

int n, m, t, ans;

int q_mod(int a, int b){
    int res = 1;
    for(; b; b &gt;&gt;= 1){
        if(b &amp; 1) res = 1ll*res * a % mod;
        a = 1ll*a * a % mod;
    }
    return res;
}

int main(){
    fastio;
    cin &gt;&gt; t;
    ans = 1;
    while(t--) {
        cin &gt;&gt; n &gt;&gt; m;
        if(n == 1){
            ans*=1;
            cout &lt;&lt; ans &lt;&lt; endl;
        }
        else if(m == 0){
            ans = 0;
            cout &lt;&lt; 0 &lt;&lt; endl;

        }
        else cout &lt;&lt; (ans = (1ll*ans * q_mod(n - 1, mod - 2)%mod)) &lt;&lt; endl;
    }
    return 0;
}</code></pre><h3 id="D-Kth-Minimum-Clique"><a href="#D-Kth-Minimum-Clique" class="headerlink" title="D Kth Minimum Clique"></a>D Kth Minimum Clique</h3><p>考察关于团的知识<br>团 加入一个点 这个点 必须与其他点 相连 相当于 这个点集合 是个完全图<br>加入这个点 即这个点集合的点 与 未在点集的点 &amp; 运算 当前 点集依然是 之前点集合 便可以加入<br>BFS 拓展这个团就好 对每个团 记录它最后的点 我们按顺序加入 每次扫它记录最后点位置之后的加入 就可以去重</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;bitset&gt;
#include &lt;queue&gt;
#include &lt;string&gt;
using namespace std;
#define fastio ios::sync_with_stdio(false);cin.tie(0);
typedef long long ll;
const int maxn = 105;

int n, k;
int w[maxn];
bitset&lt;105&gt; f[maxn];

struct node{
    ll val;
    int p;
    bitset&lt;105&gt; vis;
    bool operator &lt; (const node &amp;a)const {
        return val &gt; a.val;
    }
};

priority_queue&lt;node&gt; que;

int main(){
    cin &gt;&gt; n &gt;&gt; k;
    for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; w[i];
    for(int i = 1; i &lt;= n; i ++) {
        string s;
        cin &gt;&gt; s;
        for(int j = 0; j &lt; n; j++) f[i][j + 1] = s[j] - &apos;0&apos;;
    }
    que.push(node{0, 0, bitset&lt;105&gt;(0)});
    while(!que.empty()){
        node tmp = que.top(); que.pop();
        k--;
        if(k == 0) {
            cout &lt;&lt; tmp.val &lt;&lt; endl;
            return 0;
        }
        bitset&lt;105&gt; v = tmp.vis;
        for(int i = tmp.p + 1; i &lt;= n; i ++) {
            if(((v &amp; f[i]) == v)){
                v[i] = 1;
                int p;
                for(int i = 0; i &lt;= n; i ++) if(v[i]) p = i;
                que.push(node{tmp.val + w[i], p, v});
                v[i] = 0;
            }
        }
    }
    cout &lt;&lt; -1 &lt;&lt; endl;
    return 0;
}</code></pre><h3 id="F-Partition-problem"><a href="#F-Partition-problem" class="headerlink" title="F Partition problem"></a>F Partition problem</h3><p>这题重点不是剪枝 而是 最后我们统计ans 我们不应该N^2求 必然T 而是在过程中 就进行 对这个分集合 的竞争度计算 就不tle了orz</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int N = 20;
typedef long long LL;

int n;
LL v[N + N][N + N], ans;
int a[N], b[N];

void dfs(int u, int cnt1, int cnt2, LL sum) {
    if(cnt1 &gt; n || cnt2 &gt; n) return ;
    if(cnt1 == n &amp;&amp; cnt2 == n) {
        ans = max(sum, ans);
        return ;
    }
    LL tmp = 0;
    if(cnt1 &lt; n){
        a[cnt1 + 1] = u;
        for(int i = 1; i &lt;= cnt2; i ++) tmp += v[u][b[i]];
        dfs(u + 1, cnt1 + 1, cnt2, sum + tmp);
    }
    tmp = 0;
    if(cnt2 &lt; n) {
        b[cnt2 + 1] = u;
        for(int i = 1; i &lt;= cnt1; i ++) tmp += v[u][a[i]];
        dfs(u + 1, cnt1, cnt2 + 1, sum + tmp);
    }
}

int main() {
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= 2 * n; i ++ )
        for(int j = 1; j &lt;= 2 * n; j ++ )
            cin &gt;&gt; v[i][j];

    dfs(1, 0, 0, 0);
    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}</code></pre><h4 id="H-Second-Large-Rectangle"><a href="#H-Second-Large-Rectangle" class="headerlink" title="H Second Large Rectangle"></a>H Second Large Rectangle</h4><p>悬线法 单调栈维护都是一样的东西<br>只要记录下标就好 去重<br>当时我写的很暴力啊 23333 全枚举出来居然没有T</p>
<pre><code>#include &lt;bits/stdc++.h&gt;

using namespace std;
const int maxn = 1000 + 5;

int n, m;
int h[maxn][maxn];
int q[maxn], l[maxn], r[maxn];

int sol(int l[], int a[]){
    a[0] = -1;
    int t = 0;
    for(int i = 1; i &lt;= m; i ++ ) {
        while(a[q[t]] &gt;= a[i]) t --;
        l[i] = q[t] + 1;
        q[ ++ t ] = i;
    }
    return 0;
}

struct node{
    int a,b,c,d;
    int ar;
    bool operator &lt; (node const &amp;aaa) const {
        return ar &gt; aaa.ar;
    }
};

vector&lt;node&gt; aa;

int ans1, ans2, ans3, ans;

int work(int a[], int kk){
    sol(l, a);
    reverse(a + 1, a + 1 + m);
    sol(r, a);
    reverse(a + 1, a + 1 + m);
    int res = 0;

    for(int i = 1; i &lt;= m; i ++ ) {
        int le = l[i];
        int ri = m + 1 - r[m - i + 1];
        res = max(res, a[i] * (ri - le + 1));
        if((ri - le + 1) * a[i]) {
                aa.push_back(node{kk - a[i] + 1,l[i], kk , ri, (ri - le + 1) * a[i]});
                if(a[i] &gt; 1) {
                    aa.push_back(node{kk - a[i],l[i], kk , ri, (ri - le + 1) * (a[i] - 1)});
                }
                if((ri - le + 1) &gt; 1) {
                     aa.push_back(node{kk - a[i] + 1,l[i], kk , ri - 1, (ri - le) * (a[i])});
                }
        }
    }
    return res;
}

char mp[maxn][maxn];

int main(){
    cin &gt;&gt; n &gt;&gt; m;
    int ans = 0;
    for(int i = 1; i &lt;= n; i ++ ) {
        cin &gt;&gt; (mp[i] + 1);
        for(int j = 1; j &lt;=m; j ++ ) {
            if(mp[i][j] == &apos;1&apos;) h[i][j] = h[i - 1][j] + 1;
            else continue;
        }
         work(h[i], i);
    }
    int f = 1;
    if(aa.size() == 0) {
        cout &lt;&lt; 0 &lt;&lt; endl;
        return 0;
    }
   sort(aa.begin(), aa.end());
    int a = aa[0].a, b = aa[0].b , c = aa[0].c, d = aa[0].d;
    for(int i = 0; i &lt; aa.size(); i++) {
        //cout &lt;&lt; aa[i].a &lt;&lt; &quot; &quot; &lt;&lt; aa[i].b &lt;&lt; &quot; &quot; &lt;&lt; aa[i].c &lt;&lt; &quot; &quot; &lt;&lt; aa[i].d  &lt;&lt; &quot; &quot;  &lt;&lt; aa[i].ar &lt;&lt; endl;
        if(a != aa[i].a || b != aa[i].b || c != aa[i].c || d != aa[i].d) {
             f = 0;
            cout &lt;&lt; aa[i].ar &lt;&lt; endl;
            break;
        }
    }
  //  cout &lt;&lt; aa.size() &lt;&lt; endl;
    if(f) cout &lt;&lt; 0 &lt;&lt; endl;
    // for(int i = 1; i &lt;= n; i ++ ){
    //     for(int j = 1; j &lt;= m; j ++ ){
    //         cout &lt;&lt; h[i][j] &lt;&lt; &quot; &quot;;
    //     }cout &lt;&lt; endl;
    // }

  //  cout &lt;&lt; ans2 &lt;&lt; endl;
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/07/25/ubuntu 18.04 基础配置 (编译环境 C++ & py +桌面环境 + gnome 插件)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/25/ubuntu 18.04 基础配置 (编译环境 C++ & py +桌面环境 + gnome 插件)/" itemprop="url">ubuntu 18.04 基础配置 (编译环境 C++ & py /桌面环境 / gnome 插件)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-25T21:22:45+08:00">
                2019-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/系统配置记录/" itemprop="url" rel="index">
                    <span itemprop="name">系统配置记录</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="PC-型号"><a href="#PC-型号" class="headerlink" title="PC 型号"></a>PC 型号</h1><h5 id="本人电脑是-小米pro-15-6寸-MX150-版本-ubuntu上无指纹支持驱动-目前-2019-7-25-我觉得-20-年前-是不太可能的"><a href="#本人电脑是-小米pro-15-6寸-MX150-版本-ubuntu上无指纹支持驱动-目前-2019-7-25-我觉得-20-年前-是不太可能的" class="headerlink" title="本人电脑是 小米pro 15.6寸 MX150 版本 ubuntu上无指纹支持驱动(目前 2019:7:25 我觉得 20 年前 是不太可能的"></a>本人电脑是 小米pro 15.6寸 MX150 版本 ubuntu上无指纹支持驱动(目前 2019:7:25 我觉得 20 年前 是不太可能的</h5><p>22年有可能出)</p>
<p>ps： 如果非要享受 指纹这玩意 建议debian 这个针对小米pro 出过一系列更新 有指纹什么的</p>
<p>评价小米pro 15.6 MX150 屏幕出众 但也就屏幕出众了… 大部分机子 用久了 尤其是风扇高速转 突然停转 发出异响 多次这样<br>低速时也会有较小的异响 硬件问题 用久了 重度用的 都有</p>
<p>官网下的 ubuntu 镜像 U盘启动器直接烧一个就行</p>
<h3 id="建议最小安装-不按照不必要应用"><a href="#建议最小安装-不按照不必要应用" class="headerlink" title="建议最小安装 不按照不必要应用"></a>建议最小安装 不按照不必要应用</h3><p>默认安装 双系统 什么的也就是 往空盘直接放 我都默认按的 (本身win10 双系统)</p>
<p>安装完之后<br>一下软件<br>直接再 软件更新 应用里换 阿里源</p>
<p>有些 更新 和 软件要求重启 我们之后统一处理</p>
<p><a href="https://www.wps.cn/product/wpslinux/" target="_blank" rel="noopener"> https://www.wps.cn/product/wpslinux/ </a><br>WPS<br><a href="http://www.ubuntuchrome.com/" target="_blank" rel="noopener"> http://www.ubuntuchrome.com/ </a> chrome google<br><a href="https://music.163.com/#/download" target="_blank" rel="noopener"> https://music.163.com/#/download </a> 网易云音乐<br><a href="https://code.visualstudio.com/download" target="_blank" rel="noopener"> https://code.visualstudio.com/download
</a> vscode<br>sudo apt install git ///git</p>
<p>从设置找到语言-&gt;管理安装语言，待更新安装完成，设置为fcitx<br><a href="https://pinyin.sogou.com/linux/?r=pinyin" target="_blank" rel="noopener"> https://pinyin.sogou.com/linux/?r=pinyin
</a> 安装 SOUGOU 这个有些机子要重启 暂时别重启<br>在这个github 里面选择TIM 微信安装<br><a href="https://github.com/wszqkzqk/deepin-wine-ubuntu" target="_blank" rel="noopener"> https://github.com/wszqkzqk/deepin-wine-ubuntu
</a></p>
<p>C++ 环境 其实正常你更新了 这些环境都是ubuntu自带的</p>
<h2 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h2><pre><code>sudo apt-get install vim
sudo apt-get install gcc
sudo apt-get install g++
sudo add-apt-repository ppa:pasgui/ppa
sudo apt-get update
sudo apt-get install codeblocks
sudo apt-get install codeblocks-contrib</code></pre><p>vscode 配置 c++ py<br>py 暂时不升级 下载pip<br>c++ launch.json</p>
<pre><code>{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;(gdb) Launch&quot;,
            &quot;type&quot;: &quot;cppdbg&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/${fileBasenameNoExtension}.out&quot;,
            &quot;args&quot;: [],
            &quot;stopAtEntry&quot;: false,
            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,
            &quot;environment&quot;: [],
            &quot;externalConsole&quot;: true,
            &quot;MIMode&quot;: &quot;gdb&quot;,
            &quot;preLaunchTask&quot;: &quot;build&quot;, 
            &quot;setupCommands&quot;: [
                {
                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                    &quot;ignoreFailures&quot;: true
                }
            ]
        }
    ]
}</code></pre><p>c++ settings.json</p>
<pre><code>{
    &quot;files.associations&quot;: {
        &quot;iostream&quot;: &quot;cpp&quot;
    }
}</code></pre><p>c++ taks.json</p>
<pre><code>{
    &quot;tasks&quot;: [
        {
            &quot;label&quot;: &quot;build&quot;,
            &quot;type&quot;: &quot;shell&quot;,
            &quot;command&quot;: &quot;g++&quot;,
            &quot;args&quot;: [&quot;-g&quot;, &quot;${file}&quot;, &quot;-std=c++11&quot;, &quot;-o&quot;, &quot;${fileBasenameNoExtension}.out&quot;]
        }
     ]
}</code></pre><p>py launch.json</p>
<pre><code>{
    // 使用 IntelliSense 了解相关属性。 
    // 悬停以查看现有属性的描述。
    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [

        {
            &quot;name&quot;: &quot;Python&quot;,
            &quot;type&quot;: &quot;python&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${file}&quot;,
            &quot;console&quot;: &quot;externalTerminal&quot;
            //“integratedTerminal”
            // &quot;externalTerminal&quot;
        }
    ]
}



# 1. 更新系统包
sudo apt-get update
sudo apt-get upgrade

# 2. 安装Pip
sudo apt-get install python-pip

# 3. 检查 pip 是否安装成功
pip -V</code></pre><p>显卡驱动<br>阿里源 一般NV都有 直接再软件和更新 里找 附加驱动就行<br>现在版本是390 官方给了 431 版本了 有点小问题 还行 不建议去更新<br>小米pro 开集显就好 如果你想玩游戏 还是win吧 切换很方便</p>
<h1 id="TLP-和-GRUB-修复引导"><a href="#TLP-和-GRUB-修复引导" class="headerlink" title="TLP 和 GRUB 修复引导"></a>TLP 和 GRUB 修复引导</h1><p>Tlp 简直NB</p>
<h2 id="如果出现-耳机杂音-开启TLP-请关掉"><a href="#如果出现-耳机杂音-开启TLP-请关掉" class="headerlink" title="如果出现 耳机杂音 开启TLP 请关掉"></a>如果出现 耳机杂音 开启TLP 请关掉</h2><p>编辑 tlp 配置文件 让 <code>sound_save_power = 0</code> 重点划线</p>
<p>安装完tlp 和//// 一般不需要 grub 修复<br>tlp 下载安装不需要配置</p>
<h3 id="grub"><a href="#grub" class="headerlink" title="grub"></a>grub</h3><p>引导修复 ps 一般用不上</p>
<pre><code>sudo add-apt-repository ppa:yannubuntu/boot-repair
sudo apt-get update
sudo apt-get install -y boot-repair</code></pre><h3 id="TLP"><a href="#TLP" class="headerlink" title="TLP"></a>TLP</h3><p>不需要配置 按完就好 默认auto的 笔记本够用的</p>
<pre><code> sudo add-apt-repository ppa:linrunner/tlp
sudo apt-get update
sudo apt-get install tlp tlp-rdw
 sudo apt-get insta</code></pre><p>Gnome 插件 不一定非得要Gnome 桌面 大部分可以直接用的<br>建议百度 最小安装 桌面<br>//// //sudo apt-get install gnome</p>
<p>gnome 插件</p>
<h3 id="GNOME-Shell-扩展"><a href="#GNOME-Shell-扩展" class="headerlink" title="GNOME Shell 扩展"></a>GNOME Shell 扩展</h3><pre><code>sudo apt install gnome-tweak-tool 管理各种美化的用的
sudo apt install chrome-gnome-shell  // usr主题 插件</code></pre><p><a href="https://extensions.gnome.org/" target="_blank" rel="noopener"> https://extensions.gnome.org/ </a><br>我用的 不多 以下直接搜就好<br>其实还有剪切板插件 Clipboard Indicator<br>截图插件 Screenshot Tool</p>
<pre><code>Alt-Tab Switcher Popup Delay Removal  
AlternateTab
Auto Move Windows  
Battery Percentage  
Dynamic Panel Transparency
Impatience
OpenWeather  
Pixel Saver
TopIcons  
User Themes
VSCode Search Provider  </code></pre><h3 id="双系统-时间同步"><a href="#双系统-时间同步" class="headerlink" title="双系统 时间同步"></a>双系统 时间同步</h3><p>看情况了</p>
<pre><code>sudo apt install ntpdate
sudo ntpdate time.windows.com
sudo hwclock --localtime --systohc ok</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/07/24/2019 杭电多校第一场 E HDU 6582 Path (最短路图上的最小割)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/24/2019 杭电多校第一场 E HDU 6582 Path (最短路图上的最小割)/" itemprop="url">2019 杭电多校第一场 E HDU 6582 Path (最短路图上的最小割)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-24T19:30:32+08:00">
                2019-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/题集/" itemprop="url" rel="index">
                    <span itemprop="name">题集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>E HDU 6582 Path<br>使当前最短路 权值变了就行 同时坎的权值尽可能少<br>我们考虑求出最短路图 然后跑最小割<br>可以确定 d[v] == DJ.val[i] + d[u] 就是 最短路图上的边 加入网络流图中</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;
typedef long long ll;
const int maxn = 1e4 + 5;
typedef pair&lt;ll, int&gt; P;
const ll INF = 0x3f3f3f3f3f3f3f3f;
int n, m, cas;

ll d[maxn];
struct GDJ{
    int head[maxn], cnt;
    int to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1];
    ll val[maxn &lt;&lt; 1];

    void init(){
        memset(head, -1, (n + 5) * sizeof(int));
        cnt = -1;
    }

    void ade(int a, int b, ll c) {
        to[++cnt] = b;
        nxt[cnt] = head[a];
        val[cnt] = c;
        head[a] = cnt;
    }

    bool vis[maxn];
    void dj(){
        priority_queue&lt;P, vector&lt;P&gt;, greater&lt;P&gt; &gt; que;
        memset(d, 0x3f, (n + 5) * sizeof(ll));
        memset(vis, 0, (n + 5) * sizeof(bool));
        d[1] = 0;
        que.push(P(0, 1));
        while(!que.empty()){
            P p = que.top(); que.pop();
            int u = p.second;
            if(vis[u]) continue;
            vis[u] = 1;
            for(int i = head[u]; ~i; i = nxt[i]){
                int v = to[i];
                if(d[v] &gt; d[u] + val[i]){
                    d[v] = d[u] + val[i];
                    que.push(P(d[v], v));
                }
            }
        }
    }
}DJ;

struct GDC{
    int depth[maxn], cur[maxn], head[maxn], cnt;
    int to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1];
    ll val[maxn &lt;&lt; 1];

    void init(){
        memset(head, -1, (n + 5) * sizeof(ll));
        cnt = -1;
    }

    void ade(int a, int b, ll c) {
        to[++cnt] = b;
        nxt[cnt] = head[a];
        val[cnt] = c;
        head[a] = cnt;
    }

    bool bfs(){
        queue&lt;int&gt; que;
        que.push(1);
        memset(depth, 0, (n + 5) * sizeof(int));
        depth[1] = 1;
        while(!que.empty()){
            int u = que.front(); que.pop();
            for(int i = head[u]; ~i; i = nxt[i]) {
                if(val[i] &gt; 0 &amp;&amp; depth[to[i]] == 0) {
                    depth[to[i]] = depth[u] + 1;
                    que.push(to[i]);
                }
            }
        } 
        if(depth[n]) return 1;
        else return 0;
    }

    ll dfs(int u, ll dist){
        if(u == n) return dist;
        for(int &amp;i = cur[u]; ~i; i = nxt[i]) {
            if(depth[to[i]] == depth[u] + 1 &amp;&amp; val[i] &gt; 0){
                ll tmp = dfs(to[i], min(dist, val[i]));
                if(tmp &gt; 0) {
                    val[i] -= tmp;
                    val[i ^ 1] += tmp;
                    return tmp;
                }
            }
        }
        return 0;
    }

    ll dinic() {
        ll res =0, d;
        while(bfs()){
            for(int i = 0; i &lt;= n; i ++) cur[i] = head[i];
            while(d = dfs(1,INF)) res += d;
        }
        return res;
    }
}DC;

int main() {
    cin &gt;&gt; cas;
    while(cas --) {
        cin &gt;&gt; n &gt;&gt; m;
        DJ.init();
        for(int i = 1; i &lt;= m; i++) {
            int a, b; ll c;
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
            DJ.ade(a, b, c);
        }

        DJ.dj();
    //    cout &lt;&lt; &quot;              &quot; &lt;&lt; d[n] &lt;&lt; endl;
    //    for(int i = 1; i &lt;= n; i ++) cout &lt;&lt; d[i] &lt;&lt; endl;
        if(d[n] == INF) {
            cout &lt;&lt; 0 &lt;&lt; endl;
            continue;
        }
        DC.init();
        for(int u = 1; u &lt;= n; u ++) {
            for(int i = DJ.head[u]; ~i; i = DJ.nxt[i]){
                int v = DJ.to[i];
                ll cst = DJ.val[i];
                if(d[v] == DJ.val[i] + d[u]){
                //    cout &lt;&lt; u &lt;&lt; &quot; &quot; &lt;&lt; v &lt;&lt; endl;
                    DC.ade(u, DJ.to[i], cst), DC.ade(DJ.to[i],u,0);
                }
            }
        }

        cout &lt;&lt; DC.dinic() &lt;&lt; endl;
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/07/24/2019 ICPC 南昌现场赛 重现（部分）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/24/2019 ICPC 南昌现场赛 重现（部分）/" itemprop="url">2019 ICPC 南昌现场赛 重现（部分）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-24T19:25:43+08:00">
                2019-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/题集/" itemprop="url" rel="index">
                    <span itemprop="name">题集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="A-Attack"><a href="#A-Attack" class="headerlink" title="A. Attack"></a>A. Attack</h4><p>poj 3123<br>板子题 斯坦纳树<br>板子 如下</p>
<pre><code>const int maxm=2009;
const int maxn=39;
const int inf=0x3f3f3f3f;

struct Edge{
    int v,w,next;
}edge[maxm];

int head[maxn],top;

void init(){
    memset(head,-1,sizeof(head));
    top=0;
}

void add(int u,int v,int w){
    edge[top].v=v;
    edge[top].w=w;
    edge[top].next=head[u];
    head[u]=top++;
}

queue&lt;int&gt; q;

int stns[1&lt;&lt;9][maxn];
bool vis[1&lt;&lt;9][maxn];

void spfa(int sta){
    int u,v,w;
    while(!q.empty()){
        u=q.front(); q.pop();
        vis[sta][u]=0;
        for(int i=head[u];i!=-1;i=edge[i].next){
            v=edge[i].v;
            w=edge[i].w;
            if(stns[sta][v]&gt;stns[sta][u]+w){
                stns[sta][v]=stns[sta][u]+w;
                if(!vis[sta][v]){
                    vis[sta][v]=1;
                    q.push(v);
                }
            }
        }
    }
}
int can[maxn];//为1表示这个点是点集中的点;

int STNS(int n,int id){//所有点数,斯坦纳点个数;
    int MAX=(1&lt;&lt;id)-1;
    memset(stns,0x3f,sizeof(stns));
    for(int i=1;i&lt;=n;++i)
        if(can[i]) stns[(1&lt;&lt;id)-1][i]=0;
    for(int sta=1;sta&lt;=MAX;++sta){
        for(int i=1;i&lt;=n;++i){
            for(int son=sta&amp;(sta-1);son;son=(son-1)&amp;sta)
                stns[sta][i]=min(stns[sta][i],stns[son][i]+stns[sta-son][i]);
            if(stns[sta][i]!=inf&amp;&amp;vis[sta][i]==0){
                q.push(i);
                vis[sta][i]=1;
            }
        }
        spfa(sta);
    }
    int res=inf;
    for(int i=1;i&lt;=n;++i)
        res=min(res,stns[MAX][i]);
    return res;
}</code></pre><h4 id="F-Sequence"><a href="#F-Sequence" class="headerlink" title="F. Sequence"></a>F. Sequence</h4><p>找规律 偶数长度 贡献度 0<br>奇数长度 奇数位贡献 1次</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
typedef long long ll;
using namespace std;

const int maxn = 1e5 + 10;
const int INF = 0x3f3f3f3f;
int data[maxn];
int tree[maxn &lt;&lt; 2][2];

void push_up(int rt) {
    tree[rt][0] = tree[rt &lt;&lt; 1][0] ^ tree[rt &lt;&lt; 1 | 1][0] ;
    tree[rt][1] = tree[rt &lt;&lt; 1][1] ^ tree[rt &lt;&lt; 1 | 1][1] ;
}

void buid(int l, int r, int rt) {
    if(l == r) {
        if(l % 2 == 0)
            tree[rt][0] = data[l];
        else
            tree[rt][1] = data[l];
        return;
    }
    int mid = l + r &gt;&gt; 1;
    buid(l, mid, rt &lt;&lt; 1);
    buid(mid + 1, r, rt &lt;&lt; 1 | 1);
    push_up(rt);
}

void update(int L, int d, int l, int r, int rt, int k) {
    if(l == r) {
        tree[rt][k] = d;
        return;
    }
    int mid = l + r &gt;&gt; 1;
    if(L &lt;= mid)
        update(L, d, l, mid, rt &lt;&lt; 1, k);
    else
        update(L, d, mid + 1, r, rt &lt;&lt; 1 | 1, k);
    push_up(rt);
}

int find(int L, int R, int l, int r, int rt, int k) {
    if(L &lt;= l &amp;&amp; R &gt;= r) {
        return tree[rt][k];
    }
    int mid = (l + r) &gt;&gt; 1;
    ll ans = 0;
    if(L &lt;= mid)
        ans ^= find(L, R, l, mid, rt &lt;&lt; 1, k);
    if(R &gt; mid)
        ans ^= find(L, R, mid + 1, r, rt &lt;&lt; 1 | 1, k);
    return ans;
}

int main() {
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    int cas = 1;
    while(t --) {
        int n, m;
        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;data[i]);

        buid(1, n, 1);
        printf(&quot;Case #%d:\n&quot;, cas++);
        while(m--) {
            int cmd, l, r;
            scanf(&quot;%d %d %d&quot;, &amp;cmd, &amp;l, &amp;r);
            if(cmd == 0)
                if(l % 2 == 0)
                    update(l, r, 1, n, 1, 0);
                else
                    update(l, r, 1, n, 1, 1);
            else if((r - l + 1) % 2 == 0) printf(&quot;0\n&quot;);
            else if(l % 2 == 0) printf(&quot;%d\n&quot;, find(l, r, 1, n, 1, 0));
            else printf(&quot;%d\n&quot;, find(l, r, 1, n, 1, 1));
        }
    }
    return 0;
}</code></pre><h4 id="G-Winner"><a href="#G-Winner" class="headerlink" title="G. Winner"></a>G. Winner</h4><p>我们按3个排序 把最大的标记1 然后权值有小到大 不断 扫 把一之后跟新 为1 直到没有跟新退出</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long ll;

const int maxn = 1e5 + 5;
const int INF = 0x3f3f3f3f;

struct node {
    int num;
    int val;
    bool operator &lt; (const node &amp;a) const {
        return val &lt; a.val;
    }
} data[maxn], data2[maxn], data3[maxn];
bool vis[maxn];

int main() {
    int n, m;
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    int a = 0, b = 0, c = 0;
    for(int i = 1; i &lt;= n; i++) {
        data[i].num = i;
        scanf(&quot;%d&quot;, &amp;data[i].val);
        if(data[i].val &gt; data[a].val) a = i;
    }
    for(int i = 1; i &lt;= n; i++) {
        data2[i].num = i;
        scanf(&quot;%d&quot;, &amp;data2[i].val);
        if(data2[i].val &gt; data2[b].val) b = i;
    }
    for(int i = 1; i &lt;= n; i++) {
        data3[i].num = i;
        scanf(&quot;%d&quot;, &amp;data3[i].val);
        if(data3[i].val &gt; data3[c].val) c = i;
    }
    vis[a] = vis[b] = vis[c] = 1;
    sort(data + 1, data + 1 + n);
    sort(data2 + 1, data2 + 1 + n);
    sort(data3 + 1, data3 + 1 + n);

    while(1) {
        bool flag = 0;
        bool tt = 0;
        for(int i = 1; i &lt;= n; i++) {
            if(vis[data[i].num] == 1) flag = 1;
            if(flag == 1 &amp;&amp; vis[data[i].num] == 0) {
                tt = 1;
                vis[data[i].num] = 1;
            }
        }

        flag = 0;
        for(int i = 1; i &lt;= n; i++) {
            if(vis[data2[i].num] == 1) flag = 1;
            if(flag == 1 &amp;&amp; vis[data2[i].num] == 0) {
                tt = 1;
                vis[data2[i].num] = 1;
            }
        }

        flag = 0;
        for(int i = 1; i &lt;= n; i++) {
            if(vis[data3[i].num] == 1) flag = 1;
            if(flag == 1 &amp;&amp; vis[data3[i].num] == 0) {
                tt = 1;
                vis[data3[i].num] = 1;
            }
        }
        if(tt == 0) break;
    }

    while(m--) {
        int p;
        scanf(&quot;%d&quot;, &amp;p);
        if(vis[p] == 1) printf(&quot;YES\n&quot;);
        else printf(&quot;NO\n&quot;);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/07/22/2019牛客暑期多校(第一场) 写题记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/22/2019牛客暑期多校(第一场) 写题记录/" itemprop="url">2019牛客暑期多校(第一场) 写题记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-22T13:09:49+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/题集/" itemprop="url" rel="index">
                    <span itemprop="name">题集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="A-Equivalent-Prefixes"><a href="#A-Equivalent-Prefixes" class="headerlink" title="A. Equivalent Prefixes"></a>A. Equivalent Prefixes</h4><p>很水的单调队列<br>首先说是处理最低位置一样 那么肯定队首存的下标一样<br>其次 1 ~ p 位置区间内每部分最小对应下标一样 那样的话 队列每次进入一个元素就可以想到<br>如果每部分最小下标对应一样 那样队列队尾弹出数量应该是一致的 只需要保证 队列大小一致就完成了<br>第一个可以去掉 因为弹出一致了</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;queue&gt;
using namespace std;

const int maxn = 1e5 + 5;
deque&lt;int&gt; s1;
deque&lt;int&gt; s2;
int a[maxn], b[maxn];
int n;

int main(){
    while(scanf(&quot;%d&quot;, &amp;n) != -1){
        int f = 0;
        while(!s1.empty()) s1.pop_back();
        while(!s2.empty()) s2.pop_back();
        for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, a + i);
        for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, b + i);
        for(int i = 1; i &lt;= n; i ++) {
            while(!s1.empty() &amp;&amp; a[s1.back()] &gt; a[i]) s1.pop_back();
            s1.push_back(i);
            while(!s2.empty() &amp;&amp; b[s2.back()] &gt; b[i]) s2.pop_back();
            s2.push_back(i);
            if(s1.size() != s2.size()){
                cout &lt;&lt; i - 1 &lt;&lt; endl;
                f = 1;
                break;
            }
            //if(s1.front() != s2.front()){
            //    cout &lt;&lt; i - 1 &lt;&lt; endl;
            //    f = 1;
            //    break;
            //} 这个可以去掉 因为 弹出都一致了
        }
        if(!f) cout &lt;&lt; n &lt;&lt; endl;
    }
    return 0;
}</code></pre><h4 id="B-Integration"><a href="#B-Integration" class="headerlink" title="B. Integration"></a>B. Integration</h4><p>数学专业就是不一样啊 啥是复变啊 那个是啥定理啊 他给我张纸 我看的一脸懵逼啊 orz<br>总而言之 1 / [（b * b + x * x）* (c * c + x* x) ]<br>就是 1 / [ (b * b - c * c ) * (c * c + x * x) ] + 1 / [ (c * c - b * b) * (x * x</p>
<ul>
<li>b * b)] ;</li>
</ul>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include &lt;queue&gt;
#define int long long
using namespace std;
typedef long long ll;

const int maxn = 1e3 + 5;
const int mod = 1e9 + 7;

int n;
int a[maxn], b[maxn];

ll pow_mod(ll a, ll b) {
    ll ans = 1; a %= mod;
    while (b) {
        if (b &amp; 1) {
            ans = ans * a % mod;
            b--;
        }
        b &gt;&gt;= 1;
        a = a * a % mod;
    }
    return ans;
}

signed main(){
    while(cin &gt;&gt; n) {

        for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i], b[i] = a[i] * a[i] % mod;
        int ans = 0;

        for(int i = 1; i &lt;= n; i ++) {

            int tmp = 2 * a[i] % mod;

            int tp = a[i] * a[i] % mod;

            for(int j = 1; j &lt;= n; j ++) {
                if(j == i) continue;
                tmp = (tmp * (b[j] - tp)) % mod;
            }

            ans = (ans + pow_mod(tmp, mod - 2)) % mod;
        }

        cout &lt;&lt; (ans+mod)%mod &lt;&lt; endl;
    }
    return 0;
}</code></pre><h4 id="E-ABBA"><a href="#E-ABBA" class="headerlink" title="E. ABBA"></a>E. ABBA</h4><p>贪心的认为 前n个A都是AB的A 后面的都是 BA的 A 补充的 同理B也是<br>dp[i][j] 代表方案数 i 是 A数量 j 是 B 数量<br>那么 我们考虑 i_A - nAB_A 数量 应该是 mBA_A 的数量<br>当出现 i_A - nAB_A &lt; mBA_A 时肯定是A不够 我们选择在之前随便一个位置加上 BA的A 这里就会是 += dp[i][j]的方案数量<br>B 同理</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;
#define int long long
const int mod = 1e9 + 7;
const int maxn = 2e3 + 5;
int dp[maxn][maxn];
int n, m;

signed main(){
    while(cin &gt;&gt; n &gt;&gt; m) {
        for(int i = 0; i &lt;= n + m; i ++) {
            for(int j = 0; j &lt;= m + n; j ++) {
                dp[i][j] = 0;
            }
        }
        dp[0][0] = 1;
        for(int i = 0; i &lt;= n + m; i ++) {
            for(int j = 0; j &lt;= n + m; j ++) {
                if( i - n &lt; j) {
                    dp[i + 1][j] = (dp[i + 1][j] + dp[i][j]) % mod;
                }
                if( j - m &lt; i) {
                    dp[i][j + 1] = (dp[i][j + 1] + dp[i][j]) % mod;
                }
            }
        }
        cout &lt;&lt; dp[n + m][n + m] &lt;&lt; endl;
    }
    return 0;
}</code></pre><h4 id="F-Random-Point-in-Triangle"><a href="#F-Random-Point-in-Triangle" class="headerlink" title="F. Random Point in Triangle"></a>F. Random Point in Triangle</h4><p>这题 不用想 肯定猜 1 到 18 的系数 和面积的关系<br>然后 有一个比较扯的方法<br>就是三角形 每个边取4等分点 平行相连 我们用这个方法算期望 猜系数<br>估了下 在 10 到15 之间 试一试 就wa 1发过了…orz</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

const ll maxn=1e3+10;

ll dp[maxn][maxn];

int main(){
    ll a,b,c,d,e,f,g,S;
    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f){
        S=11*abs((c-a)*(f-b)-(d-b)*(e-a));
        cout&lt;&lt;S&lt;&lt;endl;

    }
    return 0;
}</code></pre><h4 id="H-XOR"><a href="#H-XOR" class="headerlink" title="H. XOR"></a>H. XOR</h4><p>线性基 处理出64 x 64 表达这些数据的 矩阵<br>子集大小处理成 我们选取数据的组合方案和<br>先求出 这n数据 的 线性基 当然他的线性基不唯一<br>我们先求出一个 那么 这个线性基 和外部的组合方案 就是pow(2, N_R + 1) * (n - r)<br>其次 我们考虑 多个线性基的情况 他们的方案数 同样也是pow(2, N_R + 1) 组合<br>为了 避免 我们重复对 剩下的 N_R 进行重复计算 我们只需要 预先处理出N_R基 然后 每次从R基拿一个 暴力搞一遍 看看 这个 vec[i]<br>是不是可以替代掉 就加上这一次的方案</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
const int mod = 1e9 + 7;

int n;
bool vis[maxn];
vector&lt;ll&gt; vec;
ll R[70], N_R[70], tmp[70];
ll a[maxn];

ll q_mod(ll a, ll b) {
    ll res = 1;
    while(b) {
        if(b &amp; 1) res = res * a % mod;
        a = a * a % mod;
        b &gt;&gt;= 1;
    }
    return res;
}

bool ins(ll x, ll base[]){
    for(int i = 63; i &gt;= 0; i--){
        if(x &amp; (1ll &lt;&lt; i)) {
            if(base[i]) x ^= base[i];
            else{
                base[i] = x;
                return 1;
            }
        }
    }
    return 0;
}

int main(){
    while(scanf(&quot;%d&quot;,&amp;n) != EOF) {
        int r = 0;
        vec.clear();
        for(int i = 0; i &lt;= 63; i ++) R[i] = 0;
        for(int i = 1; i &lt;= n; i ++){
            scanf(&quot;%lld&quot;, &amp;a[i]);
            vis[i] = 0;
            if(ins(a[i], R)) vis[i] = 1, r++, vec.push_back(a[i]);
        }
        if(r == n) {
            puts(&quot;0&quot;);
            continue;
        }else{
            ll ans = q_mod(2, n - r - 1) * (n - r) % mod;
            for(int j = 0; j &lt;= 63; j ++) N_R[j] = 0;

            for(int i = 1; i &lt;= n; i ++) {
                if(vis[i]) continue;
                ins(a[i], N_R);
            }

            for(int i = 0; i &lt; vec.size(); i ++ ) {
                int cnt = 0;
                for(int j = 0; j &lt;= 63; j ++) tmp[j] = 0;
                for(int j = 0; j &lt;vec.size(); j ++ ) {
                    if(i == j) continue;
                    ins(vec[j], tmp);
                }

                for(int j = 0; j &lt;= 63; j ++)
                    if(N_R[j]) ins(N_R[j], tmp);

                if(!ins(vec[i], tmp)) ans = (ans + q_mod(2, n - r - 1) ) % mod ;
            }
            printf(&quot;%lld\n&quot;, ans);
        }
    }
    return 0;
}</code></pre><h5 id="I-Points-Division"><a href="#I-Points-Division" class="headerlink" title="I. Points Division"></a>I. Points Division</h5><p>A, B 两个位置 有不同权重<br>不存在a∈A和b∈B，使得xa&gt;=xb且ya&lt;=yb;<br>也就是 对于所有 A 都在 B 左边上方<br>dp[i] = max dp[1~i] + b[i];<br>用线段树处理的是 离散化后 Y轴 每个点对之后位置的贡献度</p>
<p>每次放入一个点 它对之后的点的影响 如果对于 之后某些点低于它 会贡献a[i] 所以我们向y点之前 更新a[i] 的值</p>
<p>如果对于 之后某些点高于它 会贡献b[i] 所以我们向y点之后 更新b[i] 的值</p>
<p>我们每放 一个点到线上 查询 这个点之前可以影响它 的 A 集合 可以贡献最大的值 加上当前这个点的B[i] 是否会变的更大 进行更新<br>这里不在需要dp数组 因为线段树最后维护就是我们的最大值了<br>ps 我们很关键的是要补 0 如果 B集合什么都没有的话<br>我们没有把A的值更新进去 第一个点 1 - 1 会丢掉<br>补个0X3F点 防止 y + 1 越界</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 10;

int n;
struct node {
    int x, y, a, b;
    bool operator &lt; (const node &amp;a) const {
        return x &lt; a.x || (x == a.x &amp;&amp; y &gt; a.y);
    }
} a[maxn];
int ly[maxn];
ll ma[maxn &lt;&lt; 2], lazy[maxn &lt;&lt; 2];

void push_up(int rt) {
    ma[rt] = max(ma[rt &lt;&lt; 1], ma[rt &lt;&lt; 1 | 1]);
}

void push_down(int rt) {
    ma[rt &lt;&lt; 1 | 1] += lazy[rt] ;
    ma[rt &lt;&lt; 1] += lazy[rt];
    lazy[rt &lt;&lt; 1 | 1] += lazy[rt];
    lazy[rt &lt;&lt; 1] += lazy[rt];
    lazy[rt] = 0;
}

void build(int l, int r, int rt){
    ma[rt] = lazy[rt] = 0;
    if(l == r) return ;
    int mid = l + r &gt;&gt; 1;
    build(l, mid, rt &lt;&lt; 1);
    build(mid + 1, r, rt &lt;&lt; 1 | 1);
}

void update1(int L, int l, int r, int rt, ll c) {
    if(l == r) {
        ma[rt] = max(c, ma[rt]);
        return ;
    }
    if(lazy[rt]) push_down(rt);
    int mid = l + r &gt;&gt; 1;
    if(L &lt;= mid) update1(L, l, mid, rt &lt;&lt; 1, c);
    else update1(L, mid + 1, r, rt &lt;&lt; 1 | 1, c);
    push_up(rt);
}

void update2(int L, int R, int l, int r, int rt, ll c) {
    if(L &lt;= l &amp;&amp; R &gt;= r) {
        ma[rt] += c;
        lazy[rt] += c;
        return ;
    }
    if(lazy[rt]) push_down(rt);
    int mid = l + r &gt;&gt; 1;
    if(L &lt;= mid) update2(L, R, l, mid, rt &lt;&lt; 1, c);
    if(R &gt; mid) update2(L, R, mid + 1, r, rt &lt;&lt; 1 | 1, c);
    push_up(rt);
}

ll query(int L, int R, int l, int r, int rt) {
    if(L &lt;= l &amp;&amp; R &gt;= r) return ma[rt];
    if(lazy[rt]) push_down(rt);
    int mid = l + r &gt;&gt; 1;
    ll res = 0;
    if(L &lt;= mid) res = max(query(L, R, l, mid, rt &lt;&lt; 1), res);
    if(R &gt; mid) res = max(query(L, R, mid + 1, r, rt &lt;&lt; 1 | 1), res);
    return res;
}

signed main() {
    while(scanf(&quot;%lld&quot;, &amp;n) != EOF){
        for(int i = 1; i &lt;= n; i ++)
            scanf(&quot;%lld %lld %lld %lld&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].a, &amp;a[i].b), ly[i] = a[i].y;
        ly[n + 1] = 0, ly[n + 2] = 0x3f3f3f3f;
        sort(ly + 1, ly + 2 + n);
        int cnt = unique(ly + 1, ly + 3 + n) - ly - 1;

        for(int i = 1; i &lt;= n; i ++ )
            a[i].y = lower_bound(ly + 1, ly + 1 + cnt, a[i].y) - ly;

        sort(a + 1, a + 1 + n);
        build(1, cnt, 1);
        for(int i = 1; i &lt;= n; i ++) {
            ll tmp = query(1, a[i].y, 1, cnt, 1);
            update1(a[i].y, 1, cnt, 1, tmp + a[i].b);
            update2(1, a[i].y - 1, 1, cnt, 1, a[i].a);
            update2(a[i].y + 1, cnt, 1, cnt, 1, a[i].b);
        }
        printf(&quot;%lld\n&quot;, ma[1]);
    }
    return 0;
}</code></pre><h4 id="J-Fraction-Comparision"><a href="#J-Fraction-Comparision" class="headerlink" title="J. Fraction Comparision"></a>J. Fraction Comparision</h4><p>python 嚎啊</p>
<pre><code>while True:
    try:
        x,y,a,b=map(int,input().split())

        if x * b &gt; y * a:
            print(&quot;&gt;&quot;)
        elif x * b &lt; y * a:
            print(&quot;&lt;&quot;)
        else:
            print(&quot;=&quot;)
    except:
        break</code></pre><p>c 版本<br>官方题解 菜啊当时<br>![官方题解](<a href="https://img-blog.csdnimg.cn/20190722130825795.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190722130825795.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/07/22/《算法竞赛进阶指南》 0x21 ~ 0x24 代码 + 杂谈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/22/《算法竞赛进阶指南》 0x21 ~ 0x24 代码 + 杂谈/" itemprop="url">《算法竞赛进阶指南》 0x21 ~ 0x24 代码 + 杂谈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-22T08:26:47+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/搜索/" itemprop="url" rel="index">
                    <span itemprop="name">搜索</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="树与图的遍历"><a href="#树与图的遍历" class="headerlink" title="树与图的遍历"></a>树与图的遍历</h2><ol>
<li><strong>可达性统计</strong><br>给定一张N个点M条边的有向无环图，分别统计从每个点出发能够到达的点的数量。<br>数据 1≤N,M≤30000 这里folyd 跑 不仅数组开不下 还有n^3的复杂度chun<br>关于 这个点每个状态的用矩阵肯定存不下这些关系 所以可以考虑用int 二进制来进行压缩<br>还有bitset STL 进行非常长长度二进制存储和运算<br>可达性就可以考虑 topsort了 找到循序序列 之后 倒着来吧每个点 或 一下 就 吧可达点 付到上一个 完成统计</li>
</ol>
<pre><code>#include &lt;iostream&gt;
#include &lt;bitset&gt;
#include &lt;queue&gt;
using namespace std;
const int maxn = 3e4 + 5;

int n, m;
int head[maxn], cnt;
int to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1];
int deg[maxn], seq[maxn], k;
bitset&lt;maxn&gt; f[maxn];

void ade(int a, int b){
    to[++ cnt] = b;
    nxt[cnt] = head[a];
    head[a] = cnt;
}

void topsort(){
    queue&lt;int&gt; q;
    for(int i = 1; i &lt;= n; i ++ ) 
        if(deg[i] == 0) q.push(i);
    while(!q.empty()){
        int x = q.front(); q.pop();
        seq[++ k] = x;
        for(int i = head[x]; i; i = nxt[i]) {
            int y = to[i];
            if(-- deg[y] == 0) q.push(y);
        }
    }
}

int main(){
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1, a, b; i &lt;= m; i ++ ) {
        cin &gt;&gt; a &gt;&gt; b;
        ade(a, b);
        deg[b] ++;
    }
    topsort();
    for(int i = n; i &gt;= 1; i --) {
        int x = seq[i];
        f[x][x] = 1;
        for(int j = head[x]; j; j = nxt[j]) 
            f[x] |= f[to[j]];
    }
    for(int i = 1; i &lt;= n; i ++) cout &lt;&lt; f[i].count() &lt;&lt; endl;
    return 0;
}</code></pre><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><ol>
<li><strong>小猫爬山</strong><br>dfs 优化剪枝<br>首先 我们dfs 每次搜遍历一边考虑能装下 放入猫<br>这一操作完后 还原 进行不放入这个猫 加 一辆车的搜索</li>
</ol>
<p>考虑优化 第一 我们排序每次选最大的 可以使开头第一搜索的选择性减低<br>显然 我们也可以加入 如果当前搜索车数量 大于min （n, ans） 直接return 放弃这个不好的解</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int maxn = 100;
int n, m, ans;
int car[maxn], cat[maxn];

void dfs(int num, int cnt){
    if(cnt &gt;= ans) return ;
    if(num == n  + 1) {
        ans = cnt;
        return ;
    }
    for(int i = 1; i &lt;= cnt; i ++) {
        if(car[i] + cat[num] &lt;= m) {
            car[i] += cat[num];
            dfs(num + 1, cnt);
            car[i] -= cat[num];
        }
    }
    car[cnt + 1] = cat[num];
    dfs(num + 1, cnt + 1);
    car[cnt + 1] = 0;
}

bool cmp(int a, int b) {return a &gt; b;}

int main(){
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; cat[i];
    sort(cat + 1, cat + 1 + n, cmp);
    ans = n;
    dfs(1, 0);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</code></pre><ol start="2">
<li>Sudoko (acwing数据)<br>这个题数据好强啊 不预处理位运算超时的<br>首先考虑 选择可选位置最少的框填入搜索<br>其次这题必须加入位运算 行列宫 9位2进制表示出来 lowbit 取出最低位 遍历可选值<br>位元算 记得还原全部状态再进行下次搜索</li>
</ol>
<pre><code>#include &lt;iostream&gt;
using namespace std;

const int N = 9;
int row[N], col[N];
int ones[1 &lt;&lt; N], map[1 &lt;&lt; N];
int g[5][5];
char str[105];

inline int lowbit(int x) {
    return x &amp; -x;
}

inline int get(int x, int y) {
    return row[x] &amp; col[y] &amp; g[x/3][y/3];
}

bool dfs(int cnt) {
    if(cnt == 0) return 1;

    int minv = 10, x, y;
    for(int i = 0 ; i &lt; N; i ++) for(int j = 0; j &lt; N; j ++) 
        if(str[i * 9 + j] == &apos;.&apos;) {
            int t = ones[get(i, j)];
            if(t &lt; minv) minv = t, x = i, y = j;
        }
    for(int i = get(x, y); i; i -= lowbit(i)) {
        int t = map[lowbit(i)];
        row[x] -= 1 &lt;&lt; t;
        col[y] -= 1 &lt;&lt; t;
        g[x/3][y/3] -= 1 &lt;&lt; t;
        str[x * 9 + y] = &apos;1&apos; + t;

        if(dfs(cnt - 1)) return 1;

        row[x] += 1 &lt;&lt; t;
        col[y] += 1 &lt;&lt; t;
        g[x/3][y/3] += 1 &lt;&lt; t;
        str[x * 9 + y] = &apos;.&apos;;

    }
    return 0;
}

void init(){
    for(int i = 0; i &lt; 9; i ++) row[i] = col[i] = (1 &lt;&lt; 9) - 1;
    for(int i = 0; i &lt; 3; i ++) 
        for(int j = 0; j &lt; 3; j ++) 
            g[i][j] = (1 &lt;&lt; 9) - 1; 
}

int main(){
    for(int i = 0; i &lt; N; i ++) map[1 &lt;&lt; i] = i;
    for(int i = 0; i &lt; 1 &lt;&lt; N; i ++) {
        int s = 0;
        for(int j = i; j; j -= lowbit(j)) s ++;
        ones[i] = s;
    }

    while(cin &gt;&gt; str &amp;&amp; str[0] != &apos;e&apos;) {
        init();
        int cnt = 0;
        for(int i =0, k = 0; i &lt; N; i ++) 
            for(int j = 0; j &lt; N; j ++, k ++ ) 
                if(str[k] != &apos;.&apos;) {
                    int t = str[k] - &apos;1&apos;;
                    row[i] -= 1 &lt;&lt; t;
                    col[j] -= 1 &lt;&lt; t;
                    g[i/3][j/3] -= 1 &lt;&lt; t;
                }else cnt ++;

        dfs(cnt); 
        cout &lt;&lt; str &lt;&lt; endl;
    }
    return 0;
}</code></pre><h2 id="优化搜索"><a href="#优化搜索" class="headerlink" title="优化搜索"></a>优化搜索</h2><ol>
<li>小木棍<br>预先处理出所有木棍的总长度，且保证枚举答案的值能被总长度整除。<br>预先处理出最长的和最短的木棍的长度，搜索时从最大长度到最小长度递减枚举。<br>若拼接当前木棍时已用了一根长为X的木棍，则dfs时从长度X开始搜索。<br>若某组拼接不成立 且此时 已拼接的长度为0 或 当前已拼接的长度与刚才枚举的长度之和为最终枚举的答案<br>则可直接跳出循环，因为此时继续枚举其它更小的值时，显然可能情况更少，且同样凑不完。</li>
</ol>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;
const int maxn = 50+5;

int n,m,x,sum,xz,flag,cnt;
bool cmp(int x,int y) {return x&gt;y;}
bool vis[maxn];
int a[maxn];

void dfs(int len,int k,int lenth,int pos){
    if(flag) return ;
    if(k*lenth==sum){
        cout&lt;&lt;lenth&lt;&lt;endl;
        flag=1;
        return ;
    }
    if(sum-len&lt;a[cnt]) return ;
    if(len==lenth){
        dfs(0,k+1,lenth,1);
        return ;
    }
    for(int i=pos;i&lt;=cnt;i++){
        if(!vis[i]&amp;&amp;len+a[i]&lt;=lenth){
            vis[i]=1;
            dfs(len+a[i],k,lenth,i+1);
            vis[i]=0;
            if(len==0||len+a[i]==lenth) break;
            while(a[i]==a[i+1])i++;
        }
    }
}

int main() { 
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;m;
        if(m&lt;=50){
            a[++cnt]=m;
            sum+=m;
        } 
    }
    sort(a+1,a+1+cnt,cmp);
    xz=sum&gt;&gt;1;
    for(int i=a[1];i&lt;=xz;i++){
        if(sum%i==0){
            dfs(0,0,i,1);
            if(flag) break;
        }
    }
    if(!flag) cout&lt;&lt;sum&lt;&lt;endl;
    return 0;
}</code></pre><p>acwing （重写版）</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
const int maxn = 100 + 5;
const int mod = 1e9 + 7;

int n, sum, len;
int a[maxn], cnt;
bool vis[maxn];

bool cmp(int a, int b) {
    return a &gt; b;
}

bool dfs(int k, int len, int p, int lenth){
    if(k * lenth == sum) return 1;
    if(len == lenth) return dfs(k + 1, 0, 1, lenth);
    for(int i = p; i &lt;= cnt; i++){
        if(!vis[i] &amp;&amp; len + a[i] &lt;= lenth){
            vis[i] = 1;
            if(dfs(k, len + a[i], i + 1, lenth)) return 1;
            vis[i] = 0;
            if(len == 0) return 0;
            if(len + a[i] == lenth) return 0;
            while(a[i] == a[i + 1] &amp;&amp; i &lt;= cnt) i++;
        }
    }
    return 0;
}


signed main() {
    while(cin &gt;&gt; n &amp;&amp; n) {
        cnt = 0;
        len = 0;
        sum = 0;
        for(int i = 1, l; i &lt;= n; i ++) {
            vis[i] = 0;
            cin &gt;&gt; l;
            if(l &gt; 50) continue;
            sum += l;
            a[++ cnt] = l;
            len = max (len, l);
        }
        sort(a + 1, a + cnt, cmp);
        for(int i = len; i &lt;= sum; i ++)
            if(sum % i == 0 &amp;&amp; dfs(0, 0, 1, i)) {
                cout &lt;&lt; i &lt;&lt; endl;
                break;
            }
    } 
    return 0;
}</code></pre><ol start="2">
<li>奶油蛋糕<br>体积一定 让多层蛋糕表面积最小<br>最小体积+面积预处理 搜索超过限制return<br>从 上一层 最大r - 1，h - 1 开始搜索 情况树少<br>s + 2 * (n - v) / R[dep + 1] &gt;= ans 放缩出来的公式 。。果然只加一层超了 再加也超</li>
</ol>
<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;
const int maxn = 100 + 5;
const int mod = 1e9 + 7;

int n, m, ans;
int R[maxn], H[maxn]; 
int mins[maxn], minv[maxn];

void dfs(int dep, int v, int s){
    if(minv[dep] + v &gt; n) return ;
    if(mins[dep] + s &gt;= ans) return ;
    if(s + 2 * (n - v) / R[dep + 1] &gt;= ans) return ;

    if(dep == 0) {
        if(v == n) ans = min(ans, s);
        return ;
    }

    for(int r = min((int)sqrt(n - v), R[dep + 1] - 1); r &gt;= dep; r --) {
        for(int h = min((n - v) / r / r, H[dep + 1] - 1); h &gt;= dep; h --) {
            R[dep] = r, H[dep] = h;
            dfs(dep - 1, v + r * r * h, s + 2 * r * h + (dep == m ? r * r : 0));
        }
    }
    return ;
}


signed main() {
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= 25; i ++) {
        minv[i] = minv[i - 1] + i * i * i;
        mins[i] = mins[i - 1] + i * i * 2; 
    }
    R[m + 1] = H[m + 1] = 0x3f3f3f3f;
    ans = 0x3f3f3f3f;
    dfs(m, 0, 0);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</code></pre><h4 id="迭代加深"><a href="#迭代加深" class="headerlink" title="迭代加深"></a>迭代加深</h4><ol>
<li><strong>加成序列</strong><br>预先设置深度， 搜索再树浅位置解</li>
</ol>
<pre><code>#include &lt;iostream&gt;
using namespace std;
const int maxn = 105;

int n;
int path[maxn];

bool dfs(int u, int k){
    if (u == k) return path[u - 1] == n;
    bool vis[maxn] = {0};
    for (int i = u - 1; i &gt;= 0; i -- )
        for (int j = i; j &gt;= 0; j -- ){
            int s = path[i] + path[j];
            if (s &gt; n || s &lt;= path[u - 1] || vis[s]) continue;
            vis[s] = true;
            path[u] = s;
            if (dfs(u + 1, k)) return true;
        }
    return false;
}

int main(){
    path[0] = 1;
    while (cin &gt;&gt; n, n){
        int k = 1;
        while (!dfs(1, k)) k ++ ;
        for (int i = 0; i &lt; k; i ++ ) cout &lt;&lt; path[i] &lt;&lt; &apos; &apos;;
        cout &lt;&lt; endl;
    }
    return 0;
}</code></pre><h5 id="双向搜索"><a href="#双向搜索" class="headerlink" title="双向搜索"></a>双向搜索</h5><ol start="2">
<li><strong>送礼物</strong><br>先优化搜索顺序<br>其次 先搜前一半 dfs出所有情况<br>再dfs后面n个 这样二分查可能最大值 不用在意dp数据量太。。。。orz</li>
</ol>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;
typedef long long ll;
const int maxn = 105;

int n, m, ans, k;
int w[maxn];
int wes[1 &lt;&lt; 24], cnt;

void dfs1(int u, int s) {
    if(u == k) {
        wes[cnt ++] = s;
        return ;
    }
    if((ll)s + w[u] &lt;= m) dfs1(u + 1, s + w[u]);
    dfs1(u + 1, s);
}

void dfs2(int u, int s) {
    if(u == n) {
        int l = 0, r = cnt - 1;
        while(l &lt; r){
            int mid = l + r + 1 &gt;&gt; 1;
            if((ll)wes[mid] + s &lt;= m) l = mid;
            else r = mid - 1;
        }
        if((ll)wes[l] + s &lt;= m) ans = max(ans, wes[l] + s);
        return ;
    }
    if((ll)s + w[u] &lt;= m) dfs2(u + 1, s + w[u]);
    dfs2(u + 1, s);
}

bool cmp(int a, int b) {return a &gt; b;}

int main(){
    cin &gt;&gt; m &gt;&gt; n;
    for(int i = 0; i &lt; n; i ++) cin &gt;&gt; w[i];
    sort(w, w + n, cmp);
    k = n/2 + 2;
    dfs1(0, 0);

    sort(wes, wes + cnt);
    cnt = unique(wes, wes + cnt) - wes;
    dfs2(k, 0);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/07/11/《算法竞赛进阶指南》 0x45 ~ 0x48 代码 + 杂谈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/11/《算法竞赛进阶指南》 0x45 ~ 0x48 代码 + 杂谈/" itemprop="url">《算法竞赛进阶指南》 0x45 ~ 0x48 代码 + 杂谈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-11T15:22:07+08:00">
                2019-07-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/题集/" itemprop="url" rel="index">
                    <span itemprop="name">题集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="点分治"><a href="#点分治" class="headerlink" title="点分治"></a>点分治</h2><p>///淀粉质<br>链接 ： <a href="https://blog.csdn.net/qq_40831340/article/details/90234372" target="_blank" rel="noopener"> https://blog.csdn.net/qq_40831340/article/details/90234372
</a></p>
<h2 id="平衡树"><a href="#平衡树" class="headerlink" title="平衡树"></a>平衡树</h2><p>theap 模板</p>
<pre><code>// treap模板题
// 您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：
//插入x数
//删除x数(若有多个相同的数，因只删除一个)
//查询x数的排名(排名定义为比当前数小的数的个数+1。若有多个相同的数，因输出最小的排名)
//查询排名为x的数
//求x的前驱(前驱定义为小于x，且最大的数)
//求x的后继(后继定义为大于x，且最小的数)
const int maxn = 100000+5;
const int INF = 0x3f3f3f3f;
int siz[maxn];
int s[maxn][3];
int w[maxn],pos[maxn];
int tot;

void up(int i) {siz[i]=siz[s[i][0]]+siz[s[i][1]]+1;}

void spin(int &amp;i,int p) {
    int t=s[i][p];
    s[i][p]=s[t][!p],s[t][!p]=i,up(i),up(t),i=t;
}

void ins(int x,int &amp;i) {
    if(!i) {
        i=++tot,siz[i]=1,w[i]=x,pos[i]=rand();
        return;
    }
    siz[i]++;
    if(x&lt;=w[i]) {
        ins(x,s[i][0]);
        if(pos[s[i][0]]&lt;pos[i])spin(i,0);
    } else {
        ins(x,s[i][1]);
        if(pos[s[i][1]]&lt;pos[i])spin(i,1);
    }
}

void del(int x,int &amp;i) {
    if(w[i]==x) {
        if(s[i][0]*s[i][1]==0) {
            i=s[i][0]+s[i][1];
            return;
        }
        if(pos[s[i][0]]&gt;pos[s[i][1]]) {
            spin(i,1);
            del(x,s[i][0]);
        } else {
            spin(i,0);
            del(x,s[i][1]);
        }
    } else if(w[i]&gt;x)del(x,s[i][0]);
    else del(x,s[i][1]);
    up(i);
}

int find(int x,int i) {
    if(!i)return 1;
    if(w[i]&gt;=x)return find(x,s[i][0]);
    return find(x,s[i][1])+siz[s[i][0]]+1;
}

int ask(int x,int i) {
    if(siz[s[i][0]]==x-1)return w[i];
    if(siz[s[i][0]]&gt;=x)return ask(x,s[i][0]);
    return ask(x-siz[s[i][0]]-1,s[i][1]);
}

int pre(int x,int i) {
    if(!i)return -INF;
    if(w[i]&lt;x)return max(w[i],pre(x,s[i][1]));
    else return pre(x,s[i][0]);
}
int nxt(int x,int i) {
    if(!i)return INF;
    if(w[i]&gt;x)return min(w[i],nxt(x,s[i][0]));
    else return nxt(x,s[i][1]);
}

signed main() {
    cin&gt;&gt;n;
    int root=0;
    while(n--) {
        int cmd;
        cin&gt;&gt;cmd;
        if(cmd==1) cin&gt;&gt;m,ins(m,root);
        if(cmd==2) cin&gt;&gt;m,del(m,root);
        if(cmd==3) cin&gt;&gt;m,cout&lt;&lt;find(m,root)&lt;&lt;endl;
        if(cmd==4) cin&gt;&gt;m,cout&lt;&lt;ask(m,root)&lt;&lt;endl;
        if(cmd==5) cin&gt;&gt;m,cout&lt;&lt;pre(m,root)&lt;&lt;endl;
        cmd==6;
        cin&gt;&gt;m,cout&lt;&lt;nxt(m,root)&lt;&lt;endl;
    }
    return 0;
}</code></pre><p>可持续化<br>链接 <a href="https://blog.csdn.net/qq_40831340/article/details/90733094" target="_blank" rel="noopener"> https://blog.csdn.net/qq_40831340/article/details/90733094
</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
using namespace std;
const signed maxn =  600000+10;
signed trie[maxn * 24][2], latest[maxn * 24];
signed s[maxn], root[maxn], n, m, tot;
inline void ins(int i, int k, int p, int q){
    if(k &lt; 0) {
        latest[q] = i;
        return ;
    }
    int c = s[i] &gt;&gt; k &amp; 1;
    if(p) trie[q][c ^ 1] = trie[p][c ^ 1];
    trie[q][c] = ++tot;
    ins(i, k-1, trie[p][c], trie[q][c]);
    latest[q] = max (latest[trie[q][0]], latest[trie[q][1]]); 
}
signed ask(int now, int val, int k, int limit) {
    if(k &lt; 0) return s[latest[now]] ^ val;
    int c = val &gt;&gt; k &amp; 1;
    if(latest[trie[now][c ^ 1]] &gt;= limit)
        return ask(trie[now][c ^ 1], val, k - 1, limit);
    else 
        return ask(trie[now][c], val, k - 1, limit);
} 
signed main(){
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    latest[0] = -1;
    root[0] = ++tot;
    ins(0, 23, 0, root[0]);
    int x;
    for(int i = 1; i &lt;= n ; i ++ ) {
        scanf(&quot;%d&quot;,&amp;x);
        s[i] = x ^ s[i - 1];
        root[i] = ++ tot;
        ins(i, 23, root[i - 1], root[i]);
    }
    for(int i = 1; i &lt;= m; i ++) {
        int l, r;
        char cmd[2];
        scanf(&quot;%s&quot;,cmd);
        if(cmd[0] == &apos;A&apos;) {
            scanf(&quot;%d&quot;,&amp;x);
            root[++n] = ++ tot;
            s[n] = s[n - 1] ^ x;
            ins(n, 23, root[n - 1], root[n]);
        }else{
            scanf(&quot;%d %d %d&quot;,&amp;l, &amp;r,&amp;x);
            cout &lt;&lt; ask(root[r - 1], x ^ s[n], 23, l - 1) &lt;&lt; endl;
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="ZHXU1998">
            
              <p class="site-author-name" itemprop="name">ZHXU1998</p>
              <p class="site-description motion-element" itemprop="description">等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZHXU1998</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
