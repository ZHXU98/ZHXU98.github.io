<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢">
<meta property="og:type" content="website">
<meta property="og:title" content="蒟蒻最后的倔强">
<meta property="og:url" content="http://zhxu98.github.io/page/7/index.html">
<meta property="og:site_name" content="蒟蒻最后的倔强">
<meta property="og:description" content="等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蒟蒻最后的倔强">
<meta name="twitter:description" content="等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://zhxu98.github.io/page/7/">





  <title>蒟蒻最后的倔强</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?58b7e016a3433eb1162126ec13ec1dbf";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蒟蒻最后的倔强</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">by-zhxu98</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/07/03/《算法竞赛进阶指南》0x01 ~ 0x02 代码 + 杂谈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/03/《算法竞赛进阶指南》0x01 ~ 0x02 代码 + 杂谈/" itemprop="url">《算法竞赛进阶指南》0x01 ~ 0x02 代码 + 杂谈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-03T14:36:24+08:00">
                2019-07-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/题集/" itemprop="url" rel="index">
                    <span itemprop="name">题集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="0x01-位运算"><a href="#0x01-位运算" class="headerlink" title="0x01 位运算"></a>0x01 位运算</h2><p><strong>位运算符</strong></p>
<pre><code>第 i 位为从右往左从0开始数
如果要设置 n 的第 i 位为1，n=（n|（1&lt;&lt;i）；                              
如果要设置 n 的第 i 位为0，n=（n &amp;（~（1&lt;&lt;i））；

&amp; 按位与
如果两个相应的二进制位都为1，则该位的结果值为1，否则为0
| 按位或
两个相应的二进制位中只要有一个为1，该位的结果值为1
^  按位异或
若参加运算的两个二进制位值相同则为0，否则为1
~ 取反
~是一元运算符，用来对一个二进制数按位取\反，即将0变1，将1变0
&lt;&lt; 左移
用来将一个数的各二进制位全部左移N位，右补0

&gt;&gt; 右移 
将一个数的各二进制位右移N位，移到右端 的低位被舍弃，对于无符号数，高位补0</code></pre><p><strong>补码</strong><br>一个负整数（或原码）与其补数（或补码）相加，和为模。(C &lt; 0);<br>-C + S = INT_MAX;<br>~n = -1 - n;</p>
<p><strong>a^b</strong></p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
typedef long long ll;

ll q_mod(ll a, ll b, ll p) {
    ll res = 1 % p;
    while(b){
        if(b &amp; 1) res = res * a % p;
        a = a * a % p;
        b &gt;&gt;= 1;
    }
    return res;
}

int main(){
    ll a, b, p;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;
    cout &lt;&lt; q_mod(a, b, p) &lt;&lt; endl;
    return 0;
}</code></pre><p><strong>64位整数乘法</strong> (快速乘带mod)</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;
typedef unsigned long long ull;
typedef long long ll;

ll mul(ll a, ll b, ll p) {
    ll res = 0;
    while(b) {
        if(b &amp; 1) res = (res + a) % p;
        a = (a &lt;&lt; 1) % p;
        b &gt;&gt;= 1;
    }
    return res;
}

int main(){
    ll a, b, p;
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;
    cout &lt;&lt; mul(a, b, p) &lt;&lt; endl;
    return 0;
}</code></pre><p>以上都是利用 b的二进制 有1的才有乘法和加法意义 所做的</p>
<p><strong>lowbit</strong><br>lowbIt(x) = (-x) &amp; x; 获得最低位的 1 ;</p>
<p><strong>最短 hamilton 路径</strong><br>状压DP 居然第一节就有了 orz</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

const int maxn = 20 + 5;
int mp[maxn][maxn];
int dp[(1 &lt;&lt; 20) + 5][maxn];

int main(){
    int n;
    cin &gt;&gt; n;

    for(int i = 1; i &lt;= n; i ++ ) for(int j = 1; j &lt;= n; j ++ ) 
        cin &gt;&gt; mp[i][j];
        // for(int k=1;k&lt;=n;k++){
        //     for(int i=1;i&lt;=n;i++){
        //         for(int j=1;j&lt;=n;j++){
        //             if(mp[i][j]&gt;mp[i][k]+mp[k][j]) mp[i][j]=mp[i][k]+mp[k][j];
        //         }
        //     }
        // } 数据保证最短路 不然跑floyd先  
    memset(dp, 0x3f, sizeof dp);
    //for(int i = 0; i &lt;=n ; i ++ ) dp[1 &lt;&lt; i][i] = 0; // 任意开始最短路径
    dp[1][0] = 0;
    for(int s = 1; s &lt; (1 &lt;&lt; n); s ++ ) {
        for(int i = 0; i &lt; n; i ++ ) {
            if( !(s &amp; (1 &lt;&lt; i)) ) continue; // 借助这个城市
            for(int j = 0; j &lt; n; j ++ ) {
                if(s &amp; (1 &lt;&lt; j)) continue; // 要去这个城市
                dp[s | (1 &lt;&lt; j)][j] = min(dp[s | (1 &lt;&lt; j)][j], dp[s][i] + mp[i + 1][j + 1]);
            }
        }
    }
    cout &lt;&lt; dp[(1 &lt;&lt; n) - 1][n - 1] &lt;&lt; endl;
    return 0;
}</code></pre><h2 id="0x02递推与递归"><a href="#0x02递推与递归" class="headerlink" title="0x02递推与递归"></a>0x02递推与递归</h2><p>枚举: 排列 组合 (多项式级和指数级别, 递归、循环 剪支);</p>
<p><strong>递归实现指数型枚举</strong></p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

const int maxn = 20;
int ans[maxn], hh, tt;
int n;

void dfs(int num){
    if(num == n + 1) {
        for(int i = hh; i &lt; tt; i ++ ) {
            cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;
        }cout &lt;&lt; endl;
        return;
    }
    dfs(num + 1);
    ans[tt] = num;
    tt ++;
    dfs(num + 1);
    tt --;
}

int main(){
    cin &gt;&gt; n;
    hh = 1, tt = 1;
    dfs(1);
    return 0;
}</code></pre><p><strong>递归实现组合型枚举</strong><br>注意剪枝</p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

const int maxn = 30;
int ans[maxn], hh, tt;
int n, m;

void dfs(int num){
    if(tt &gt; m + 1|| tt + (n - num) &lt; m)
        return;
    if(tt == m + 1) {
        for(int i = 1; i &lt; tt; i ++ ){
            cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;
        }cout &lt;&lt; endl;
        return ;
    }
    ans[tt] = num;
    tt ++;
    dfs(num + 1);
    tt --;
    dfs(num + 1);
}

int main(){
    cin &gt;&gt; n &gt;&gt; m;
    hh = 1, tt = 1;
    dfs(1);
    return 0;
}</code></pre><p><strong>递归实现排列枚举型</strong></p>
<pre><code>#include &lt;iostream&gt;
using namespace std;

const int maxn = 15;
bool vis[maxn];
int ans[maxn], hh, tt;
int n, m;

void dfs(int num){
    if(num == n + 1) {
        for(int i = 1; i &lt; tt; i ++ ) {
            cout &lt;&lt; ans[i] &lt;&lt; &quot; &quot;;
        }cout &lt;&lt; endl;
        return ;
    }
    for(int i = 1; i &lt;= n; i ++ ) {
        if(vis[i]) continue;
        ans[tt] = i;
        tt ++;
        vis[i] = 1;
        dfs(num + 1);
        tt -- ;
        vis[i] = 0;
    }
}

int main(){
    cin &gt;&gt; n;
    hh = 1, tt = 1;
    dfs(1);
    return 0;
}</code></pre><p>例题:<br><strong>费解的开关</strong><br>每一点 只影响上下左右<br>不妨枚举第一次方案 这样 之后每一层都必须根据上一层来处理 翻不翻<br>最后判断最后一层 是否可行就行</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

const int maxn = 10;
int a[maxn][maxn], b[maxn][maxn];
int n, ans;

int solve(int k){
    int res = 0;
    for(int i = 2; i &lt;= n; i ++ ) {
        for(int j = 1; j &lt;= n; j ++ ) {
            if((a[i - 1][j] + b[i - 1][j] + b[i - 1][j - 1] + b[i - 1][j + 1] + b[i - 2][j]) &amp; 1) {
                res ++;
                b[i][j] = 1;
            }else {
                b[i][j] = 0;
            }
        }
        if(res + k &gt; 6) return 0x3f3f3f3f;
    }

    for(int j = 1; j &lt;= n; j ++ ) {
        if((a[n][j] + b[n][j] + b[n][j - 1] + b[n][j + 1] + b[n - 1][j]) &amp; 1) {
            return 0x3f3f3f3f;
        }
    }
    return res;
}

void dfs(int num, int k) {
    if(num == n + 1) {
        ans = min(solve(k) + k, ans);
        return ;
    }
    b[1][num] = 0;
    dfs(num + 1, k);
    b[1][num] = 1;
    dfs(num + 1, k + 1);
}

int main(){
    int cas ;
    cin &gt;&gt; cas;
    n = 5;
    while(cas --) {
        memset(a, 0, sizeof a);
        memset(b, 0, sizeof b);
        string line;
        for(int i = 1; i &lt;= 5; i++ ) {
            cin &gt;&gt; line;
            for(int j = 1; j &lt;= 5; j++ ) {
                if(line[j - 1] == &apos;0&apos;) a[i][j] = 1;
            }
        }
        ans = 0x3f3f3f3f;
        dfs(1, 0);
        if(ans &gt; 6) cout &lt;&lt; -1 &lt;&lt; endl;
        else cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}</code></pre><p><strong>多汉诺塔问题</strong></p>
<blockquote>
<p>首先考虑n个盘子3塔的经典Hanoi问题，设dn表示求解n个盘子3塔问题的最少步数，显然有 dn=2∗dn−1+1</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>含义为把前n−1个盘子从A借助C转移到B，再将第n个盘子转移到C，最后把n−1个盘子从B借助A转移到C。</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>类似地，对于本题，设f[n]表示求解n个盘子4塔问题的最小步数，则有 fn=min(2∗fi+dn−i)(1≤i&lt;n)</p>
</blockquote>
<blockquote>
</blockquote>
<blockquote>
<p>含义为把前i个盘子在4柱的情况下从A转移到B，再将n−i个盘子在3柱的情况下从A转移到D，最后再将i个盘子在4柱的情况下从B转移到D<br> 那么对于n盘m塔的问题(m&gt;4)，就有 fn,m=min(2∗fi,m+fn−i,m−1)(1≤i&lt;n)<br> 使得我们可以在O(n^2∗m)的复杂度内求解该问题</p>
</blockquote>
<pre><code>#include &lt;iostream&gt;
using namespace std;

const int maxn = 25 + 5 ;
int n, m;

int dp[20], d[20];

signed main() {
    d[1] = 1;
    for(int i = 2; i &lt;= 15; i++) {
        d[i] = d[i - 1] * 2 + 1;
    }
    memset(dp, 0x3f, sizeof(dp));
    dp[1] = 1;
    for(int i = 2; i &lt;= 15; i++) {
        for(int j = 1; j &lt; i; j++) {
            dp[i] = min(dp[i], d[i - j] + dp[j] * 2);
        } // 2 * 4塔模式  + 1 * 3塔模式
    }
    for(int i = 1; i &lt;= 12; i++) {
        cout &lt;&lt; dp[i] &lt;&lt; endl;
    }
    return 0;
}</code></pre><p><strong>约数之和</strong> 这题不仅分治可以做… 矩阵快速幂 还有后面的数论一个解法 好像也提到过<br>这里先先补上书上的解法</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;
typedef long long ll;
const int mod = 9901;
const int maxn = 105;
int n, m;
int p[maxn], c[maxn], cnt;

void divide(int n) {
    cnt = 0;
    for(int i = 2; i &lt;= sqrt(n); i++) {
        if(n % i == 0) {
            p[++cnt] = i, c[cnt] = 0;
            while(n % i == 0)
                n /= i, c[cnt]++;
        }
    }
    if(n &gt; 1)
        p[++cnt] = n, c[cnt] = 1;
}

int q_mod(int a, int b) {
    int res = 1;
    while(b){
        if(b &amp; 1) res = 1ll*  res * a % mod;
        a = 1ll * a * a % mod;
        b &gt;&gt;= 1;
    }
    return res;
}

int dfs(int pt, int ct) {
    if(ct == 0) return 1;
    if(ct % 2 == 1)
        return ((1ll + q_mod(pt, (ct + 1) / 2)) * dfs(pt, (ct - 1) / 2)) % mod;
    else
        return ((1ll + q_mod(pt, ct / 2)) * dfs(pt, (ct / 2) - 1) % mod + q_mod(pt, ct)) % mod;
}

int main(){
    cin &gt;&gt; n &gt;&gt; m;
    divide(n);
    int ans = 1 ;
    if(n == 0) ans = 0;
    for(int i = 1; i &lt;= cnt ; i ++ ) {
        ans *= dfs(p[i], c[i] * m);
        ans %= mod;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</code></pre><p><strong>分形之城</strong><br>补充这个</p>
<blockquote>
<p>ps : 坐标旋转公式<br> (x, y) 旋转 b 度 (逆时针)<br> s = x cos(b) – y sin(b)<br> t = x sin(b) + y cos(b)<br> <img src="https://img-blog.csdnimg.cn/20190703143445133.png" alt="在这里插入图片描述"></p>
</blockquote>
<blockquote>
<p>坐标轴旋转<br> <img src="https://img-blog.csdnimg.cn/20190703143454989.png" alt="在这里插入图片描述"></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/06/10/龙曲线  [分形]  从 DFS暴力 到 规律 实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/10/龙曲线  [分形]  从 DFS暴力 到 规律 实现/" itemprop="url">龙曲线  [分形]  从 DFS暴力 到 规律 实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-10T18:38:41+08:00">
                2019-06-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/搜索/" itemprop="url" rel="index">
                    <span itemprop="name">搜索</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>龙曲线<br>龙曲线是以简单的数学规则画出一种曲线，它具有以下形态。曲线从一个简单的线段起始，按照一定规则变换此线段完成整个曲线。每形成一次变换称为“完成了一次变换代”，而每完成一代，曲线会进化到更复杂的形式。像这种“放大其一小部分的形状时，表现出与整个形状极为相似构造的图形”，就是分形。<br>画出龙曲线的方法暂且就称为龙曲线字符串吧！龙曲线字符串由X、Y、F、+、-组成。<br>那么，要画出龙曲线就从一个点起始画出如下曲线即可。</p>
<p>F：向前方移动一格并画线。<br>+：向左旋转90度。<br>-：向右旋转90度。<br>X、Y：忽略。<br>画出第0代龙曲线的字符串是FX。从下一代开始，按照如下方式利用前一代字符串进行字符替换，从而获得当前一代的龙曲线字符串。<br>X-&gt; X+YF<br>Y-&gt; FX+Y</p>
<p>根据上面的替换式，就有如下的1、2代龙曲线字符串。<br>第一代：FX+YF<br>第二代：FX+YF+FX-YF<br>我们想要求出第n代龙曲线字符串。不过，考虑到答案有可能很长，所以只想计算出第p个字符起始长度为l个字符的字符串。请编写程序实现这种功能。</p>
<p>输入<br>第一行输入测试用例的个数C（C&lt;=50）。各测试用例的第一行分别输入3个整数，即龙曲线的世代n（0&lt;=n&lt;=50）、p以及l（1&lt;=p&lt;=1 000 000<br>000、1&lt;=l&lt;=50）。第n代龙曲线字符串的长度可假设成总是大于等于p+l的数值。<br>输出<br>每个测试用例在1行内输出第n代龙曲线字符串的第p个字符开始，输出l个字符。</p>
<p>示例输入<br>4  
0 1 2<br>1 1 5<br>2 6 5<br>42 764853475 30<br>示例输出<br>FX<br>FX+YF<br>+FX-Y<br>FX-YF-FX+YF+FX-YF-FX+YF-FX-YF-  </p>
<p>首先是暴力 代码</p>
<pre><code>#include&lt;iostream&gt;
using namespace std;

void dfs(string str, int N) {
    if(N == 0) {
        cout &lt;&lt; str;
        return;
    }
    for(int i = 0; i &lt; str.size(); ++i) {
        if(str[i] == &apos;X&apos;)
            dfs(&quot;X+YF&quot;, N - 1);
        else if(str[i] == &apos;Y&apos;)
            dfs(&quot;FX-Y&quot;, N - 1);
        else
            cout &lt;&lt; str[i];
    }
}

int main() {
    int n;
    cin &gt;&gt; n;
    dfs(&quot;FX&quot;, n);
}</code></pre><p>这里我们爆出 1 到 5 的数据表</p>
<pre><code>第一代：FX+YF // 5
第二代：FX+YF+FX-YF // 11
第三代：FX+YF+FX-YF+FX+YF-FX-YF // 23
第四代：FX+YF+FX-YF+FX+YF-FX-YF+FX+YF+FX-YF-FX+YF-FX-YF // 47
五:        FX+YF+FX-YF+FX+YF-FX-YF+FX+YF+FX-YF-FX+YF-FX-YF  \
        +FX+YF+FX-YF+FX+YF-FX-YF-FX+YF+FX-YF-FX+YF-FX-YF</code></pre><p>字符数：sum[i] = (sum[i-1] &lt;&lt; 1) + 1;</p>
<p>字母规律：循环节 FXYFFXYF<br>符号规律：</p>
<pre><code>1.    +
2.    + + -
3.    + + - + + - -
4.    + + - + + - - + + + - + + - -
5.       + + - + + - - + + + - + + - - + + + - + + - - + + + - + + - -</code></pre><p>发现 每个字符 前后的空隙 轮着插 + -;<br>所以 再倍增上一个的同时 把 + - 依次插入<br>这也是为什么 字符数：sum[i] = (sum[i-1] &lt;&lt; 1) + 1; 是这样规律</p>
<p>那么 我们选择 每次将 非 0， 2， 4 位置的F X Y以外 的下表 首先 / 3<br>然后不断 / 2 只到达到奇数位<br>例如 第 3 代</p>
<pre><code>  1 2 3 4 5 6 7
  + + - + + - - 
  第一位 + 1 mod 4  = 2 :+
  第二位 / 2 之后 + 1 mod 4 = 2：+
  第三位 +1 mod 4 = 0 ：-
  第四位 / 2 / 2 + 1 mod 4 = 2 ：+
  第五位 + 1 mod 4 = 2 ： +
  第六位 / 2 + 1 mod 4 =  0 ： -
  第七位 + 1 mod 4 = 0 ： -

    大体上是这样的一般规律 其实mod 2在搞规律也行 我找的时候当4的循环节了 同时mod 4也是因为我前面没有处理好



#include&lt;bits/stdc++.h&gt;
using namespace std;

void get_c(int &amp;x) {
    while(x % 2 == 0) {
        x /= 2;
    }
} // 确定第 x 位 属于O, E层次

void output(int x) {
    if(x % 6 == 2) // 循环节 2p
            cout &lt;&lt; &quot;X&quot;;
        else if(x % 6 == 4) // 循环节 3p
            cout &lt;&lt; &quot;Y&quot;;
        else if(x % 3 == 0) {
            x = x / 3;
            get_c(x); // 降 k
            if((x + 1) % 4 == 2) {
                cout &lt;&lt; &quot;+&quot;;
            } else
                cout &lt;&lt; &quot;-&quot;;
        } else
            cout &lt;&lt; &quot;F&quot;; // 循环节 1p
}

void sol(int p, int l) {
    for(int i = 0; i &lt; l; i++) {
        int k = p + i;
        output(k);
    }
    cout &lt;&lt; endl;
}

int main() {
    int cas;
    for(cin &gt;&gt; cas; cas--;) {
        int n, p, l;
        cin &gt;&gt; n &gt;&gt; p &gt;&gt; l;
        sol(p, l);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/06/02/2019 南昌网络赛 J. Distance on the tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/02/2019 南昌网络赛 J. Distance on the tree/" itemprop="url">2019 南昌网络赛 J. Distance on the tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-02T15:49:06+08:00">
                2019-06-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>wa 这题重写了一遍过了 <del>我第一次写的什么狗屎啊</del></p>
<p>题目 ： <a href="https://nanti.jisuanke.com/t/38229" target="_blank" rel="noopener"> https://nanti.jisuanke.com/t/38229
</a></p>
<p>如下图<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190602154705226.jpg?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190602154705226.jpg?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)<br>对每个 树节点 以他向后面每个链 建主席树<br>这样只要跑lca 就能区间快查k大了</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
using namespace std;

const int maxn = 100000 + 10;

int head[maxn], depth[maxn], cnt;
int shu;
int dis[maxn &lt;&lt; 1];
int nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1];

int fa[maxn][30], lg[maxn];
int n, m, k, q;

void ade(int a, int b, int c) {
    to[++cnt] = b;
    nxt[cnt] = head[a];
    dis[cnt] = c;
    head[a] = cnt;
}

struct node {
    int lc, rc;
    int val;
} tree[maxn * 20];

int tot, root[maxn];
int b[maxn];

int build(int l, int r) {
    int p = ++ tot;
    if(l == r) {
        tree[p].val = 0;
        return p;
    }
    int mid = l + r &gt;&gt; 1;
    tree[p].lc = build(l, mid);
    tree[p].rc = build(mid + 1, r);
    tree[p].val = tree[tree[p].lc].val + tree[tree[p].rc].val;
    return p;
}

int ins(int now, int l, int r, int pos, int val) {
    int p = ++ tot;
    tree[p] = tree[now];
    if(l == r) {
        tree[p].val += val ;
        return p;
    }
    int mid = l + r &gt;&gt; 1;
    if(pos &lt;= mid)
        tree[p].lc = ins(tree[now].lc, l, mid, pos, val);
    else
        tree[p].rc = ins(tree[now].rc, mid + 1, r, pos, val);
    tree[p].val = tree[tree[p].lc].val + tree[tree[p].rc].val;
    return p;
}

int ask(int p, int q, int l, int r, int L, int R) {
    if(R &lt; L) return 0;
    if(L &lt;= l &amp;&amp; r &lt;= R)
        return tree[p].val - tree[q].val;

    int mid = l + r &gt;&gt; 1;
    int res = 0;
    if(L &lt;= mid)
        res += ask(tree[p].lc, tree[q].lc, l, mid, L, R);
    if(R &gt; mid)
        res += ask(tree[p].rc, tree[q].rc, mid + 1, r, L, R);
    return res;
}

int getid(int x) {
    int res = upper_bound(b + 1, b + shu, x) - b - 1;
    return res;
}

void dfs(int x, int pre) {
    depth[x] = depth[pre] + 1;
    fa[x][0] = pre;
    for(int i = 1; (1 &lt;&lt; i) &lt;= depth[x]; i++)
        fa[x][i] = fa[fa[x][i - 1]][i - 1];
    for(int i = head[x]; i; i = nxt[i])
        if(to[i] != pre) {
            root[to[i]] = ins(root[x], 1, shu, getid(dis[i]), 1);
            dfs(to[i], x);
        }
}

int lca(int x, int y) {
    if(depth[x] &lt; depth[y])
        swap(x, y);
    while(depth[x] &gt; depth[y])
        x = fa[x][lg[depth[x] - depth[y]] - 1];
    if(x == y)
        return x;
    for(int k = lg[depth[x]] - 1; k &gt;= 0; k--) {
        if(fa[x][k] != fa[y][k]) {
            x = fa[x][k], y = fa[y][k];
        }
    }
    return fa[x][0];
}

void lsh() {
    sort(b + 1, b + n);
    shu = unique(b + 1, b + n) - b;
}

int main() {
    for(int i = 1; i &lt; maxn; i++)
        lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i);

    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt; n; i ++ ) {
        int st, ed, dis;
        cin &gt;&gt; st &gt;&gt; ed &gt;&gt; dis;
        ade(st, ed, dis),ade(ed, st, dis);
        b[i] = dis;
    }

    lsh();

    root[1] = build(1, shu);

    dfs(1,0);

    for(int i = 1; i &lt;= m; i ++) {
        int x, y, k;
        scanf( &quot;%d %d %d&quot; , &amp;x, &amp;y, &amp;k);
        k = getid(k);
        int LCA = lca(x, y);
        printf( &quot;%d\n&quot;,\
                ask(root[y], root[LCA], 1, shu, 1, k)\
                + ask(root[x], root[LCA], 1, shu, 1, k)\
              );
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/05/30/2019 ACM-ICPC 西安邀请赛 A C D L M (+签到题 题解)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/30/2019 ACM-ICPC 西安邀请赛 A C D L M (+签到题 题解)/" itemprop="url">2019 ACM-ICPC 西安邀请赛 A C D L M (/签到题 题解)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-30T10:20:49+08:00">
                2019-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/题集/" itemprop="url" rel="index">
                    <span itemprop="name">题集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="A"><a href="#A" class="headerlink" title="A"></a>A</h2><p><strong>Tasks</strong><br>上来以为DP 结果直接贪也是楞了</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
using namespace std;
#define int long long

const int maxn = 1e5 + 5 ;

int a[maxn];

signed main() {
    fastio;
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;

    for(int i = 1 ; i &lt;= n; i++) {
        cin &gt;&gt; a[i];
    }

    int res = 0;
    int ans = 0;
    sort(a + 1, a + 1 + n);
    for(int i = 1; i &lt;=n; i++) {
        if(res + a[i] &lt;= m)
            res += a[i], ans++;
        else
            break;
    }

    cout &lt;&lt; ans &lt;&lt; endl;

    return 0;
}</code></pre><h2 id="C"><a href="#C" class="headerlink" title="C"></a>C</h2><p>** Angel’s Journey**  
画图计算公式 简单计算下</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
using namespace std;
#define int long long

const int maxn = 1e5 + 5 ;
const double pi = acos(-1.0);

double rdis(double x, double y, double a, double b) {
    return sqrt((x - a) * (x - a) + (y - b) * (y - b));
}

signed main() {
    //  fastio;
    int T;
    cin &gt;&gt; T;
    while(T--) {
        double rx, ry, r, x, y;

        cin &gt;&gt; rx &gt;&gt; ry &gt;&gt; r &gt;&gt; x &gt;&gt; y;

        if(x &lt; rx - r || x &gt; rx + r) {
            if(x &lt; rx - r) {
                double ans = rdis(rx - r, ry, x, y);
                ans += pi / 2 * r;
                printf(&quot;%.4lf\n&quot;, ans);
            } else {
                double ans = rdis(rx + r, ry, x, y);
                ans += pi / 2 * r;
                printf(&quot;%.4lf\n&quot;, ans);
            }
        } else {
            double d = rdis(x, y, rx, ry);
            double qd = sqrt(d * d - r * r);

            double a1 = atan(abs(x-rx) / abs(ry-y));
            double a2 = atan(qd / r);

            double j = pi / 2 - a1 - a2;

            double xl = j * r;

         //   cout&lt;&lt;qd&lt;&lt;&quot;    &quot;&lt;&lt;a1&lt;&lt;&quot;   &quot;&lt;&lt;a2&lt;&lt;&quot;   &quot;&lt;&lt;j&lt;&lt;&quot;  &quot;&lt;&lt;xl&lt;&lt;endl;

            double ans = xl;
            ans += qd;
            ans += pi / 2 * r;
            printf(&quot;%.4lf\n&quot;, ans);
        }
    }
    return 0;
}</code></pre><h2 id="D"><a href="#D" class="headerlink" title="D"></a>D</h2><p><strong>Miku and Generals</strong><br>把物品有关系 一开始dfs分好 变成一个必选其中一个的<br>而孤立点 就是一半的01背包</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
using namespace std;
#define int long long

const int maxn = 1e6 + 5 ;
const double pi = acos(-1.0);

int n, m;
int dp[maxn];
int a[maxn];

int head[3005], cnt;
int nxt[10000], to[10000];

struct node {
    int v, w;
} wu[205];

void ade(int a, int b) {
    to[++cnt] = b;
    nxt[cnt] = head[a];
    head[a] = cnt;
}

int s1,s2;
int vis[maxn];

void dfs(int x) {
    if(vis[x]==1) {
        if(s1==-1) s1=0;
        s1+=a[x];
    } else {
        if(s2==-1) s2=0;
        s2+=a[x];
    }

    for(int i = head[x]; i; i = nxt[i]) {
        if(vis[to[i]]) continue;
        vis[to[i]] = (vis[x] == 1 ? 2 : 1);
        dfs(to[i]);
    }
}

signed main() {
//    fastio;
    int T;
    cin &gt;&gt; T;
    while(T--) {
        int sum=0;
        memset(head,0,sizeof(head));
        memset(vis,0,sizeof(vis));
        memset(dp,0,sizeof(dp));
        cnt=0;
        cin &gt;&gt; n &gt;&gt; m;
        for(int i = 1; i &lt;= n; i++) {
            cin &gt;&gt; a[i];
            a[i]/=50;
            sum+=a[i];
        }

        for(int i = 1; i &lt;= m; i++) {
            int u, v;
            cin &gt;&gt; u &gt;&gt; v;
            ade(u,v),ade(v,u);
        }

        int wus=0;

        for(int i=1; i&lt;=n; i++) {
            if(vis[i]) continue;
            vis[i]=1;
            s1=-1,s2=-1;
            dfs(i);
            wu[++wus]=node {s1,s2};
        }

        for(int i=1; i&lt;=wus; i++) {
            for(int j=sum/2; j&gt;=0; j--) {
                if(wu[i].w!=-1) {
                    if(j&gt;=wu[i].w&amp;&amp;j&gt;=wu[i].v) {
                        dp[j]=max(dp[j-wu[i].v]+wu[i].v,dp[j-wu[i].w]+wu[i].w);
                    } else if(j&gt;=wu[i].w) {
                        dp[j]=dp[j-wu[i].w]+wu[i].w;
                    } else if(j&gt;=wu[i].v) {
                        dp[j]=dp[j-wu[i].v]+wu[i].v;
                    }
                } else {
                    if(j&gt;=wu[i].v)
                        dp[j]=max(dp[j],dp[j-wu[i].v]+wu[i].v);
                }
            }
        }
        cout&lt;&lt;(sum-dp[sum/2])*50&lt;&lt;endl;

    }
    return 0;
}</code></pre><h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><p><strong>Swap</strong><br>直接打表上去也压力不大。。才400ms</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
using namespace std;
#define int long long

const int maxn = 1e5 + 5 ;

set&lt;string&gt; S;

string s;
int len;
void dfs(int d) {
    if(d) {
        if(len % 2 == 0) {
            for(int i = 0; i &lt; len / 2; i++) {
                swap(s[i], s[i + len / 2 ]);
            }
          //  cout &lt;&lt; s &lt;&lt; endl;
            if(S.find(s) != S.end())
                return ;
            S.insert(s);
            dfs(!d);
        }
        else{
            for(int i = 0; i &lt; len / 2; i++) {
                swap(s[i], s[i + len / 2 +1]);
            }
          //  cout &lt;&lt; s &lt;&lt; endl;
            if(S.find(s) != S.end())
                return ;
            S.insert(s);
            dfs(!d);
        }

    } else {
        for(int i = 0; i &lt; len - 1; i += 2) {
            swap(s[i], s[i + 1]);
        }
       // cout &lt;&lt; s &lt;&lt; endl;
        if(S.find(s) != S.end())
            return ;
        S.insert(s);
        dfs(!d);
    }
}

signed main() {
    fastio;
    int n=3;
   // while(n&lt;20){
   cin&gt;&gt;n;
   if(n==1) cout&lt;&lt;1&lt;&lt;endl;
   else if(n==2) cout&lt;&lt;2&lt;&lt;endl;
   else{

        s=&quot;&quot;;
        for(int i = 1; i &lt;= n; i++)
            s.push_back(i + &apos;a&apos;);
      //  cout &lt;&lt; s &lt;&lt; endl;
        len = n;
        dfs(0);
      //  cout&lt;&lt;n&lt;&lt;&quot;     &quot; &lt;&lt; S.size()&lt;&lt;endl;
      cout&lt;&lt;S.size()&lt;&lt;endl;
        n++;
        S.clear();
   }
   // }
    return 0;
}</code></pre><h2 id="M"><a href="#M" class="headerlink" title="M"></a>M</h2><p><strong>Travel</strong><br>数据水了 直接贪过去的也行。。。<br>正解应该是二分 chk可达n点</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
typedef long long ll;

const int maxn=1e5+10;

struct node {
    int to,dis;
};
bool vis[maxn];

vector&lt;node&gt;v[maxn];
int n,m,c,d,e;

bool check(int x) {
    queue&lt;pair&lt;int,int&gt; &gt; que;
    que.push(make_pair(1,x*e));
    while(!que.empty()){
        pair&lt;int,int&gt; p=que.front();
        que.pop(); 
        if(p.first==n) return 1; 
        if(vis[p.first]) continue ;
        vis[p.first]=1;
        for(int i=0;i&lt;v[p.first].size();i++){
            if(p.second&gt;=1&amp;&amp;v[p.first][i].dis&lt;=x*d){
                que.push(make_pair(v[p.first][i].to,p.second-1));
            }
        }
    }
    return 0;
}

signed main() {
    cin&gt;&gt;n&gt;&gt;m&gt;&gt;c&gt;&gt;d&gt;&gt;e;
    memset(vis,0,sizeof(vis));
    for(int i=0; i&lt;m; i++) {
        int x,y,z;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;
        v[x].push_back(node {y,z});
        v[y].push_back(node {x,z});
    }

    int l=0,r=1e5,mid;
    while(r-l&gt;1) {
        memset(vis,0,sizeof(vis));
        mid=(l+r)/2;
        if(check(mid)) r=mid;
        else l=mid;
    }
    cout&lt;&lt;r*c&lt;&lt;endl;
    return 0;
}</code></pre><p>菜鸡我只能签到了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/05/28/HASH 字符串 KMP 进制hash 最小表示法 trie树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/28/HASH 字符串 KMP 进制hash 最小表示法 trie树/" itemprop="url">HASH 字符串 KMP 进制hash 最小表示法 trie树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-28T18:39:22+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>雪花雪花</strong></p>
<blockquote>
<p>有N片雪花，每片雪花由六个角组成，每个角都有长度。<br> 第i片雪花六个角的长度从某个角开始顺时针依次记为ai,1,ai,2,…,ai,6。<br> 因为雪花的形状是封闭的环形，所以从任何一个角开始顺时针或逆时针往后记录长度，得到的六元组都代表形状相同的雪花。<br> 例如ai,1,ai,2,…,ai,6和ai,2,ai,3,…,ai,6，ai,1就是形状相同的雪花。<br> ai,1,ai,2,…,ai,6和ai,6,ai,5,…,ai,1也是形状相同的雪花。<br> 我们称两片雪花形状相同，当且仅当它们各自从某一角开始顺时针或逆时针记录长度，能得到两个相同的六元组。<br> 求这N片雪花中是否存在两片形状相同的雪花。<br> 输入格式<br> 第一行输入一个整数N，代表雪花的数量。<br> 接下来N行，每行描述一片雪花。<br> 每行包含6个整数，分别代表雪花的六个角的长度（这六个数即为从雪花的随机一个角顺时针或逆时针记录长度得到）。<br> 同行数值之间，用空格隔开。<br> 输出格式<br> 如果不存在两片形状相同的雪花，则输出：<br> No two snowflakes are alike.<br> 如果存在两片形状相同的雪花，则输出：<br> Twin snowflakes found.<br> 数据范围<br> 1≤n≤100000,<br> 0≤ai,j&lt;10000000<br> 输入样例：<br> 2<br> 1 2 3 4 5 6<br> 4 3 2 1 6 5<br> 输出样例：<br> Twin snowflakes found.</p>
</blockquote>
<p>虽然说是hash表过的题 但是这里我写一个 最小表示过的代码</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
using namespace std;
#define int long long

const int maxn = 1e6 + 5 ;
const double pi = acos(-1.0);
const int mod = 991 ;
int s[300],ss[300];
int ge(int s[]) {
    int len = 6;
    for(int i=1; i&lt;=len; i++) s[i+len]=s[i];
    int i=1,j=2,k;
    while(i&lt;=len&amp;&amp;j&lt;=len) {
        for(k=0; k&lt;len&amp;&amp;s[i+k]==s[j+k]; k++);
        if(k==len) break;
        if(s[k+i]&gt;s[j+k]) {
            i=i+1+k;
            if(i==j) i++;
        } else {
            j=j+1+k;
            if(j==i) j++;
        }
    }
    int pos=min(i,j);
    return pos;
}

set&lt;int&gt; mp;

signed main() {
    int n;
    cin&gt;&gt;n;
    while(n--) {
        for(int i=1; i&lt;=6; i++) {
            cin&gt;&gt;s[i];
        }
        for(int i=1; i&lt;=6; i++) ss[7-i]=s[i];
        int hash = 0;
        int k1=ge(s);
        for(int i=0; i&lt;6; i++) {
            hash=hash*mod+s[k1+i];
        }
        int k2=ge(ss);
        int hash2=0;
        for(int i=0; i&lt;6; i++) {
            hash2=hash2*mod+ss[k2+i];
        }
        if(mp.find(min(hash,hash2))!=mp.end()) {
            cout&lt;&lt;&quot;Twin snowflakes found.&quot;&lt;&lt;endl;
            return 0;
        }
        mp.insert(min(hash,hash2));
    }
    cout&lt;&lt;&quot;No two snowflakes are alike.&quot;&lt;&lt;endl;
    return 0;
}</code></pre><p><strong>进制hash</strong><br>快速找 字符串内部连续串是否存在 一样</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
using namespace std;
#define int unsigned long long

const int maxn = 1e6 + 5 ;
const double pi = acos(-1.0);
const int mod = 131;

char str[maxn];
int p[maxn],f[maxn];
int n;

signed main() {
    scanf(&quot;%s&quot;,str+1);
    int len = strlen(str+1);
    p[0]=1;
    for(int i=1; i&lt;=len; i++) {
        f[i]=f[i-1]*131+(str[i]-&apos;a&apos;+1);
        p[i]=p[i-1]*mod;
    }
    cin&gt;&gt;n;
    while(n--) {
        int l,r,x,y;
        cin&gt;&gt;x&gt;&gt;y&gt;&gt;l&gt;&gt;r;
        if(f[y]-f[x-1]*p[y-x+1]==f[r]-f[l-1]*p[r-l+1]) {
            cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;
        } else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;
    }
    return 0;
}</code></pre><p><strong>马拉车</strong> <strong>KMP</strong> 板子不讲</p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p><strong>前缀统计</strong></p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
using namespace std;
#define int long long

const int maxn = 1e6+5;

int trie[maxn][30],tot=1;
int ens[maxn];

void ins(char str[]){
    int len=strlen(str),p=1;
    for(int k=0;k&lt;len;k++){
        int ch=str[k]-&apos;a&apos;;
        if(trie[p][ch]==0) trie[p][ch]=++tot;
        p=trie[p][ch]; 
    }
    ens[p]++;
}

int serach(char str[]){
    int res=0;
    int len=strlen(str),p=1;
    for(int k=0;k&lt;len;k++){
        int ch=str[k]-&apos;a&apos;;
        if(trie[p][ch]==0) break;
        p=trie[p][ch];
        if(ens[p]) res+=ens[p];
    }
    return res;
}

signed main() {
    fastio;
    int n,m;
    cin&gt;&gt;n&gt;&gt;m;
    char s[maxn];
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;s;
        ins(s);
    }
//    cin&gt;&gt;m;
    while(m--){
        int ans=0;
        cin&gt;&gt;s;
        ans+=serach(s);
        cout&lt;&lt;ans&lt;&lt;endl;
    }
    return 0;
}</code></pre><p><strong>最大异或对</strong></p>
<blockquote>
<p>在给定的N个整数A1，A2……AN中选出两个进行xor（异或）运算，得到的结果最大是多少？<br> 输入格式<br> 第一行输入一个整数N。<br> 第二行输入N个整数A1～AN。<br> 输出格式<br> 输出一个整数表示答案。<br> 数据范围<br> 1≤N≤105,<br> 0≤Ai&lt;231<br> 输入样例：<br> 3<br> 1 2 3<br> 输出样例：<br> 3</p>
</blockquote>
<p>第一次完全没有想到这跟trie有关系 orz<br>PS 这里一定要高位往低位取贪心 先拿高位 比低位贪</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
using namespace std;
#define int long long

const int maxn = 4e6+5;

int trie[maxn][5],tot=1;

void ins(int s){
    int p=1;
    for(int k=0;k&lt;=31;k++){
    //    int ch = ((1&lt;&lt;k)&amp;s?1:0);
        int ch=s&gt;&gt;k&amp;1;
        if(trie[p][ch]==0) trie[p][ch]=++tot;
        p=trie[p][ch]; 
    }
}

int serach(int s){
    int res=0;
    int p=1;
    for(int k=0;k&lt;=31;k++){
    //    int ch=((1&lt;&lt;k)&amp;s);
        int ch=s&gt;&gt;k&amp;1;
        if(trie[p][!ch]){
            p=trie[p][!ch];
            res+=(1&lt;&lt;k);
        }
        else{
            p=trie[p][ch];
        }
    }
    return res;
}

int a[maxn];

signed main() {
    fastio;
    int n,m;
    cin&gt;&gt;n;
    int s;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
        ins(a[i]);
    }
    int ans=0;
    for(int i=1;i&lt;=n;i++){
        ans=max(ans,serach(a[i]));
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</code></pre><p><strong>最长异或值路径</strong><br>树上 2点之间路径的最大异或值<br>无根树转有根树 记录每个点到跟路径异或值 重复部分刚好是2次 被消掉<br>如上找最大异或值就好</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
using namespace std;
//#define int long long

const int maxn = 4e6+5;

int trie[maxn][5],tot=1;

int cnt,head[maxn];
int nxt[maxn&lt;&lt;1],to[maxn&lt;&lt;1],dis[maxn&lt;&lt;1];

void ade(int a,int b,int c) {
    to[++cnt]=b;
    dis[cnt]=c;
    nxt[cnt]=head[a];
    head[a]=cnt;
}
int fa[maxn];

void dfs(int x,int pre,int sum) {
    fa[x]=sum;
    for(int i=head[x]; i; i=nxt[i]) {
        if(to[i]==pre) continue;    
        dfs(to[i],x,sum^dis[i]);
    }    
}

void ins(int s) {
    int p=1;
    for(int k=31; k&gt;=0; k--) {
        int ch=s&gt;&gt;k&amp;1;
        if(trie[p][ch]==0) trie[p][ch]=++tot;
        p=trie[p][ch];
    }
}

int serach(int s) {
    int res=0;
    int p=1;
    for(int k=31; k&gt;=0; k--) {
        int ch=s&gt;&gt;k&amp;1;
        if(trie[p][!ch]) {
            p=trie[p][!ch];
            res+=(1&lt;&lt;k);
        } else {
            p=trie[p][ch];
        }
    }
    return res;
}

int a[maxn];

signed main() {
    fastio;
    int n,m;
    cin&gt;&gt;n;
    int st,ed,d;
    for(int i=1;i&lt;n;i++){
        cin&gt;&gt;st&gt;&gt;ed&gt;&gt;d;
        st++,ed++;
        ade(st,ed,d),ade(ed,st,d);
    }
    dfs(1,-1,0);
    for(int i=1;i&lt;=n;i++){
        ins(fa[i]);
    }
    int ans=0;
    for(int i=1;i&lt;=n;i++){
        ans=max(ans,serach(fa[i]));
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/05/15/2019 第十四届 中北大学ACM程序设计竞赛 题解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/2019 第十四届 中北大学ACM程序设计竞赛 题解/" itemprop="url">2019 第十四届 中北大学ACM程序设计竞赛 题解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T14:10:08+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/题集/" itemprop="url" rel="index">
                    <span itemprop="name">题集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>A.CQW又迟到了</strong><br>CQW是个坏学生，每天都迟到，从没看见他在第一节课出现过，懒惰的他，总是在点名的最后一刻出现。为了治一治他这个坏习惯，教C语言的XZW老师决定每天都给他布置一个单独的作业，并答应只要他每次都能正确完成作业就不点他的名字，CQW为了可以多睡觉，立刻答应了下来。为了让CQW知难而退，于是第一天XZW老师就布置了一个超级难的题！</p>
<p>将一个字符串循环打印输出成一个 n * n 的矩阵。</p>
<p>如输入：abcd</p>
<p>那么输出：<br>abcd<br>bcda<br>cdab<br>dabc</p>
<p>也就是说每次都将输出的上一个字符串的第一个字符移动到最后的位置形成新的字符串。</p>
<p>天哪！对于从来不上课的CQW同学来说这题实在是太难了。他听说你喜欢唱跳、rap和篮球，还练习了两年半的C语言，于是过来请求你的帮助，你可以帮帮他吗？</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
//#define int long long
using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

const int maxn = 1e6+5;
const int INF = 0x3f3f3f3f;

int n,m,k;


signed main(){
    fastio;
    string str;
    cin&gt;&gt;str;
    n=str.size();
    for(int i=0;i&lt;n;i++){
        for(int j=0;j&lt;n;j++){
            cout&lt;&lt;str[(j+i)%n];
        }cout&lt;&lt;endl;
    }
    return 0;
}</code></pre><p><strong>B.CQW的倔强</strong><br>LCH和LPF是大学，每天都在讨论一些很高深的问题，像迪利克雷卷积之类的简单东西，他们根本不屑一顾。CQW是出了名的学渣，可是学渣也是有上进心的呀，他相信天道酬勤，只要他肯努力，一定可以赶上LCH和LPF的。有道是，一定要努力，只有努力过后，才能明白自己真的是不行。CQW在一次LCH和LPF讨论完后，趁着他们出去的功夫，他偷到了他们使用的手稿！CQW如获至宝，马上就开始研究他们讨论的题目，只见纸上赫然出现几个大字：给出一个整数<br>n ，请出 1 - n 的所有数字中一共出现了多少个 9 。</p>
<p>能数位DP 但是暴力能过。。。。。</p>
<p>包含一个整数 n（1&lt;= n &lt;=1000000）。</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
#define int long long
using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

const int maxn = 1e6+5;
const int INF = 0x3f3f3f3f;

int n,m,k;

int chk(int i){
    int res=0;
    while(i){
        if(i%10==9) res++;
        i/=10;
    }
    return res;
}

signed main(){
    fastio;
    cin&gt;&gt;n;
    int ans=0;
    for(int i=1;i&lt;=n;i++){
        ans+=chk(i);
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</code></pre><p><strong>C.WYS非常方</strong><br>在2019年3月底的团体程序设计天梯赛后，16级队员正式退役了，有的队员迅速找到了一份满意而体面的工作，有的队员估摸一算发现自己好像能保研了，还有一些队员则是在考研的道路上一往无前所向披靡，而有的队员懵在原地，不知所措。</p>
<p>WYS作为实验室中一个细心观察生活中点点滴滴的人，她很快就发现了实验室中某些人的状态很不对劲，常常呆在某个位置发呆，于是她向LZX，YXY等人询问情况，而却苦于心情难以用言语表达，决定由肢体语言表达出自己的心情<br>—-我很方，非常方。</p>
<p>作为一名实验室中考研人群中的一员，WYS发现自己似乎没有很多时间去处理这些问题，于是他把这个问题交给了你，希望你能够给出正确的答案。</p>
<p>我们简化问题，实验室有n(1&lt;=n&lt;=3000)个呆在原地的人，他们被看做为平面上的整数点（x，y)（1&lt;=x,y&lt;=5000)，要表达出他们有多方，一共需要满足两个条件：</p>
<pre><code>1.组成一个正方形,只有特殊的正方形才能说明他们非常方

2.组成的正方形尽可能大</code></pre><p>即我们要找到平面上四个人组成的最大的正方形面积为多少？</p>
<p>n^2 枚举 用向量找点 因为都是整数坐标 。。。 所以对应点也是整数坐标 要是用单位向量 又去搞了 根号找距离 大概精度不够wa了</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define double int
using namespace std;

const double eps = 1e-8;
bool mp[5005][5005];

struct node {
    int x;
    int y;
} a[3005];

double ans=0;

bool chk(int x,int y){
    if(x&gt;=0&amp;&amp;y&gt;=0&amp;&amp;y&lt;=5000&amp;&amp;x&lt;=5000){
        if(mp[x][y]==1) return 1;
    }
    return 0;
}

void dodeal(int i,int j) {
    int tx,ty;
    tx=a[i].x-a[j].x;
    ty=a[i].y-a[j].y;
    int x=-ty;
    int y=tx;
    if(chk(a[i].x+x,a[i].y+y)&amp;&amp;chk(a[j].x+x,a[j].y+y)){
        ans=max(ans,x*x+y*y);
    }
    if(chk(a[i].x-x,a[i].y-y)&amp;&amp;chk(a[j].x-x,a[j].y-y)){
        ans=max(ans,x*x+y*y);
    }
}

signed main() {
    int n;
    cin&gt;&gt;n;
    for(int i=1; i&lt;=n; i++) {
        cin&gt;&gt;a[i].x&gt;&gt;a[i].y;
        mp[a[i].x][a[i].y]=1;
    }
    ans=0;
    for(int i=1; i&lt;=n; i++) {
        for(int j=i+1; j&lt;=n; j++) {
            dodeal(i,j);
        }
    }
    if(ans==0) cout&lt;&lt;-1&lt;&lt;endl;
    else cout&lt;&lt;(int)ans&lt;&lt;endl;
    return 0;
}</code></pre><p><strong>D.绝对强者LYF</strong></p>
<p>LYF是一个篮球高手，为了展现自己的篮球技艺，他总和学弟们打篮球，希望通过虐小菜鸡们获得满足感，长久以来终于引起了公愤。为了制裁LYF，大家在暑假集训时进行了疯狂特训，如今已是今非昔比，现在的他们决定要选出他们中的绝对强者去制裁LYF，绝对强者要求：得分、篮板、助攻、抢断、封盖，五项数据都没有人比他高才行。你可以选出绝对强者吗？<br>存最大 直接找</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
#define int long long
using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

const int maxn = 1e3+5;
const int INF = 0x3f3f3f3f;

int n,m,k;

struct node{
    int a,b,c,d,e;
    int id;
}q[maxn];

signed main(){
    fastio;
    cin&gt;&gt;n;
    int ans=0;
    int a,b,c,d,e;
    int ma=-1,mb=-1,mc=-1,md=-1,me=-1;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;
        q[i]=node{a,b,c,d,e,i};
        ma=max(ma,a);
        mb=max(mb,b);
        mc=max(mc,c);
        md=max(md,d);
        me=max(me,e);
    }
    for(int i=1;i&lt;=n;i++){
        if(ma==q[i].a&amp;&amp;q[i].b==mb&amp;&amp;q[i].c==mc&amp;&amp;q[i].d==md&amp;&amp;q[i].e==me){
            cout&lt;&lt;i&lt;&lt;endl;
            return 0;
        }
    }
    cout&lt;&lt;&quot;WO LYF MEI YOU KAI GUA !&quot;&lt;&lt;endl;
    return 0;
}</code></pre><p><strong>E.1009的奇思妙想</strong><br>1009最近发现自己非常孤独,因为他开始有了自己的思想,并有了一个重大发现:除了1以外,他竟然不能被任何小于他的数整除!这可真是一个令人悲伤的发现呢.<br>后来慢慢的他意识到,他原来是一个较为特殊的数字–质数.</p>
<p>与此同时他还发现自己还有很多与他一样的小伙伴,如果他们能够抱团组成一个好大好大的数,这样他们就不会再孤独了.</p>
<p>于是他找到了和他长度相同的质数小伙伴,打算组成一个长度为x的超大数字</p>
<p>小伙伴们纷纷赞同1009的提议,并觉得如果单单拼在一起好像没什么难度,很无聊嘛,于是他们决定组合在一起,即他们要让组成的长度为x的数中,任意四个连续的数都是他的小伙伴(或者他自己),换句话说,就是组成的长度为x的数字中,任意连续四位都是一个质数且该质数不包含前导零.这样子大家你中有我,我中有你,只要有想组合的人(数字),就不是孤身一人(数字).</p>
<p>我们举个例子来说:对于98039这个数来说,连续的四位数有9803和8039,这两个数字都是质数,所以98039就算在长度为5的一种组成方法.</p>
<p>不过有多少种组成方式呢?1009想了很久,似乎还是想不来?那么你能解决这个问题吗?(答案对1e9+7取模)</p>
<p>注意:对于长度为5的位数来说,10097这种数字是不能算成一种组成方式的哦,因为连续的4位数右1009和0097,而0097虽然是一个质数,但他实际上是一个小于1000的数,即长度小于4,不是1009的小伙伴哦</p>
<pre><code>每个数字出现次数可能不止一次,且1009无需在每次组合方案中出现,比如98039也可以当成一种组合方案</code></pre><p>先打质数 找到1000到10000内的<br>我们发现 下一位连续4个质数 她的前3位和前一岑的4个质数 后三位一样<br>我们想到 dp[ 长度 ] [ 素数后3位 or前3位有关 ]<br>进而尝试一下 发现<br>dp[ k ] [ 素数%1000 ] += dp [ k - 1 ] [ 质数/10 ] ；不断累计</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;

const double eps = 1e-8;
int n,m;
const int mod = 1e9+7;

bool pri[10000];
int dp[3][1005];
int pre[2000];
int cnt;

void init(){
    pri[0]=pri[1]=1;
    for(int i=2;i&lt;10000;i++){
        if(pri[i]==0){
            pre[++cnt]=i;
            if(i&lt;10000&amp;&amp;i&gt;1000) dp[0][i%1000]++;
            for(int j=i+i;j&lt;10000;j+=i){
                pri[j]=1;
            }
        } 
    }
//    for(int i=1;i&lt;=cnt;i++){
//        if(pre[i]&gt;=1000&amp;&amp;pre[i]&lt;=10000) cout&lt;&lt;i&lt;&lt;&quot;  &quot;&lt;&lt;pre[i]&lt;&lt;endl;
//    //    else if(pre[i]&lt;=10000) cout&lt;&lt;i&lt;&lt;endl;
//    }
}

signed main() {
    int x;
    cin&gt;&gt;x;
    init();
    for(int i=5;i&lt;=x;i++){
        for(int j=169;j&lt;=1229;j++){
            dp[i%2][pre[j]%1000]=dp[i%2][pre[j]%1000]+dp[(i-1)%2][pre[j]/10];
            dp[i%2][pre[j]%1000]%=mod;
        }
        for(int j=0;j&lt;1000;j++) dp[(i-1)%2][j]=0;
    }
    int ans=0;
    for(int i=0;i&lt;1000;i++){
        ans+=dp[x%2][i];
        ans%=mod;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</code></pre><p><strong>F.CQW的幸福</strong></p>
<p>在很久很久以前，CQW喜欢上了一个女孩，可是CQW是一个爆脾气。恰好这个女孩喜欢脾气好的男孩子。于是CQW为了追求这个女孩子，就跑去找巫师NCE。NCE听闻此事之后，告诉CQW在珠穆朗玛之巅有一瓶宝贵的神药可以帮他解决这个问题，并且告知CQW在神药外围有一道机关，这个机关需要让他求出最小的有4^n个因子的数是多少，这一下子难住了CQW，于是CQW向你发起了求助，不知道聪明的你能不能帮CQW完成心愿，要知道CQW的幸福已经在你手中了！</p>
<p>4^n 变为 2^n<br>因子数 4 16 48 而质因子+1 连积 是约束个数 考虑每个素数贡献度<br>4个 约数的时候 是6 1 2 3 6 2^2 *3^1<br>2 下次在出现 如果想对于 2^n 有贡献度 必然是2^2<br>所以 我们把每次用过的数据平方放回去 一是保证最优同时最小 还确定了贡献度+1</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;
const int maxn = 1e7+5;
const int INF = 0x3f3f3f3f;
int cnt;

bool isp[maxn];

priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; que; 

void init(){
    for(int i=2;i&lt;maxn;i++){
        if(!isp[i]){
            que.push(i);
            for(int j=i+i;j&lt;maxn;j+=i) isp[j]=1;
        }
    }
}
const int mod = 998244353 ;

signed main() {
    int n;
    init();
    cin&gt;&gt;n;
    ll ans=1;
    for(int i=1;i&lt;=n;i++){
        int res=que.top();
        que.pop();
        ans=ans*res%mod;
        que.push(res*res);
    //    cout&lt;&lt;res&lt;&lt;endl;
        res=que.top();
        que.pop();
        ans=ans*res%mod;
        que.push(res*res);
        //cout&lt;&lt;res&lt;&lt;&quot;  &quot;&lt;&lt;ans&lt;&lt;endl;
    }
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</code></pre><p><strong>G.FWJ的追求者</strong><br>众所周知FWJ是一位打篮球特别厉害而且长得特别好看的小姐姐，迷倒了一群又一群篮球场上的小哥哥。最近又有一个小哥哥拜倒在了FWJ的石榴裙下，小哥哥展开了疯狂的最求，每天都送零食来实验室，FWJ小姐姐要保持身材，这些零食当然都到CQW的肚子里去了。可是FWJ早就对XZW芳心暗许，又怎会答应别人的最求呢？于是FWJ想让这位小哥哥知难而退，给他出了一道难题，题目如下：</p>
<pre><code>商店里有1到n元的商品，现在让你设计一种货币的面额

使得你手里的货币，可以买到1-n元的商品之间的任意一种

求不同货币面值数目最小的设计方法</code></pre><p>这位小哥哥很不甘心就这样放弃，于是向聪明的你发起了求救，你能否帮他解决这一难题呢？<br>洛谷原题。。。。</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
#define int long long
using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;

const int maxn = 1e3+5;
const int INF = 0x3f3f3f3f;

int n,m,k;

struct node{
    int a,b,c,d,e;
    int id;
}q[maxn];

signed main(){
    fastio;
    int cas;
    cin&gt;&gt;cas;
    while(cas--){
        cin&gt;&gt;n;
        int res=0;
        while(n){
            res++;
        //    cout&lt;&lt;n/2&lt;&lt;endl;
            n/=2;
        }
        cout&lt;&lt;res&lt;&lt;endl;
    }
    return 0;
}</code></pre><p><strong>H.ZBT的学分</strong><br>现在有N个活动，ZBT完成每个活动都可以获得一些学分，各个活动的获得的学分不尽相同，每个活动最多只能参加一次。</p>
<p>ZBT缺K个学分才能毕业，ZBT必须修够K个学分，不然他不能毕业，同时ZBT作为一个强迫症患者，有如下要求：</p>
<ol>
<li>他不想获得超过K个学分，也就是ZBT最后参加活动获得的总学分刚好是K个。</li>
</ol>
<ol start="2">
<li>如果有一些活动是他喜欢的活动，他哪怕影响毕业也要在这些活动中参加至少一个。</li>
</ol>
<p>现在他问你总共有多少个参加活动的方案数可以满足他的条件？</p>
<p>枚举 喜欢的 然后剩下的分2块 二分查 减低复杂度</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;

int n,m,k;

const int maxn = 55 ;
int a[maxn],b[maxn];
bool vis[maxn];
int q[maxn],h[maxn];
int qq[(1&lt;&lt;16)+10],hh[(1&lt;&lt;16)+10];
int ans;

signed main(){
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i];
    cin&gt;&gt;k&gt;&gt;m;
    for(int i=0;i&lt;m;i++) cin&gt;&gt;b[i],b[i]--;
    if(m==0){
        int cnt1=0,cnt2=0;

        int resk=k;

        for(int j=0;j&lt;n;j++){
            if(cnt1&lt;cnt2) q[cnt1++] = a[j];
            else h[cnt2++] = a[j];
        }

        int cn1=(1&lt;&lt;cnt1);
        int cn2=(1&lt;&lt;cnt2);

        for(int j=0;j&lt;(cn1);j++){
            qq[j]=0;
            for(int z=0;z&lt;=17;z++)
                if(j&amp;(1&lt;&lt;z)) qq[j]+=q[z];
        }

        for(int j=0;j&lt;(cn2);j++){
            hh[j]=0;
            for(int z=0;z&lt;=17;z++)
                if(j&amp;(1&lt;&lt;z)) hh[j]+=h[z];
        }

        sort(hh,hh+cn2);

        for(int j=0;j&lt;cn1;j++){
            ans+=(upper_bound(hh,hh+cn2,resk-qq[j])-lower_bound(hh,hh+cn2,resk-qq[j]));
        }
    }
    else for(int i=0;i&lt;m;i++){
        vis[b[i]]=1;

        int cnt1=0,cnt2=0;

        int resk=k-a[b[i]];

        for(int j=0;j&lt;n;j++){
            if(vis[j]) continue ; 
            else if(cnt1&lt;cnt2) q[cnt1++] = a[j];
            else h[cnt2++] = a[j];
        }

        int cn1=(1&lt;&lt;cnt1);
        int cn2=(1&lt;&lt;cnt2);

        for(int j=0;j&lt;(cn1);j++){
            qq[j]=0;
            for(int z=0;z&lt;=17;z++)
                if(j&amp;(1&lt;&lt;z)) qq[j]+=q[z];
        }

        for(int j=0;j&lt;(cn2);j++){
            hh[j]=0;
            for(int z=0;z&lt;=17;z++)
                if(j&amp;(1&lt;&lt;z)) hh[j]+=h[z];
        }

        sort(hh,hh+cn2);

        for(int j=0;j&lt;cn1;j++){
            ans+=(upper_bound(hh,hh+cn2,resk-qq[j])-lower_bound(hh,hh+cn2,resk-qq[j]));
        }

    }
        cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</code></pre><p><strong>I.SHT的梦想</strong><br>欧拉降幂 + 线段树 不会数学 告辞</p>
<p><strong>J.ZBT的游戏</strong><br>区间计数 裸题 数据应该是水了 0 1 0 1 0 1 底层要是这样的数据 都n2卡死了 正解要不离线 要不莫队分块来着</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int,int&gt; P;
const int maxn = 2e6+5;
const int INF = 0x3f3f3f3f;

struct node{
    int col;
    int laz;
}tree[maxn&lt;&lt;2];

void pushup(int rt){
    if(tree[rt&lt;&lt;1].col!=tree[rt&lt;&lt;1|1].col) tree[rt].col=-1;
    else tree[rt].col=tree[rt&lt;&lt;1].col;
}

void pushdown(int rt){
    if(tree[rt].laz!=0){
        tree[rt&lt;&lt;1].col=tree[rt&lt;&lt;1|1].col=tree[rt].laz;
        tree[rt&lt;&lt;1].laz=tree[rt&lt;&lt;1|1].laz=tree[rt].laz;
        tree[rt].laz=0;
    }
}

void update(int L,int R,int l,int r,int rt,int c){
    if(L&lt;=l&amp;&amp;R&gt;=r){
        tree[rt].laz=c;
        tree[rt].col=c;
        return ;
    }
    pushdown(rt);
    int mid=(l+r)&gt;&gt;1;
    if(L&lt;=mid) update(L,R,l,mid,rt&lt;&lt;1,c);
    if(mid&lt;R) update(L,R,mid+1,r,rt&lt;&lt;1|1,c);
    pushup(rt);
}

set&lt;int&gt; S;

int query(int L,int R,int l,int r,int rt){
    if(L&lt;=l&amp;&amp;r&lt;=R&amp;&amp;tree[rt].col!=-1){
        if(tree[rt].col!=0)    S.insert(tree[rt].col);
        return 0;
    }
    if(l==r){
        if(tree[rt].col!=0) S.insert(tree[rt].col);
        return 0;
    }
    pushdown(rt);
    int mid=(l+r)&gt;&gt;1;
    if(L&lt;=mid) query(L,R,l,mid,rt&lt;&lt;1);
    if(R&gt;mid) query(L,R,mid+1,r,rt&lt;&lt;1|1);
    pushup(rt);
}

signed main() {
    int cas;
    int n,m,k;
//    freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);
//    freopen(&quot;a.out&quot;,&quot;w+&quot;,stdout);
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
    char cmd[20];
    int l,r;
    int f=0;
    for(int i=1;i&lt;=m;i++){
        scanf(&quot;%s %d %d&quot;,cmd,&amp;l,&amp;r);
        int t;
        if(cmd[0]==&apos;C&apos;){
            scanf(&quot;%d&quot;,&amp;t);
            update(l,r,1,n,1,t);
        }else{
            f=1;
            S.clear();
            query(l,r,1,n,1);
            printf(&quot;%d\n&quot;,S.size());
        }
    }
    if(!f) printf(&quot;This is a boring game!\n&quot;);
    return 0;
}</code></pre><p><strong>K.ZJ和LQW打羽毛球</strong><br>不会<br><strong>L.SW和ZK的恋爱</strong><br>lcm 比如说 8 2个0 你就。。。。找8和200的lcm orz</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/05/08/入门状压DP [SCOI2005] 互不侵犯  [USACO06NOV] 玉米田Corn Fields [NOI2001] 炮兵阵地/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/08/入门状压DP [SCOI2005] 互不侵犯  [USACO06NOV] 玉米田Corn Fields [NOI2001] 炮兵阵地/" itemprop="url">入门状压DP [SCOI2005] 互不侵犯  [USACO06NOV] 玉米田Corn Fields [NOI2001] 炮兵阵地</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-08T13:11:59+08:00">
                2019-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DP/" itemprop="url" rel="index">
                    <span itemprop="name">DP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先附上 <a href="https://blog.csdn.net/qq_40831340/article/details/81502522" target="_blank" rel="noopener"> https://blog.csdn.net/qq_40831340/article/details/81502522
</a><br>TSP问题<br>Traveling by Stagecoach POJ - 2686 和 2018年小白月赛4 D-郊区春游题解</p>
<h2 id="SCOI2005-互不侵犯"><a href="#SCOI2005-互不侵犯" class="headerlink" title="[SCOI2005]互不侵犯"></a>[SCOI2005]互不侵犯</h2><p>题目描述<br>在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共8个格子。</p>
<p>输入输出格式<br>输入格式：<br>只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N）</p>
<p>输出格式：<br>所得的方案数</p>
<p>输入输出样例<br>输入样例#1：<br>3 2<br>输出样例#1：<br>16</p>
<p>二进制 先预处理出来不相邻的1 代表国王可以有的状态 就可以减少枚举次数<br>同时记录下 这个状态用了多少国王</p>
<p>接下来从第二层开始 dp 首先确保 2层不冲突 就把 上层状态[ p ]+这次放多少 kins[ j ]本次状态可以放多少 不断加下去就好</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
#define int long long
using namespace std;
typedef long long ll;

ll dp[15][(1&lt;&lt;9)+5][100];
int n,m,k;
int cnt,ans;
int state[1&lt;&lt;11],king[1&lt;&lt;11];

void init() {
    int tot=(1&lt;&lt;n)-1;
    for(int i=0; i&lt;=tot; i++) {
        if(!((i&lt;&lt;1)&amp;i)) {
            state[++cnt]=i;
            int res=i;
            while(res) {
                king[cnt]+=res%2;
                res&gt;&gt;=1;
            }
        }
    }
}

signed main() {
    fastio;
    cin&gt;&gt;n&gt;&gt;k;
    init();
    for(int i=1; i&lt;=cnt; i++) dp[1][i][king[i]]=1;
    //    if(king[i]&lt;=k) 

    for(int i=2;i&lt;=n;i++){
        for(int j=1;j&lt;=cnt;j++){
            for(int p=1;p&lt;=cnt;p++){
                if(state[j]&amp;state[p]) continue;
                if(state[j]&amp;(state[p]&lt;&lt;1)) continue;
                if((state[j]&lt;&lt;1)&amp;state[p]) continue;

                for(int s=1;s&lt;=k;s++){
                    if(king[j]+s&gt;k) break;
                    dp[i][j][king[j]+s]+=dp[i-1][p][s];
                }

            }
        }
    }
    int ans=0;
    for(int i=1;i&lt;=n;i++){
        for(int j=1;j&lt;=cnt;j++)
            ans+=dp[i][j][k]; 
    } 
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</code></pre><h2 id="USACO06NOV-玉米田Corn-Fields"><a href="#USACO06NOV-玉米田Corn-Fields" class="headerlink" title="[USACO06NOV] 玉米田Corn Fields"></a>[USACO06NOV] 玉米田Corn Fields</h2><p>农场主John新买了一块长方形的新牧场，这块牧场被划分成M行N列(1 ≤ M ≤ 12; 1 ≤ N ≤<br>12)，每一格都是一块正方形的土地。John打算在牧场上的某几格里种上美味的草，供他的奶牛们享用。</p>
<p>遗憾的是，有些土地相当贫瘠，不能用来种草。并且，奶牛们喜欢独占一块草地的感觉，于是John不会选择两块相邻的土地，也就是说，没有哪两块草地有公共边。</p>
<p>John想知道，如果不考虑草地的总块数，那么，一共有多少种种植方案可供他选择？（当然，把新牧场完全荒废也是一种方案）</p>
<p>输入输出格式<br>输入格式：<br>第一行：两个整数M和N，用空格隔开。</p>
<p>第2到第M+1行：每行包含N个用空格隔开的整数，描述了每块土地的状态。第i+1行描述了第i行的土地，所有整数均为0或1，是1的话，表示这块土地足够肥沃，0则表示这块土地不适合种草。</p>
<p>输出格式：<br>一个整数，即牧场分配总方案数除以100,000,000的余数。</p>
<p>输入输出样例<br>输入样例#1：<br>2 3<br>1 1 1<br>0 1 0<br>输出样例#1：<br>9</p>
<p>本题与上题大体一样。。。。。。。都不要处理每层cows的个数 仅统计方法总数</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
#define int long long
using namespace std;
typedef long long ll;

const long long mod = 1e8;

int n,m,ans;

int mp[15];
int dp[15][((1&lt;&lt;12)+5)];
int state[(1&lt;&lt;12)+5],cows[(1&lt;&lt;12)+5];
int cnt;

void init() {
    int tot=(1&lt;&lt;m)-1;
    for(int i=0; i&lt;=tot; i++) {
        if((i&lt;&lt;1)&amp;i) continue;
        int res=i;
        state[++cnt]=i;
        while(res) {
            cows[cnt]+=res%2;
            res&gt;&gt;=1;
        }
    }
}

signed main() {
    fastio;
//    freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);
    cin&gt;&gt;n&gt;&gt;m;

    for(int i=1;i&lt;=n;i++){
        int res=0,k;
        for(int j=m-1;j&gt;=0;j--){
            cin&gt;&gt;k;
            mp[i]|=(k&lt;&lt;j);
        }
    }

    init();
    for(int i=1;i&lt;=cnt;i++)
        if((mp[1]|state[i])!=mp[1]) continue;
        else dp[1][state[i]]=1;

    for(int i=2;i&lt;=n;i++){
        for(int j=1;j&lt;=cnt;j++){
            if((mp[i]|state[j])!=mp[i]) continue;
            for(int p=1;p&lt;=cnt;p++){
                if((mp[i-1]|state[p])!=mp[i-1]) continue;
                if(state[p]&amp;state[j]) continue;
                dp[i][state[j]]=(dp[i][state[j]]+dp[i-1][state[p]])%mod;
            }
        }
    }

    for(int i=0;i&lt;(1&lt;&lt;m);i++) ans=(ans+dp[n][i])%mod;
    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</code></pre><h2 id="NOI2001-炮兵阵地"><a href="#NOI2001-炮兵阵地" class="headerlink" title="[NOI2001]炮兵阵地"></a>[NOI2001]炮兵阵地</h2><p>题目描述<br>司令部的将军们打算在N <em>M的网格地图上部署他们的炮兵部队。一个N</em> M的地图由N行M列组成，地图的每一格可能是山地（用“H”<br>表示），也可能是平原（用“P”表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：<br><img src="https://img-blog.csdnimg.cn/20190508130632183.jpg" alt="在这里插入图片描述"></p>
<p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。<br>现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。</p>
<p>输入输出格式<br>输入格式：<br>第一行包含两个由空格分割开的正整数，分别表示N和M；</p>
<p>接下来的N行，每一行含有连续的M个字符（‘P’或者‘H’），中间没有空格。按顺序表示地图中每一行的数据。N≤100；M≤10。</p>
<p>输出格式：<br>仅一行，包含一个整数K，表示最多能摆放的炮兵部队的数量。</p>
<p>输入输出样例<br>输入样例#1：<br>5 4<br>PHPP<br>PPHH<br>PPPP<br>PHPP<br>PHHP<br>输出样例#1：<br>6</p>
<p>这题相比上2道题 多了要处理的 层数<br>所以 我们选择 开3位 第一位层数 第二位 前一层的状态 第三位 当前层的状态<br>先处理 1 2 层 将炮车数 初始化<br>接下来 像前2道题一样 不断枚举每层的状态 和前一层 前2层的状态 判断合法<br>最后只要在 最后一层 所有状态中找最大值就好<br>(也可以在在dp过程中接着ans=max(ans,dp[ i ][ p ][ j ]));</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
#define int long long
using namespace std;
typedef long long ll;

const long long mod = 1e8;

int n,m,ans;

int mp[105];
int dp[105][((1&lt;&lt;6)+5)][(1&lt;&lt;6)+5];
int state[(1&lt;&lt;6)+5],pcs[(1&lt;&lt;6)+5];
int cnt;

void init() {
    int tot=(1&lt;&lt;m)-1;
    for(int i=0; i&lt;=tot; i++) {
        if((i&lt;&lt;1)&amp;i) continue;
        if((i&lt;&lt;2)&amp;i) continue;
        state[++cnt]=i;
        int res=i;
        while(res) {
            pcs[cnt]+=res%2;
            res&gt;&gt;=1;
        }
        if(!(mp[1]&amp;state[cnt])) dp[1][0][cnt]=pcs[cnt];
    }

    for(int i=1; i&lt;=cnt; i++) {
        for(int j=1; j&lt;=cnt; j++) {
            if(state[i]&amp;state[j]) continue;
            if(mp[2]&amp;state[j]) continue;
            dp[2][i][j]=max(dp[2][i][j],dp[1][0][i]+pcs[j]);
        }
    }
}

signed main() {
    fastio;
//    freopen(&quot;a.in&quot;,&quot;r&quot;,stdin);
    cin&gt;&gt;n&gt;&gt;m;
    string str;
    for(int i=1; i&lt;=n; i++) {
        cin&gt;&gt;str;
        int res=0;
        for(int j=0; j&lt;m; j++) {
            if(str[j]==&apos;H&apos;) res=res&lt;&lt;1|1;
            else res&lt;&lt;=1;
        }
        mp[i]=res;
    }
    init();
    // wa 这密密麻麻的continue啊 让我ac吧 233333
    for(int i=3; i&lt;=n; i++) {
        for(int j=1; j&lt;=cnt; j++) {

            if(mp[i]&amp;state[j]) continue;

            for(int p=1; p&lt;=cnt; p++) {

                if(mp[i-1]&amp;state[p]) continue;
                if(state[j]&amp;state[p]) continue;

                for(int k=1; k&lt;=cnt; k++) {

                    if(mp[i-2]&amp;state[k]) continue;
                    if(state[k]&amp;state[j]) continue;
                    if(state[k]&amp;state[p]) continue;

                    dp[i][p][j]=max(dp[i-1][k][p]+pcs[j],dp[i][p][j]);
                }
            }
        }
    }

    for(int i=1; i&lt;=cnt; i++)
        for(int j=1; j&lt;=cnt; j++)
            ans=max(ans,dp[n][i][j]);

    cout&lt;&lt;ans&lt;&lt;endl;
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/04/22/The Preliminary Contest for ICPC China Nanchang 南昌网络赛 A H I K M J题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/22/The Preliminary Contest for ICPC China Nanchang 南昌网络赛 A H I K M J题/" itemprop="url">The Preliminary Contest for ICPC China Nanchang 南昌网络赛 A H I K M J题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-22T13:45:41+08:00">
                2019-04-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/题集/" itemprop="url" rel="index">
                    <span itemprop="name">题集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我补过 J题拉 orz 交了3次 重写了一次orz<br><del>真是太快乐(自闭)拉</del><br>连接 <a href="https://blog.csdn.net/qq_40831340/article/details/90739880" target="_blank" rel="noopener"> https://blog.csdn.net/qq_40831340/article/details/90739880
</a></p>
<blockquote>
<p>A PERFECT NUMBER PROBLEM<br> Write a program to output the first 55 perfect numbers. A perfect number is<br>defined to be a positive integer where the sum of its positive integer<br>divisors excluding the number itself equals the number.<br> For example: 1+ 2 + 3 = 61+2+3=6, and 66 is the first perfect number.<br> There is no input for this problem.</p>
</blockquote>
<p>百度完美数可得。。。。</p>
<pre><code>int main(){
    cout&lt;&lt;&quot;6&quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;28&quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;496&quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;8128&quot;&lt;&lt;endl;
    cout&lt;&lt;&quot;33550336&quot;&lt;&lt;endl;
    return 0;
}</code></pre><blockquote>
<p>M Subsequence</p>
</blockquote>
<p>给母串 和一些子串 问 字串是否在母串出现过 (可以不连续) 2018百度之星网络赛第一题 2019 牛客小白月赛12 最后一题 贴过来就过 。。。</p>
<p>其实就是开了个26*maxn 的数组 倒着扫 存每层下一个字母出现位置 就可以 o(m) 的确定一个串存不存在了</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int maxn = 1e5+5;

char mp[maxn];
char sp[maxn];
int pos[30][maxn];

int main() {
    scanf(&quot;%s&quot;,mp);
    int len=strlen(mp);
    for(int i=len-1; i&gt;=0; i--) {
        for(int j=27; j&gt;=1; j--) {
            pos[j][i]=pos[j][i+1];
        }
        pos[mp[i]-&apos;a&apos;+1][i]=i+1;

    }
    int n;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1; i&lt;=n; i++) {
        scanf(&quot;%s&quot;,sp);
        len=strlen(sp);
        int j=0;
        int nxt=0;
        while(j&lt;len) {
            nxt=pos[sp[j]-&apos;a&apos;+1][nxt];
            if(nxt==0) {
                cout&lt;&lt;&quot;NO\n&quot;;
                break;
            }
            if(j==len-1) {
                cout&lt;&lt;&quot;YES\n&quot;;
                break;
            }
            j++;
        }
    }
    return 0;
}</code></pre><blockquote>
<p>H Coloring Game<br> David has a white board with 2 \times N2×N grids.He decides to paint some<br>grids black with his brush.He always starts at the top left corner and ends at<br>the bottom right corner, where grids should be black ultimately.<br> Each time he can move his brush up(↑), down(↓), left(←), right(→), left<br>up(↖), left down(↙), right up(↗), right down (↘) to the next grid.<br> For a grid visited before,the color is still black. Otherwise it changes<br>from white to black.<br> David wants you to compute the number of different color schemes for a<br>given board. Two color schemes are considered different if and only if the<br>color of at least one corresponding position is different.</p>
</blockquote>
<p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190422134814982.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190422134814982.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)<br>给你一个2x n 个网格 这个人左上走到右下 走过的格子涂黑 它可以走周围8个方向<br>因为它最后是到右下的 我们可以认为 这个2x n 除了第一层(左上一定黑) 和 最后一层（右下一定黑）<br>其他层 只有3个状态 10 01 11 所以 是3^（n-2）个状态 + 第一层和最后一次的4个状态<br>ans = 4*3^（n-2）;</p>
<p>ps 1列 特判；</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
//#define int long long
using namespace std;
typedef long long ll;
const long long INF = 0x3f3f3f3f3f3f3f3f ;
const int maxn = 5e5 + 5 ;
const long long mod=1000000007;

long long int quick_mod(long long int a,long long int b) {
    long long int ans=1;
    a%=mod;
    while(b) {
        if(b&amp;1) {
            ans=ans*a%mod;
            b--;
        }
        b&gt;&gt;=1;
        a=a*a%mod;
    }
    return ans;
}

int main() {
    ll n;
    cin&gt;&gt;n;
    if(n==1) cout&lt;&lt;1&lt;&lt;endl;
    else cout&lt;&lt;4*quick_mod(3,n-2)%mod&lt;&lt;endl;
    return 0;
}</code></pre><blockquote>
<p>I Max answer<br> Alice has a magic array. She suggests that the value of a interval is equal<br>to the sum of the values in the interval, multiplied by the smallest value in<br>the interval.<br> Now she is planning to find the max value of the intervals in her array.<br>Can you help her?</p>
</blockquote>
<p>给你一个长度n的序列 选取一个数字 和(包含它连续的)区间(而且它必须是这个区间的最小值) 使a[i]*(这一区间的和) 最大<br>首先单调栈 处理每个a[ i ] 管理区间(没有比它小的最大连续区间)<br>然后 对 a[ i ] 分2种情况 正负来考虑</p>
<ol>
<li>大于 0 的情况 显然是 它 管理的区间和*a[ i ] 因为a[i]&gt;0 同时它肯定是这区间最低点 该区间越长和越大 </li>
<li>小于 0 的情况 不妨我们维护一个 前缀和 既然它是负数 我们 当前i 到R[ i ]前缀和最好越小越好 而L[ i ] 到 i得和越大越好 </li>
</ol>
<pre><code>#include&lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
//#define int long long
using namespace std;
typedef long long ll;
const long long INF = 0x3f3f3f3f3f3f3f3f ;
const int maxn = 5e5 + 5 ;

int n;
ll a[maxn],sum[maxn]; 
int L[maxn],R[maxn];

struct node {
    ll minsum,maxsum;
} tr[maxn&lt;&lt;4];

void pushup(int rt) {
    tr[rt].minsum=min(tr[rt&lt;&lt;1].minsum,tr[rt&lt;&lt;1|1].minsum);
    tr[rt].maxsum=max(tr[rt&lt;&lt;1].maxsum,tr[rt&lt;&lt;1|1].maxsum);
}

void build(int l,int r,int rt) {
    if(l==r) {
        tr[rt]={sum[l],sum[l]};
        return ;
    }
    int mid=(l+r)&gt;&gt;1;
    build(l,mid,rt&lt;&lt;1);
    build(mid+1,r,rt&lt;&lt;1|1);
    pushup(rt);
}

ll maxquery(int L,int R,int l,int r,int rt){
    if(L&lt;=l&amp;&amp;r&lt;=R){
        return tr[rt].maxsum;
    }
    int mid=(l+r)&gt;&gt;1;
    ll res=-INF;
    if(L&lt;=mid) res=max(res,maxquery(L,R,l,mid,rt&lt;&lt;1));
    if(R&gt;mid) res=max(res,maxquery(L,R,mid+1,r,rt&lt;&lt;1|1));
    return res;
}

ll minquery(int L,int R,int l,int r,int rt){
    if(L&lt;=l&amp;&amp;r&lt;=R){
        return tr[rt].minsum;
    }
    int mid=(l+r)&gt;&gt;1;
    ll res=INF;
    if(L&lt;=mid) res=min(res,minquery(L,R,l,mid,rt&lt;&lt;1));
    if(R&gt;mid) res=min(res,minquery(L,R,mid+1,r,rt&lt;&lt;1|1));
    return res;
}

void solLR() {
    stack&lt;int&gt; s;
    for(int i=1; i&lt;=n; i++) {
        while(!s.empty()&amp;&amp;a[s.top()]&gt;=a[i]) s.pop();
        L[i]=(s.empty())?0:s.top();
        s.push(i);
    }
    while(!s.empty()) s.pop();
    for(int i=n; i&gt;=1; i--) {
        while(!s.empty()&amp;&amp;a[s.top()]&gt;=a[i]) s.pop();
        R[i]=(s.empty())?(n+1):s.top();
        s.push(i);
    }
}

signed main() {
    scanf(&quot;%lld&quot;,&amp;n);
    for(int i=1; i&lt;=n; i++) scanf(&quot;%lld&quot;,&amp;a[i]),sum[i]=sum[i-1]+a[i];
    solLR();
    build(1,n,1);
    ll ans=-INF;
    ll rmin,lmax;
    for(int i=1; i&lt;=n; i++) {
        if(a[i]&lt;0) {
            rmin=minquery(i,R[i]-1,1,n,1);
            lmax=maxquery(L[i]+1,i,1,n,1);
            ans=max(ans,a[i]*(rmin-lmax));
        } else {
            ans=max(ans,a[i]*(sum[R[i]-1]-sum[L[i]]));
        }
    }
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}</code></pre><blockquote>
<p>K MORE XOR<br> Given a sequence of n numbers and three functions.<br> Define a function f(l,r)f(l,r) which returns \oplus a[x]⊕a[x] (l \le x \le<br>rl≤x≤r). The \oplus⊕ represents exclusive OR.<br> Define a function g(l,r)g(l,r) which returns \oplus f(x,y)(l \le x \le y<br>\le r)⊕f(x,y)(l≤x≤y≤r).<br> Define a function w(l,r)w(l,r) which returns \oplus g(x,y)(l \le x \le y<br>\le r)⊕g(x,y)(l≤x≤y≤r).<br> You are also given a number of xor-queries. A xor-query is a pair (i, ji,j)<br>(1 \le i \le j \le n1≤i≤j≤n). For each xor-query (i, j)(i,j), you have to<br>answer the result of function w(l,r)w(l,r).</p>
</blockquote>
<p>让你求异或得前缀和的前缀和的前缀和 orz 规律题 异或 出现2次的数字 显然是0 这里搞贡献度就好<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190422134149740.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190422134149740.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)<br>发现 4 组一循环 当长度是 1的时候 只取这个段的每4个数的第一个 orz 其他的看表</p>
<p>暴力直接for超时了 这里选择维护一个前缀异或和的数组</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)
using namespace std;
typedef long long ll;
const int INF = 0x3f3f3f3f ;
const int maxn = 1e5 + 5 ;

int a[maxn];

int main() {
    int t,n,l,r,res,len,q;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--) {
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1; i&lt;=n; i++) scanf(&quot;%d&quot;,&amp;a[i]);
        for(int i=4; i&lt;=n; i++) a[i]^=a[i-4];
        scanf(&quot;%d&quot;,&amp;q);
        while(q--) {
            scanf(&quot;%d %d&quot;,&amp;l,&amp;r);
            len = r - l + 1 ;
            if(len%4==0) printf(&quot;0\n&quot;);
            else if(len % 4 == 1) {
                if(l&gt;=4) res=a[r]^a[l-4];
                else res=a[r];
                printf(&quot;%d\n&quot;,res);
            } else if(len % 4 == 2) {
                if(l&gt;=4) res=a[r]^a[l-4];
                else res=a[r];
                l++,r--;
                if(l&gt;=4) res=res^a[r]^a[l-4];
                else res=res^a[r];
                printf(&quot;%d\n&quot;,res);

            } else if(len % 4 == 3) {
                l++,r--;
                if(l&gt;=4) res=a[r]^a[l-4];
                else res=a[r];
                printf(&quot;%d\n&quot;,res);
            }
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/04/09/CCPC-Wannafly Winter Camp Day3 (Div2, onsite)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/09/CCPC-Wannafly Winter Camp Day3 (Div2, onsite)/" itemprop="url">CCPC-Wannafly Winter Camp Day3 (Div2, onsite)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-09T11:40:14+08:00">
                2019-04-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>A 二十四点* (暴力)<br>orz 被队友带躺 A题我是暴力不出这么快的<br>虽然只有2个测试点 一个 6 一个 10</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;
#include &lt;map&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;

ll ans=0,n;

ll yz(ll zu[],ll s) {    //data shengchende shuzu,s wei changdu

    if(s&lt;2) return 0;

    for(int i=0; i&lt;s; i++) {
        for(int j=i+1; j&lt;s; j++) {
            ll a=zu[i]+zu[j];
            if(a==24) return 1;
            else {
                ll ne[15],lz=0;
                for(int k=0; k&lt;s; k++) {
                    if(k==i||k==j) continue;
                    ne[lz]=zu[k];
                    lz++;
                }
                ne[lz]=a;
                if(yz(ne,s-1)==1) return 1;
            }

            ll b=abs(zu[i]-zu[j]);
            if(b==24) return 1;
            else if(b==0) ;
            else {
                ll ne[15],lz=0;
                for(int k=0; k&lt;s; k++) {
                    if(k==i||k==j) continue;
                    ne[lz]=zu[k];
                    lz++;
                }
                ne[lz]=b;
                if(yz(ne,s-1)==1) return 1;
            }

            ll c=zu[i]*zu[j];
            if(c==24) return 1;
            else {
                ll ne[15],lz=0;
                for(int k=0; k&lt;s; k++) {
                    if(k==i||k==j) continue;
                    ne[lz]=zu[k];
                    lz++;
                }
                ne[lz]=c;
                if(yz(ne,s-1)==1) return 1;
            }

            ll d=-1;
            if(zu[i]&gt;zu[j]&amp;&amp;zu[i]%zu[j]==0) d=zu[i]/zu[j];
            else if(zu[i]&lt;zu[j]&amp;&amp;zu[j]%zu[i]==0) d=zu[j]/zu[i];
            if(d==-1) continue;
            if(d==24) return 1;
            else {
                ll ne[15],lz=0;
                for(int k=0; k&lt;s; k++) {
                    if(k==i||k==j) continue;
                    ne[lz]=zu[k];
                    lz++;
                }
                ne[lz]=d;
                if(yz(ne,s-1)==1) return 1;

            }
        }
    }
    return 0;
}

void zxl(ll data[],ll zu[],ll s,ll x) {    //data shengchende shuzu,s wei changdu
    if(s&gt;=n||x&gt;=n) return;

    ll ne[15]= {0};

    for(int i=0; i&lt;s; i++) {
        ne[i]=zu[i];
    }

    for(int i=x; i&lt;n; i++) {
        ne[s]=data[i];

        if(yz(ne,s+1)!=0) {
            ans++;
        }
        zxl(data,ne,s+1,i+1);
    }
}


int main() {
    ans=0;
    ll data[15]= {0},zu[15]= {2,3,4};
    scanf(&quot;%lld&quot;,&amp;n);
    for(int i=0; i&lt;n; i++) scanf(&quot;%lld&quot;,&amp;data[i]);
    zxl(data,zu,0,0);

    printf(&quot;%lld&quot;,ans);
    return 0;
}</code></pre><p>G 排列 (模拟） 对不起 其实我连题都读不懂。。。。。。。。。。。。orz<br>p：原数组<br>Ap：前缀数组<br>q：p中第i小的前缀的长度<br>q 可以还原 Ap 数组 但是 Ap必须是非递增的<br>所以 样例<br>q 5 3 4 1 2<br>Ap 3 0 2 0 1 出现 某个数据位置小于前一个 当0 它必然是 最后cnt++;<br>p 3 4 2 5 1</p>
<pre><code>#include &lt;bits/stdc++.h&gt; 
using namespace std;
typedef long long ll;
typedef unsigned long long ull;

const int maxn = 1e5+5; 
int a[maxn];
int cnt,n,m;
int ans[maxn];

int main() {
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++){
        cin&gt;&gt;a[i];
        if(a[i]&lt;a[i-1]||i==1) ans[a[i]]=++cnt;
    } 
    for(int i=1;i&lt;=n;i++){
        if(i!=1) cout&lt;&lt;&quot; &quot;;
        if(ans[i]) cout&lt;&lt;ans[i];
        else cout&lt;&lt;++cnt;
    }puts(&quot;&quot;);
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/04/08/CCPC-Wannafly Winter Camp Day2 (Div2, onsite) H Cosmic Cleaner (计算几何)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/08/CCPC-Wannafly Winter Camp Day2 (Div2, onsite) H Cosmic Cleaner (计算几何)/" itemprop="url">CCPC-Wannafly Winter Camp Day2 (Div2, onsite) H Cosmic Cleaner (计算几何)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-08T21:13:23+08:00">
                2019-04-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2球相交 求体积和 很多人的板子应该都是从</p>
<blockquote>
<p><a href="https://blog.csdn.net/enterprise_/article/details/81624174" target="_blank" rel="noopener"> https://blog.csdn.net/enterprise_/article/details/81624174
</a><br> ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190408211221330.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190408211221330.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)<br> ![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190408211243638.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190408211243638.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)</p>
</blockquote>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const int maxn = 6000+5;
const int INF = 0x3f3f3f3f;
const int cx[]= {0,0,1,-1};
const int cy[]= {1,-1,0,0};
const double eps= 1&gt;&gt;10;
const int maxv = 100+5;
const double PI=acos(-1.0);

int n,m,k,t;

struct node {
    double x,y,z,r;
} a[maxn];

double dx,dy,dr,dz;

typedef struct point {
    double x,y,z;
    point() {}
    point(double a, double b,double c) {
        x = a;
        y = b;
        z = c;
    }
    point operator -(const point &amp;b)const {     //返回减去后的新点
        return point(x - b.x, y - b.y,z-b.z);
    }
    point operator +(const point &amp;b)const {     //返回加上后的新点
        return point(x + b.x, y + b.y,z+b.z);
    }
    //数乘计算
    point operator *(const double &amp;k)const {    //返回相乘后的新点
        return point(x * k, y * k,z*k);
    }
    point operator /(const double &amp;k)const {    //返回相除后的新点
        return point(x / k, y / k,z/k);
    }
    double operator *(const point &amp;b)const {    //点乘
        return x*b.x + y*b.y+z*b.z;
    }
} point;

double dist(point p1, point p2) {       //返回平面上两点距离
    return sqrt((p1 - p2)*(p1 - p2));
}

typedef struct sphere {//球
    double r;
    point centre;
} sphere;

double res(sphere a, sphere b) {
    double v=0;
    double d = dist(a.centre, b.centre);//球心距
    double t = (d*d + a.r*a.r - b.r*b.r) / (2.0 * d);//
    double h = sqrt((a.r*a.r) - (t*t)) * 2;//h1=h2，球冠的高
    double angle_a = 2 * acos((a.r*a.r + d*d - b.r*b.r) / (2.0 * a.r*d));  //余弦公式计算r1对应圆心角，弧度
    double angle_b = 2 * acos((b.r*b.r + d*d - a.r*a.r) / (2.0 * b.r*d));  //余弦公式计算r2对应圆心角，弧度
    double l1 = ((a.r*a.r - b.r*b.r) / d + d) / 2;
    double l2 = d - l1;
    double x1 = a.r - l1, x2 = b.r - l2;//分别为两个球缺的高度
    double v1 = PI*x1*x1*(a.r - x1 / 3);//相交部分r1圆所对应的球缺部分体积
    double v2 = PI*x2*x2*(b.r - x2 / 3);//相交部分r2圆所对应的球缺部分体积
    return v = v1 + v2;//相交部分体积
}

int main() {
    cin&gt;&gt;t;
    int cas=1;
    while(t--) {
        scanf(&quot;%d&quot;,&amp;n);
        for(int i=1; i&lt;=n; i++) {
            scanf(&quot;%lf %lf %lf %lf&quot;,&amp;a[i].x,&amp;a[i].y,&amp;a[i].z,&amp;a[i].r);
        }
        scanf(&quot;%lf %lf %lf %lf&quot;,&amp;dx,&amp;dy,&amp;dz,&amp;dr);
        sphere tp,b;
        b.centre.x=dx;
        b.centre.y=dy;
        b.centre.z=dz;
        b.r=dr;
        double V=0;
        for(int i=1; i&lt;=n; i++) {
            double len=abs(sqrt((a[i].x-dx)*(a[i].x-dx)+(a[i].y-dy)*(a[i].y-dy)+(a[i].z-dz)*(a[i].z-dz)));
            if(len&gt;dr+a[i].r) continue;
            else if(len&lt;=dr-a[i].r) {
                V+=4*PI*a[i].r*a[i].r*a[i].r/3;
                continue;
            } else {
                tp.centre.x=a[i].x;
                tp.centre.y=a[i].y;
                tp.centre.z=a[i].z;
                tp.r=a[i].r;
                V+=res(tp,b);
            }
        }
        //   cout&lt;&lt;V&lt;&lt;endl;
        printf(&quot;Case #%d: %.9lf\n&quot;,cas++,V);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="ZHXU1998">
            
              <p class="site-author-name" itemprop="name">ZHXU1998</p>
              <p class="site-description motion-element" itemprop="description">等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZHXU1998</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
