<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢">
<meta property="og:type" content="website">
<meta property="og:title" content="蒟蒻最后的倔强">
<meta property="og:url" content="http://zhxu98.github.io/page/3/index.html">
<meta property="og:site_name" content="蒟蒻最后的倔强">
<meta property="og:description" content="等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蒟蒻最后的倔强">
<meta name="twitter:description" content="等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://zhxu98.github.io/page/3/">





  <title>蒟蒻最后的倔强</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?58b7e016a3433eb1162126ec13ec1dbf";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蒟蒻最后的倔强</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">by-zhxu98</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/15/2019 牛客多校第九场 E All men are brothers (并查集 + 数学)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/2019 牛客多校第九场 E All men are brothers (并查集 + 数学)/" itemprop="url">2019 牛客多校第九场 E All men are brothers (并查集 | 数学)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T19:48:34+08:00">
                2019-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数学/" itemprop="url" rel="index">
                    <span itemprop="name">数学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190815193932686.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190815193932686.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)<br>每4个 互相不能是朋友<br>考虑并查集维护<br>我们正着数 有点难 正好 我们朋友关系 是一个一个加进去的 这样就可以 每次减去我们加入这2个集合产生的冲突 + 剩下集合贡献出的2个<br>如果每次在数就超时了 而且 我们组合数 减去的 是 所有大于2的集合 贡献2个元素的量 所以开一个变量 存下 加的时候 把这2个要加入集合去掉 合并完并查集<br>把题面合并 就o1 处理组合数<br>题解搞得平方没有看懂 以上好理解点感觉</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e5 + 10;
const int mod = 1;
#define int long long

int pre[maxn], siz[maxn];
int c[maxn][5];

void init() {
    for(int i = 1; i &lt; maxn; i ++) pre[i] = i, siz[i] = 1;
    c[1][0] = c[1][1] = 1;
    for(int i = 2; i &lt; maxn; i ++){
        c[i][0] = 1;
        for(int j = 1; j &lt;= 4; j ++){
            c[i][j] = c[i-1][j] + c[i-1][j-1];
        }
    }
}

int finds(int x) {
    return x == pre[x] ? x : pre[x] = finds(pre[x]);
}

void unions(int x, int y) {
    x = finds(x), y = finds(y);
    pre[x] = y,siz[y] += siz[x];
}

signed main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    init();
    int ans = c[n][4];
    cout &lt;&lt; ans &lt;&lt; endl;
    int ps = 0;
    for(int i = 1, a, b; i &lt;= m; i ++) {
        cin &gt;&gt; a &gt;&gt; b;
        if(finds(a) == finds(b)) {
            cout &lt;&lt; ans &lt;&lt; endl;
        } else {
            int t1 = 0;
            if(siz[finds(a)] &gt;= 2) t1 = c[siz[finds(a)]][2];
            int t2 = 0;
            if(siz[finds(b)] &gt;= 2) t2 = c[siz[finds(b)]][2];

            int ss = siz[finds(a)] + siz[finds(b)];
            int ks = siz[finds(a)] * siz[finds(b)];
            int ts = ps + t1 + t2;
        //    cout &lt;&lt; &quot;    &quot; &lt;&lt; ts &lt;&lt; endl;
            int tmp = ks * (c[n - ss][2] + ts); 
        //    cout &lt;&lt; tmp &lt;&lt; endl;
            ans -= tmp;
            cout &lt;&lt; ans &lt;&lt; endl;
            ps = ps - c[ss][2] + t1 + t2;
            unions(a, b);
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/15/2019 牛客多校第九场 D  Knapsack (折半搜索)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/15/2019 牛客多校第九场 D  Knapsack (折半搜索)/" itemprop="url">2019 牛客多校第九场 D  Knapsack (折半搜索)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-15T13:53:23+08:00">
                2019-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/搜索/" itemprop="url" rel="index">
                    <span itemprop="name">搜索</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="D-Knapsack-Cryptosystem-折半搜索"><a href="#D-Knapsack-Cryptosystem-折半搜索" class="headerlink" title="D Knapsack Cryptosystem (折半搜索)"></a>D Knapsack Cryptosystem (折半搜索)</h4><p>给了36 个数 给了 s 问 能不能凑出s<br>我们折半分开搜索 复杂度下去 就好 二进制啊二进制 打印反了可还行<br>唉 打印二进制 打印反了 wa了</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int maxn = 3e5 + 10;

int n, m, sum, ky, sy;
int a[40];

struct node{
    int vis;
    int val;
}w[maxn];
int cnt;
string str, sss;

bool cmp(const node &amp;a, const node &amp;b) {
    return a.val &lt; b.val;
}

void dfs(int u, int s, int vis) {
    if(s &gt; sum) return ;
    if(u == ky) {
        w[++cnt] = node{vis,s};
        return ;
    }
    if(s + a[u] &lt;= sum) dfs(u + 1, s + a[u], vis | (1 &lt;&lt; u));
    dfs(u + 1, s, vis);
}

void dfs2(int u, int s, int vis) {
    if(s &gt; sum) return;
    if(u == n) {
        int l = 1, r = cnt;
        int sl = sum - s;
        while(l &lt; r) {
            int mid = l + r + 1 &gt;&gt; 1;
            if(w[mid].val &lt;= sl) l = mid;
            else r = mid - 1;
        }
        if(w[l].val == sl) {
           for(int i = 0; i &lt; sy ; i++) {
               if(w[l].vis &gt;&gt; i &amp; 1) cout &lt;&lt; &quot;1&quot;;
               else cout &lt;&lt; 0;
           }
           for(int i = sy; i &lt; n; i ++) {
               if(vis &gt;&gt; (i - sy) &amp; 1) cout &lt;&lt; 1;
               else cout &lt;&lt; 0;
           }
           exit(0);
        }
        return ;
    }
    if(s + a[u] &lt;= sum) dfs2(u + 1, s + a[u], vis | (1 &lt;&lt; (u - sy)));
    dfs2(u + 1, s, vis);
}

signed main() {
    scanf(&quot;%lld %lld&quot;, &amp;n, &amp;sum);
    for(int i = 0; i &lt; n; i ++) scanf(&quot;%lld&quot;, a + i);
    ky = n/2;
    sy = n/2;
    dfs(0, 0, 0);
    sort(w + 1, w + cnt + 1, cmp);
    dfs2(ky, 0, 0);
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/14/2019HDU多校第四场 AND Minimum Spanning Tree HDU - 6614/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/14/2019HDU多校第四场 AND Minimum Spanning Tree HDU - 6614/" itemprop="url">2019HDU多校第四场 AND Minimum Spanning Tree HDU - 6614</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-14T17:25:12+08:00">
                2019-08-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/贪心/" itemprop="url" rel="index">
                    <span itemprop="name">贪心</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一个思路题 画了好多 才看出来 有点菜 orz</p>
<h3 id="AND-Minimum-Spanning-Tree"><a href="#AND-Minimum-Spanning-Tree" class="headerlink" title="AND Minimum Spanning Tree"></a>AND Minimum Spanning Tree</h3><h5 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h5><p>You are given a complete graph with N vertices, numbered from 1 to N.<br>The weight of the edge between vertex x and vertex y (1&lt;=x, y&lt;=N, x!=y) is<br>simply the bitwise AND of x and y. Now you are to find minimum spanning tree<br>of this graph.<br>给了你1 到 n 边权是 2点 &amp; 的值<br>很快知道 只有 1 和 0 但是 一开始没有思考找最小 只是构造出来 wa了一发 然后脑子开始不转了 花了点时间 想到从低开始 遇到第一个二进制 0 与之前<br>的 100… 数据 看看能不能对其<br>如果没有0不然就向上找 + 1… 能不能再n以下 就过了</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 2e6 + 5;

int main() {
    int t, n;
    scanf(&quot;%d&quot;, &amp;t);
    while(t -- ) {
        scanf(&quot;%d&quot;, &amp;n);

        int ejws = 0;
        int m = n;
        while(m) {
            ejws ++;
            m/=2;
        } 

        int q1s = 0;
        q1s = (1 &lt;&lt; ejws) - 1;

        int ans = 0;

        if(n == q1s) ans = 1;
        printf(&quot;%d\n&quot;, ans);

        for(int i = 2; i &lt;= n; i ++) {
            int ejws = 0;
            int m = i;
            int f = 0;
            while(m) {
                if(m % 2 == 0) {
                    printf(&quot;%d&quot;, 1 &lt;&lt; ejws);
                    f = 1;
                    break;
                }
                m /= 2;
                ejws ++;
            }
            if(!f) {
                ;if(i + 1 &lt;= n) printf(&quot;%d&quot;, i + 1); 
                else printf(&quot;%d&quot;, 1); 
            }
            if(i == n) puts(&quot;&quot;);
            else printf(&quot; &quot;);
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/12/高级树状数组——区间修改区间查询、二维树状数组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/高级树状数组——区间修改区间查询、二维树状数组/" itemprop="url">高级树状数组——区间修改区间查询、二维树状数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-12T20:15:18+08:00">
                2019-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/树型结构/" itemprop="url" rel="index">
                    <span itemprop="name">树型结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="“高级”数据结构——树状数组！"><a href="#“高级”数据结构——树状数组！" class="headerlink" title="“高级”数据结构——树状数组！"></a>“高级”数据结构——树状数组！</h1><p>※本文一切代码未经编译，不保证正确性，如发现问题，欢迎指正！</p>
<ol>
<li>单点修改 + 区间查询<br>最简单的树状数组就是这样的：</li>
</ol>
<pre><code>void add(int p, int x){ //给位置p增加x
    while(p &lt;= n) sum[p] += x, p += p &amp; -p;
}
int ask(int p){ //求位置p的前缀和
    int res = 0;
    while(p) res += sum[p], p -= p &amp; -p;
    return res;
}
int range_ask(int l, int r){ //区间求和
    return ask(r) - ask(l - 1);
}</code></pre><ol start="2">
<li>区间修改 + 单点查询<br>通过“差分”（就是记录数组中每个元素与前一个元素的差），可以把这个问题转化为问题1。</li>
</ol>
<p>查询<br>设原数组为a[i], 设数组d[i]=a[i]−a <a href="a%5B0%5D=0"> i−1 </a> ，则<br>a[i]=∑ij=1d[j]，可以通过求d[i]的前缀和查询。</p>
<p>修改<br>当给区间[l,r]加上x的时候，a[l] 与前一个元素 a[l−1] 的差增加了x，a[r+1] 与 a[r]<br>的差减少了x。根据d[i]数组的定义，只需给d[l] 加上 x, 给d[r+1] 减去 x 即可。</p>
<pre><code>void add(int p, int x){ //这个函数用来在树状数组中直接修改
    while(p &lt;= n) sum[p] += x, p += p &amp; -p;
}
void range_add(int l, int r, int x){ //给区间[l, r]加上x
    add(l, x), add(r + 1, -x);
}
int ask(int p){ //单点查询
    int res = 0;
    while(p) res += sum[p], p -= p &amp; -p;
    return res;
}</code></pre><ol start="3">
<li>区间修改 + 区间查询<br>这是最常用的部分，也是用线段树写着最麻烦的部分——但是现在我们有了树状数组！</li>
</ol>
<p>怎么求呢？我们基于问题2的“差分”思路，考虑一下如何在问题2构建的树状数组中求前缀和：</p>
<p>位置p的前缀和 =<br>∑i=1pa[i]=∑i=1p∑j=1id[j]</p>
<p>在等式最右侧的式子∑pi=1∑ij=1d[j]中，d[1] 被用了p次，d[2]被用了p−1次……那么我们可以写出：</p>
<p>位置p的前缀和 =<br>∑i=1p∑j=1id[j]=∑i=1pd[i]∗(p−i+1)=(p+1)∗∑i=1pd[i]−∑i=1pd[i]∗i</p>
<p>那么我们可以维护两个数组的前缀和：<br>一个数组是 sum1[i]=d[i]，<br>另一个数组是 sum2[i]=d[i]∗i。</p>
<p>查询<br>位置p的前缀和即： (p + 1) * sum1数组中p的前缀和 - sum2数组中p的前缀和。</p>
<p>区间[l, r]的和即：位置r的前缀和 - 位置l的前缀和。</p>
<p>修改<br>对于sum1数组的修改同问题2中对d数组的修改。</p>
<p>对于sum2数组的修改也类似，我们给 sum2[l] 加上 l * x，给 sum2[r + 1] 减去 (r + 1) * x。</p>
<pre><code>void add(ll p, ll x){
    for(int i = p; i &lt;= n; i += i &amp; -i)
        sum1[i] += x, sum2[i] += x * p;
}
void range_add(ll l, ll r, ll x){
    add(l, x), add(r + 1, -x);
}
ll ask(ll p){
    ll res = 0;
    for(int i = p; i; i -= i &amp; -i)
        res += (p + 1) * sum1[i] - sum2[i];
    return res;
}
ll range_ask(ll l, ll r){
    return ask(r) - ask(l - 1);
}</code></pre><p>用这个做区间修改区间求和的题，无论是时间上还是空间上都比带lazy标记的线段树要优。</p>
<ol start="4">
<li>二维树状数组<br>我们已经学会了对于序列的常用操作，那么我们不由得想到（谁会想到啊喂）……能不能把类似的操作应用到矩阵上呢？这时候我们就要写二维树状数组了！</li>
</ol>
<p>在一维树状数组中，tree[x]（树状数组中的那个“数组”）记录的是右端点为x、长度为lowbit(x)的区间的区间和。<br>那么在二维树状数组中，可以类似地定义tree[x][y]记录的是右下角为(x, y)，高为lowbit(x), 宽为 lowbit(y)的区间的区间和。</p>
<p>单点修改 + 区间查询</p>
<pre><code>void add(int x, int y, int z){ //将点(x, y)加上z
    int memo_y = y;
    while(x &lt;= n){
        y = memo_y;
        while(y &lt;= n)
            tree[x][y] += z, y += y &amp; -y;
        x += x &amp; -x;
    }
}
void ask(int x, int y){//求左上角为(1,1)右下角为(x,y) 的矩阵和
    int res = 0, memo_y = y;
    while(x){
        y = memo_y;
        while(y)
            res += tree[x][y], y -= y &amp; -y;
        x -= x &amp; -x;
    }
}</code></pre><p>区间修改 + 单点查询<br>我们对于一维数组进行差分，是为了使差分数组前缀和等于原数组对应位置的元素。</p>
<p>那么如何对二维数组进行差分呢？可以针对二维前缀和的求法来设计方案。</p>
<p>二维前缀和：<br>sum[i][j]=sum[i−1][j]+sum[i][j−1]−sum[i−1][j−1]+a[i][j]</p>
<p>那么我们可以令差分数组d[i][j] 表示 a[i][j] 与 a[i−1][j]+a[i][j−1]−a[i−1][j−1] 的差。</p>
<p>例如下面这个矩阵</p>
<p>1 4 8<br>6 7 2<br>3 9 5<br>对应的差分数组就是</p>
<p>1 3 4<br>5 -2 -9<br>-3 5 1<br>当我们想要将一个矩阵加上x时，怎么做呢？<br>下面是给最中间的3*3矩阵加上x时，差分数组的变化：</p>
<p>0 0 0 0 0<br>0 +x 0 0 -x<br>0 0 0 0 0<br>0 0 0 0 0<br>0 -x 0 0 +x<br>这样给修改差分，造成的效果就是：</p>
<p>0 0 0 0 0<br>0 x x x 0<br>0 x x x 0<br>0 x x x 0<br>0 0 0 0 0<br>那么我们开始写代码吧！</p>
<pre><code>void add(int x, int y, int z){ 
    int memo_y = y;
    while(x &lt;= n){
        y = memo_y;
        while(y &lt;= n)
            tree[x][y] += z, y += y &amp; -y;
        x += x &amp; -x;
    }
}
void range_add(int xa, int ya, int xb, int yb, int z){
    add(xa, ya, z);
    add(xa, yb + 1, -z);
    add(xb + 1, ya, -z);
    add(xb + 1, yb + 1, z);
}
void ask(int x, int y){
    int res = 0, memo_y = y;
    while(x){
        y = memo_y;
        while(y)
            res += tree[x][y], y -= y &amp; -y;
        x -= x &amp; -x;
    }
}</code></pre><p>区间修改 + 区间查询<br>类比之前一维数组的区间修改区间查询，下面这个式子表示的是点(x, y)的二维前缀和：</p>
<p>∑i=1x∑j=1y∑k=1i∑h=1jd[h][k]<br>(d[h][k]为点(h, k)对应的“二维差分”(同上题))</p>
<p>这个式子炒鸡复杂( O(n4) 复杂度！)，但利用树状数组，我们可以把它优化到 O(log2n)！</p>
<p>首先，类比一维数组，统计一下每个d[h][k]出现过多少次。d[1][1]出现了x∗y次，d[1][2]出现了x∗(y−1)次……d[h][k] 出现了<br>(x−h+1)∗(y−k+1) 次。</p>
<p>那么这个式子就可以写成：</p>
<p>∑i=1x∑j=1yd[i][j]∗(x+1−i)∗(y+1−j)</p>
<p>把这个式子展开，就得到：</p>
<p>(x+1)∗(y+1)∗∑i=1x∑j=1yd[i][j]</p>
<p>−(y+1)∗∑i=1x∑j=1yd[i][j]∗i</p>
<p>−(x+1)∗∑i=1x∑j=1yd[i][j]∗j</p>
<p>+∑i=1x∑j=1yd[i][j]∗i∗j</p>
<p>那么我们要开四个树状数组，分别维护：</p>
<p>d[i][j],d[i][j]∗i,d[i][j]∗j,d[i][j]∗i∗j</p>
<p>这样就完成了！</p>
<pre><code>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;iostream&gt;
using namespace std;
typedef long long ll;
ll read(){
    char c; bool op = 0;
    while((c = getchar()) &lt; &apos;0&apos; || c &gt; &apos;9&apos;)
        if(c == &apos;-&apos;) op = 1;
    ll res = c - &apos;0&apos;;
    while((c = getchar()) &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;)
        res = res * 10 + c - &apos;0&apos;;
    return op ? -res : res;
}
const int N = 205;
ll n, m, Q;
ll t1[N][N], t2[N][N], t3[N][N], t4[N][N];
void add(ll x, ll y, ll z){
    for(int X = x; X &lt;= n; X += X &amp; -X)
        for(int Y = y; Y &lt;= m; Y += Y &amp; -Y){
            t1[X][Y] += z;
            t2[X][Y] += z * x;
            t3[X][Y] += z * y;
            t4[X][Y] += z * x * y;
        }
}
void range_add(ll xa, ll ya, ll xb, ll yb, ll z){ //(xa, ya) 到 (xb, yb) 的矩形
    add(xa, ya, z);
    add(xa, yb + 1, -z);
    add(xb + 1, ya, -z);
    add(xb + 1, yb + 1, z);
}
ll ask(ll x, ll y){
    ll res = 0;
    for(int i = x; i; i -= i &amp; -i)
        for(int j = y; j; j -= j &amp; -j)
            res += (x + 1) * (y + 1) * t1[i][j]
                - (y + 1) * t2[i][j]
                - (x + 1) * t3[i][j]
                + t4[i][j];
    return res;
}
ll range_ask(ll xa, ll ya, ll xb, ll yb){
    return ask(xb, yb) - ask(xb, ya - 1) - ask(xa - 1, yb) + ask(xa - 1, ya - 1);
}
int main(){
    n = read(), m = read(), Q = read();
    for(int i = 1; i &lt;= n; i++){
        for(int j = 1; j &lt;= m; j++){
            ll z = read();
            range_add(i, j, i, j, z);
        }
    }
    while(Q--){
        ll ya = read(), xa = read(), yb = read(), xb = read(), z = read(), a = read();
        if(range_ask(xa, ya, xb, yb) &lt; z * (xb - xa + 1) * (yb - ya + 1))
            range_add(xa, ya, xb, yb, a);
    }
    for(int i = 1; i &lt;= n; i++){
        for(int j = 1; j &lt;= m; j++)
            printf(&quot;%lld &quot;, range_ask(i, j, i, j));
        putchar(&apos;\n&apos;);
    }
    return 0;
}</code></pre><p>本文作者：胡小兔<br>博客地址： <a href="http://rabbithu.cnblogs.com" target="_blank" rel="noopener"> http://rabbithu.cnblogs.com </a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/12/KMP + Z函数 基本概念 入门水题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/12/KMP + Z函数 基本概念 入门水题/" itemprop="url">KMP + Z函数 基本概念 入门水题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-12T13:31:14+08:00">
                2019-08-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/字符串/" itemprop="url" rel="index">
                    <span itemprop="name">字符串</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>KMP<br>Z函数 | 拓展KMP</p>
<h2 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h2><p>字符串 abcabcd 的前缀函数为 0 0 0 1 2 3 0 ，<br>字符串 aabaaab的前缀函数为 0 1 0 1 2 2 3 .<br>以第 i 个 作为 结尾 和前缀匹配 最多往前匹多长</p>
<h2 id="Z函数"><a href="#Z函数" class="headerlink" title="Z函数"></a>Z函数</h2><p><img src="https://img-blog.csdnimg.cn/2019081211182145.png" alt="在这里插入图片描述"><br>已第i个 作为开始 和前缀匹配 往后面最长匹配多少</p>
<h5 id="洛谷板子题-kmp-找位置"><a href="#洛谷板子题-kmp-找位置" class="headerlink" title="洛谷板子题 kmp 找位置"></a>洛谷板子题 kmp 找位置</h5><pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn = 1e6 + 10;

int nxt[maxn];
char s1[maxn], s2[maxn];

void get_nxt(int n, char *s){
    memset(nxt, 0, (n + 5) * sizeof(int));
    nxt[0] = -1;
    int i = 0, j = -1;
    while(i &lt; n){
        if(j == -1 || s[j] == s[i]){
            i++, j++;
            nxt[i] = j;
        }
        else j = nxt[j];
    }
}

void kmp(int n, int m) {
    int t1 = 0, t2 = 0;
    while(t1 &lt; n) {
        if(t2 == -1 || s1[t1] == s2[t2]) t1 ++, t2 ++;
        else t2 = nxt[t2];
        if(t2 == m) {
            printf(&quot;%d\n&quot;, t1 - m + 1);
            t2 = nxt[t2]; // t2 = 0 不重复用的输出
        }
    }
}

int main() {
    scanf(&quot;%s %s&quot;, s1, s2);
    int n, m;
    n = strlen(s1), m = strlen(s2);
    get_nxt(m, s2);
    kmp(n, m);
    for(int i = 1; i &lt;= m; i ++) printf(&quot;%d &quot;, nxt[i]);
    puts(&quot;&quot;);
    return 0;
}</code></pre><h5 id="kmp-找循环节"><a href="#kmp-找循环节" class="headerlink" title="kmp 找循环节"></a>kmp 找循环节</h5><p>POJ 2406</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn = 1e6 + 10;

int nxt[maxn];
char s[maxn];
int n;

void get_nxt(){
    memset(nxt, 0, (n + 5) * sizeof(int));
    nxt[0] = -1;
    int i = 0, j = -1;
    while(i &lt; n){
        if(j == -1 || s[j] == s[i]){
            i++;
            j++;
            nxt[i] = j;
        }
        else
            j = nxt[j];
    }
}

int main() {
    while(scanf(&quot;%s&quot;, s) &amp;&amp; s[0] != &apos;.&apos;) {
        n = strlen(s);
        get_nxt();
        if(n % (n - nxt[n]) != 0) puts(&quot;1&quot;);
        else printf(&quot;%d\n&quot;, n / (n - nxt[n]));
    }
    return 0;
}</code></pre><h5 id="kmp-找所有循环节周期"><a href="#kmp-找所有循环节周期" class="headerlink" title="kmp 找所有循环节周期"></a>kmp 找所有循环节周期</h5><p>POJ 1961</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
using namespace std;
const int maxn = 1e6 + 10;

int nxt[maxn];
char s[maxn];
int n;

void get_nxt(){
    memset(nxt, 0, (n + 5) * sizeof(int));
    nxt[0] = -1;
    int i = 0, j = -1;
    while(i &lt; n){
        if(j == -1 || s[j] == s[i]){
            i++, j++;
            nxt[i] = j;
        }
        else j = nxt[j];
    }
}

int main() {
    int cas = 1;
    while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n) {

        scanf(&quot;%s&quot;, s);
        get_nxt();
        printf(&quot;Test case# %d\n&quot;, cas ++);
        for(int i = 1; i &lt;= n; i ++) {
            int k = i - nxt[i];
            if(i % k == 0 &amp;&amp; i != k) printf(&quot;%d %d\n&quot;, i, i/k);
        }    puts(&quot;&quot;);
    }
    return 0;
}</code></pre><h2 id="Z-函数"><a href="#Z-函数" class="headerlink" title="Z 函数"></a>Z 函数</h2><h4 id="Codeforces-126B-Password"><a href="#Codeforces-126B-Password" class="headerlink" title="Codeforces 126B Password"></a>Codeforces 126B Password</h4><p>你要在一个串中找到“密码”，密码定义为既是前缀，也是后缀，同时在串中间出现过的子串。<br>i + z[i] == n i位开始能匹配到的 后缀 同时 ma &gt;= n - i 之前 出现过不小它 的串</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e6 + 10;

int z[maxn];
string s;
int n;

void get_z() {
    int l=0,r=0;
    for (int i=1; i&lt;n; i++) {
        if (i&gt;r) {
            l=i,r=i;
            while (r&lt;n &amp;&amp; s[r-l]==s[r]) r++;
            z[i]=r-l,r--;
        } else {
            int k=i-l;
            if (z[k]&lt;r-i+1) z[i]=z[k];
            else {
                l=i;
                while (r&lt;n &amp;&amp; s[r-l]==s[r]) r++;
                z[i]=r-l,r--;
            }
        }
    }
}

int main() {
    cin &gt;&gt; s;
    n = s.size();
    get_z();
    int pos = -1, ma = 0;
    for(int i = 1; i &lt; n; i ++) {
        if(z[i] + i == n &amp;&amp; ma &gt;= n - i) {
            pos = i;
            break;
        }
        ma = max(ma, z[i]);
    }

//    for(int i = 1; i &lt; n; i ++) {
//        cout &lt;&lt; z[i] &lt;&lt; &quot; &quot;;
//    }
//    cout &lt;&lt; endl;
//    cout &lt;&lt; pos &lt;&lt; &quot; &quot; &lt;&lt; ma &lt;&lt; endl;
    if(pos == -1) cout &lt;&lt; &quot;Just a legend&quot;;
    else for(int i = 0; i &lt; n - pos; i ++) cout &lt;&lt; s[i];
    cout &lt;&lt; endl;
    return 0;
}</code></pre><h4 id="Codeforces-535D-Tavas-and-Malekas"><a href="#Codeforces-535D-Tavas-and-Malekas" class="headerlink" title="Codeforces 535D Tavas and Malekas"></a>Codeforces 535D Tavas and Malekas</h4><p>每个位置 如果不与之前重合 直接放就行<br>重合 判断 能不能合法放进去<br>用差分标记 最后0得位置就是26 ^ 多少</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e6 + 10;
const int mod = 1e9 + 7;

int z[maxn], pos[maxn], a[maxn];
string s;
int n, m, l;

void get_z(int n) {
    int l=0,r=0;
    for (int i=1; i&lt;n; i++) {
        if (i&gt;r) {
            l=i,r=i;
            while (r&lt;n &amp;&amp; s[r-l]==s[r]) r++;
            z[i]=r-l,r--;
        } else {
            int k=i-l;
            if (z[k]&lt;r-i+1) z[i]=z[k];
            else {
                l=i;
                while (r&lt;n &amp;&amp; s[r-l]==s[r]) r++;
                z[i]=r-l,r--;
            }
        }
    }
}

bool chk(int i, int j) {
    if(i + l &lt;= j) return 1;
    return z[j - i] &gt;= i + l - j;
}

int ksm(int a, int b) {
    int res = 1;
    for(; b; b &gt;&gt;= 1) {
        if(b &amp; 1) res = 1ll * res * a % mod;
        a = 1ll * a * a % mod;
    }
    return res;
}

signed main() {
    cin &gt;&gt; n &gt;&gt; m;
    cin &gt;&gt; s;
    l = s.size();
    get_z(l);
    for(int i = 1; i &lt;= m; i ++) cin &gt;&gt; pos[i], pos[i]--;

    for(int i = 1; i &lt; m; i ++) {
        if(chk(pos[i], pos[i + 1])) {
            a[pos[i]] ++, a[pos[i] + l] --;
        } else {
            cout &lt;&lt; 0 &lt;&lt; endl;
            return 0;
        }
    }
    if(m) a[pos[m]] ++, a[pos[m] + l] --;
    for(int i = 1; i &lt; n; i ++) 
        a[i] += a[i - 1];

    int tot = 0;
    for(int i = 0; i &lt; n; i ++) if(!a[i]) tot ++;
    cout &lt;&lt; ksm(26, tot) &lt;&lt; endl;
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/11/2019HDU多校第五场 HDU 6629. string matching (扩展KMP应用+Z函数)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/11/2019HDU多校第五场 HDU 6629. string matching (扩展KMP应用+Z函数)/" itemprop="url">2019HDU多校第五场 HDU 6629. string matching (扩展KMP应用//Z函数)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-11T09:34:33+08:00">
                2019-08-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/字符串/" itemprop="url" rel="index">
                    <span itemprop="name">字符串</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这道题坎扩展KMPnxt数组规律看了一会 也意识到 自己对展开kmp各种应用还是不够熟练<br>题意：给出一个用于求在一个给定字符串中求每一位的后缀（含自己）与这个字符串的最长相同的长度的算法，问你对于给出的字符串执行这个算法，会进行多少次这个算法中那个字符与字符的比较过程<br>扩展KMP里求NXT数组的代码跑一遍，我们就可以得到每一位的最长字串的长度，然后因为问的是比较次数，那么只要这一位的位置加上它的子串长没用超过字符串的最后一位，就说明它会在统计时还要加上一次比较次数，也就是在统计它的字串长度时它和下一位比较并且匹配失败的那一次。<br>nxt[i]表示T[i,len-1]与T[0,len-1]的最长公共前缀。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
#define N 1000010
#define int long long
using namespace std;

int q, nxt[N], extend[N];
string s, t;

void getnxt() {
    nxt[0] = t.size(); //nxt[0]一定是T的长度
    int now = 0;
    while(t[now] == t[1 + now] &amp;&amp; now + 1 &lt; (int)t.size())
        now++;//这就是从1开始暴力
    nxt[1] = now;
    int p0 = 1;
    for(int i = 2; i &lt; (int)t.size(); i++) {
        if(i + nxt[i - p0] &lt; nxt[p0] + p0)
            nxt[i] = nxt[i - p0]; //第一种情况
        else {
            //第二种情况
            int now = nxt[p0] + p0 - i;
            now = max(now, 0ll); //这里是为了防止i&gt;p的情况
            while(t[now] == t[i + now] &amp;&amp; i + now &lt; (int)t.size())
                now++;//暴力
            nxt[i] = now;
            p0 = i; //更新p0
        }
    }
}
signed main() {
    int cas;
    ios::sync_with_stdio(false);cin.tie(0);
    cin &gt;&gt;cas;
    while(cas--) {
        cin &gt;&gt; t;
        memset(nxt, 0, sizeof(nxt));
        getnxt();
        int len = t.size();
        int ans =0;
        for(int i = 1; i &lt; len; i++) {
            //  printf(&quot;%d &quot;, nxt[i]); //输出nxt
            //    ans ++;
            if(nxt[i]) {
                ans += nxt[i];
            }
            if(nxt[i]!=len-i) ans ++; // nxt[i] + i &lt; len 
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    //    puts(&quot;&quot;);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/10/2019HDU杭电多校第六场 HDU 6638 Snowy Smile (二维最大矩阵和+线段树)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/10/2019HDU杭电多校第六场 HDU 6638 Snowy Smile (二维最大矩阵和+线段树)/" itemprop="url">2019HDU杭电多校第六场 HDU 6638 Snowy Smile (二维最大矩阵和|线段树)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-10T20:41:36+08:00">
                2019-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190810202933875.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190810202933875.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190810202937290.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190810202937290.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)<br>一个巨大的矩阵 1e9 之间 稀疏矩阵</p>
<p>现在给了一些点权值 让你找一个矩形 圈主的权值全拿了 问最多可以拿多少<br>hdu MAXsum 有一维的题 不带修改<br>如果带修改 也只是 线段树维护 最大子段和的题<br><a href="https://blog.csdn.net/qq_40831340/article/details/90726050" target="_blank" rel="noopener"> https://blog.csdn.net/qq_40831340/article/details/90726050
</a></p>
<p>这次 变成二维的了<br>我们选择离散化数据 枚举上下边界 用子段和最大的方式来寻求可能存在的最大矩阵<br>选区 x 轴 离散化 枚举y高度上下界 再这一过程中 maxsum 直接可以找到每轮加入的点 可能产生的最大值<br>特地的注意 再跑上界的过程中 我们就已经可以算 枚举底部 到现在枚举上界的里面的最大值了 我第一次整成 n^3 lgn了</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
using namespace std;
const int maxn = 4e3 + 5;
const int INF = 0x3f3f3f3f;
typedef pair&lt;int, int&gt; P;
typedef long long ll;
int cas, n;
struct point{
    int x, y, val;
    bool operator &lt; (const point &amp;a) const {
        return y &lt; a.y;
    }
}a[maxn];
vector&lt;int&gt; p[maxn];

int bx[maxn], by[maxn];

struct node{
    ll sum, lmax, rmax, lrmax;
}tree[maxn &lt;&lt; 2];

void push_up(int rt) {
    tree[rt].sum = tree[rt &lt;&lt; 1].sum + tree[rt &lt;&lt; 1 | 1].sum;
    tree[rt].lmax = max(tree[rt &lt;&lt; 1].lmax, \
                        tree[rt &lt;&lt; 1].sum + tree[rt &lt;&lt; 1 | 1].lmax);
    tree[rt].rmax = max(tree[rt &lt;&lt; 1 | 1].rmax, \
                        tree[rt &lt;&lt; 1 | 1].sum + tree[rt &lt;&lt; 1].rmax);
    tree[rt].lrmax = max( max(tree[rt &lt;&lt; 1].lrmax, tree[rt &lt;&lt; 1 | 1].lrmax), \
                         tree[rt &lt;&lt; 1].rmax + tree[rt &lt;&lt; 1 | 1].lmax);
}

void updata(int L, int l, int r, int rt, int c) {
    if(l == r) {
        tree[rt].sum += 1ll * c;
        tree[rt].lrmax = tree[rt].lmax = tree[rt].rmax = tree[rt].sum;
        return ;
    }
    int mid = l + r &gt;&gt; 1;
    if(L &lt;= mid) updata(L, l, mid, rt &lt;&lt; 1, c);
    else updata(L, mid + 1, r, rt &lt;&lt; 1 | 1, c);
    push_up(rt);
}

int main() {
    scanf(&quot;%d&quot;, &amp;cas);
    while(cas --) {
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i ++) {
            scanf(&quot;%d %d %d&quot;, &amp;a[i].x, &amp;a[i].y, &amp;a[i].val);
            bx[i] = a[i].x, by[i] = a[i].y;
        }
        sort(bx + 1, bx + 1 + n);
        int xlen = unique(bx + 1, bx + 1 + n) - bx - 1;
        sort(by + 1, by + 1 + n);
        int ylen = unique(by + 1, by + 1 + n) - by - 1;

        for(int i = 1; i &lt;= n; i ++) {
            a[i].x = lower_bound(bx + 1, bx + xlen + 1, a[i].x) - bx;
            a[i].y = lower_bound(by + 1, by + ylen + 1, a[i].y) - by;
        }
        sort(a + 1, a + 1 + n);
        ll ans = 0;
        for(int i = 1; i &lt;= ylen; i ++) {
            memset(tree, 0, (xlen * 4 + 5) * sizeof(node));
            int pos = 1;
            while(a[pos].y &lt; i &amp;&amp; pos &lt;= n) pos ++;
            for(int j = i; j &lt;= ylen; j ++) {
                while(a[pos].y &lt;= j &amp;&amp; pos &lt;= n) {
                    updata(a[pos].x, 1, xlen, 1, a[pos].val);
                    pos ++;
                }
                ans = max(ans, tree[1].lrmax);
            }
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/10/2019牛客暑期多校(第七场) 写题记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/10/2019牛客暑期多校(第七场) 写题记录/" itemprop="url">2019牛客暑期多校(第七场) 写题记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-10T17:13:57+08:00">
                2019-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/题集/" itemprop="url" rel="index">
                    <span itemprop="name">题集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="J-A-B-problem"><a href="#J-A-B-problem" class="headerlink" title="J A+B problem"></a>J A+B problem</h4><p>签到 翻转之后相加 再翻转</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

int main() {
    int t;
    cin &gt;&gt; t;
    while(t--) {
        string a, b;
        cin &gt;&gt; a &gt;&gt; b;
        ll x = 0, y = 0;
        reverse(a.begin(), a.end());
        reverse(b.begin(), b.end());
        ll z = 0;
        for(int i = 0; i &lt; a.size(); i++) {
            x = x * 10 + a[i] - &apos;0&apos;;
        }
        for(int i = 0; i &lt; b.size(); i++) {
            y = y * 10 + b[i] - &apos;0&apos;;
        }
        z = x + y;
        if(!z)
            cout &lt;&lt; z &lt;&lt; endl;
        else {
            while(z % 10 == 0)
                z /= 10;
            while(z) {
                cout &lt;&lt; z % 10;
                z /= 10;
            }
            cout &lt;&lt; endl;
        }
    }
    return 0;
}</code></pre><h4 id="A-String"><a href="#A-String" class="headerlink" title="A String"></a>A String</h4><p>分割 01 尽快让每段最长最小<br>最小表示 应该更快一些 不过 只有01 和长度才200</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;

string s;

bool ok(int l, int r) {
    if(r == l)
        return 1;
    string ss = &quot;&quot;;
    for(int i = l; i &lt;= r; i++)
        ss += s[i];
    string str = ss;
    int x = r - l;
    while(x--) {
        str += str[0];
        str.erase(0, 1);
        if(str &lt; ss)
            return 0;
    }
    return 1;
}

int main() {
    int t;
    cin &gt;&gt; t;
    while(t--) {
        cin &gt;&gt; s;
        int lr = s.size();
        int l = 0, r = lr - 1;
        while(1) {
            for(int i = r; i &gt;= l; i--) {
                if(ok(l, i)) {
                    for(int j = l; j &lt;= i; j++)
                        cout &lt;&lt; s[j];
                    cout &lt;&lt; &apos; &apos;;
                    l = i + 1;
                    r = lr - 1;
                    break;
                }
            }
            if(l &gt;= lr)
                break;
        }
        cout &lt;&lt; endl;
    }
    return 0;
}</code></pre><h4 id="B-Irreducible-Polynomial"><a href="#B-Irreducible-Polynomial" class="headerlink" title="B Irreducible Polynomial"></a>B Irreducible Polynomial</h4><p>基本代数定理 除了 n == 2 无解没有的拆 &gt;= 3 拆2项压力不打</p>
<pre><code>#include&lt;cstdio&gt;
int main() {
    int n,tp,a[25];
    int cas;
    scanf(&quot;%d&quot;, &amp;cas);
    while(cas --) {
        scanf(&quot;%d&quot;, &amp;n);
        for(int i=0; i&lt;=n; scanf(&quot;%d&quot;,a+i),i++);
        if(n&gt;2||n==2&amp;&amp;a[1]*a[1]&gt;=4*a[0]*a[2])
            printf(&quot;No\n&quot;);
        else
            printf(&quot;Yes\n&quot;);
    }
    return 0;
}</code></pre><h4 id="C-Governing-sand"><a href="#C-Governing-sand" class="headerlink" title="C Governing sand"></a>C Governing sand</h4><p>权值线段树<br>我们 排好序 从小到大枚举 每次吧最小的多余的删掉 大于高度也去掉<br>枚举完 找最小值</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0);
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;
const int INF = 0x3f3f3f3f;
const ll LINF = 0x3f3f3f3f3f3f3f3f;
typedef pair&lt;int, int&gt; P;

int n;
struct no {
    int h, c, p, pos;
} a[maxn];

bool cmp1(no a, no b) {
    return a.c &lt; b.c;
}

bool cmp2(no a, no b) {
    return a.h &lt; b.h;
}

struct node {
    ll num;
    ll sum;
} tree[maxn &lt;&lt; 2];

void build(int l, int r, int rt) {
    tree[rt].num = 0;
    tree[rt].sum = 0;
    if (l == r)
        return;
    int mid = l + r &gt;&gt; 1;
    build(l, mid, rt &lt;&lt; 1);
    build(mid + 1, r, rt &lt;&lt; 1 | 1);
}

void updata(int L, int val, int num, int l, int r, int rt) {
    if (l == r) {
        tree[rt].num += num;
        tree[rt].sum += 1ll * num * val;
        return;
    }
    int mid = l + r &gt;&gt; 1;
    if(L &lt;= mid)
        updata(L, val, num, l, mid, rt &lt;&lt; 1);
    else
        updata(L, val, num, mid + 1, r, rt &lt;&lt; 1 | 1);
    tree[rt].num = tree[rt &lt;&lt; 1].num + tree[(rt &lt;&lt; 1) | 1].num;
    tree[rt].sum = tree[rt &lt;&lt; 1].sum + tree[(rt &lt;&lt; 1) | 1].sum;
}

ll query(ll k, int l, int r, int rt) {
    if (k &lt;= 0)
        return 0;
    if (k &gt;= tree[rt].num)
        return tree[rt].sum;
    if (l == r) {
        return tree[rt].sum / tree[rt].num * k;
    }
    int mid = r + l &gt;&gt; 1;
    return query(k, l, mid, rt &lt;&lt; 1) + query(k - tree[rt &lt;&lt; 1].num, mid + 1, r, rt &lt;&lt; 1 | 1);
}

signed main() {
    fastio;
    while (cin &gt;&gt; n) {
        ll ans = 0;
        for (int i = 1; i &lt;= n; i++) {
            cin &gt;&gt; a[i].h &gt;&gt; a[i].c &gt;&gt; a[i].p;
            ans += (ll) a[i].c * a[i].p;
        }
        sort(a + 1, a + 1 + n, cmp1);
        for (int i = 0; i &lt; n; i++)
            a[i].pos = i;
        build(1, n, 1);
        sort(a + 1, a + 1 + n, cmp2);

        int prep = 0;
        ll tot = 0;
        ll cnt = a[1].p;
        ll res = ans - 1ll * a[1].p * a[1].c;
        for (int i = 2; i &lt;= n; i++) {
            if (i == n + 1 || a[i].h != a[i - 1].h) {
                ll tmp =  query(tot - (cnt - 1), 1, n, 1) + res;
                if (ans &gt; tmp) ans = tmp;
                cnt = a[i].p;
                while (prep &lt; i) {
                    updata(a[prep].pos, a[prep].c, a[prep].p, 1, n, 1);
                    tot += a[prep].p;
                    prep++;
                }
            } else cnt += a[i].p;

            res -= (ll)a[i].c * a[i].p;
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}</code></pre><h4 id="D-Number"><a href="#D-Number" class="headerlink" title="D Number"></a>D Number</h4><p>找个n位 p 的倍数 补0 。。。</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int maxn = 2e5 + 5;
const int INF = 0x3f3f3f3f;
const long long LINF = 0x3f3f3f3f3f3f3f3f;
typedef pair&lt;int, int&gt; P;

int main() {
    string p;
    int n;
    cin &gt;&gt; n &gt;&gt; p; 
    int lenn = n;
    int lenp = p.size();

    if(lenn == lenp ) cout &lt;&lt; p &lt;&lt; endl;
    else if(lenn &lt; lenp) cout &lt;&lt; &quot;T_T&quot; &lt;&lt; endl;
    else {
        cout &lt;&lt; p ;
        for(int i = 1; i &lt;= lenn - lenp; i ++) {
            cout &lt;&lt; 0;
        }cout &lt;&lt; endl;
    }

    return 0;
}</code></pre><h4 id="E-Find-the-median"><a href="#E-Find-the-median" class="headerlink" title="E Find the median"></a>E Find the median</h4><p>这道题<br>首先 我们把能想到线段树 其次 维护 这一片区间 + 1的次数<br>那么就是 用点代表区间<br>如果我们考虑用点 代表区间的话 首先我们对这个区间进行一个补长 右边加个一什么的<br>（5， 6） （7， 9） (9, 11) (11, 11)<br>我们 左端点不变 右端点 +1 进行离散化前存储<br>然后 离散化完 我们实际存储<br>第一 5， 6 区间 被我们 [1, 2)<br>第二 7， 9 区间 被我们 [2, 4)<br>第三 9， 11 区间 被我们 [ 3, 6)<br>第4区间 11 11 被我们 [5, 6) 代替了<br>这样 左开右闭区间 就能 一个不拉处理他们</p>
<p>如果 我们处理 5， 6 区间 我们只要 直接查 左区间 下标 （右区间 + 1）(我们离散化 + 1 就是为了能不重复的处理区间 这里要补回1)下标 -<br>1 相当于 第一个区间 1 这个点代表了 5 【2，4）这个区间 代表了7，9<br>数据差多大 都可以用这样处理的下标 不漏不重的处理</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0);
using namespace std;
typedef long long ll;
const int maxn = 4e5 + 10;
int le[maxn], rig[maxn];
int n;
int a1, a2, b1, b2, x[maxn], y[maxn], c1, c2, m1, m2;
int b[maxn &lt;&lt; 1], ls[maxn], rs[maxn];
ll sum[maxn &lt;&lt; 3], lazy[maxn &lt;&lt; 3];

void push_down(int l, int r, int root) {
    if(!lazy[root])
        return ;
    int mid = l + r &gt;&gt; 1;
    sum[root &lt;&lt; 1] += (ll)(b[mid + 1] - b[l]) * lazy[root];
    sum[root &lt;&lt; 1 | 1] += (ll)(b[r + 1] - b[mid + 1]) * lazy[root];
    lazy[root &lt;&lt; 1] += lazy[root];
    lazy[root &lt;&lt; 1 | 1] += lazy[root];
    lazy[root] = 0;
}

void updata(int L, int R, int l, int r, int rt) {
    if(L &lt;= l &amp;&amp; R &gt;= r) {
        lazy[rt] += 1;
        sum[rt] += 1ll * (b[r + 1] - b[l]);
        return ;
    }
    push_down(l, r, rt);
    int mid = l + r &gt;&gt; 1;
    if(L &lt;= mid)
        updata(L, R, l, mid, rt &lt;&lt; 1);
    if(R &gt; mid)
        updata(L, R, mid + 1, r, rt &lt;&lt; 1 | 1);
    sum[rt] = sum[rt &lt;&lt; 1] + sum[rt &lt;&lt; 1 | 1];
}

int query(int l, int r, int rt, ll k) {
    if(l == r)
        return b[l] + (k - 1) / (lazy[rt]); // sum 和 lazy 最后不一样 sum 是这一段所有的和 lazy 只是次数
    int mid = l + r &gt;&gt; 1;
    push_down(l, r, rt);
    if(sum[rt &lt;&lt; 1] &lt; k)
        return query(mid + 1, r, rt &lt;&lt; 1 | 1, k - sum[rt &lt;&lt; 1]);
    else
        return query(l, mid, rt &lt;&lt; 1, k);
}

signed main() {
    fastio;
    cin &gt;&gt; n;
    cin &gt;&gt; x[1] &gt;&gt; x[2] &gt;&gt; a1 &gt;&gt; b1 &gt;&gt; c1 &gt;&gt; m1;
    cin &gt;&gt; y[1] &gt;&gt; y[2] &gt;&gt; a2 &gt;&gt; b2 &gt;&gt; c2 &gt;&gt; m2;

    int len = 0;
    for(int i = 3; i &lt;= n; i ++) {
        x[i] = (1ll * a1 * x[i - 1] + b1 * x[i - 2] + c1) % m1;
        y[i] = (1ll * a2 * y[i - 1] + b2 * y[i - 2] + c2) % m2;
    }

    for(int i = 1; i &lt;= n; i ++) {
        ls[i] = min(x[i], y[i]) + 1;
        b[++ len] = ls[i];
        rs[i] = max(x[i], y[i]) + 1;
        b[++ len] = rs[i] + 1;
    }
    sort(b + 1, b + 1 + len);
    len = unique(b + 1, b + 1 + len) - b - 1;
    ll tot = 0;
    for(int i = 1; i &lt;= n; i ++) {
        tot += (rs[i] - ls[i] + 1);
        int ul = lower_bound(b + 1, b + 1 + len, ls[i]) - b;
        int ur = lower_bound(b + 1, b + 1 + len, rs[i] + 1) - b;
        updata(ul, ur - 1, 1, len, 1);
        cout &lt;&lt; query(1, len, 1, (tot + 1) / 2) &lt;&lt; endl;
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/08/2019HDU杭电多校第三场 HDU 6606  Distribution of books (DP+线段树)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/08/2019HDU杭电多校第三场 HDU 6606  Distribution of books (DP+线段树)/" itemprop="url">2019HDU杭电多校第三场 HDU 6606  Distribution of books (DP+线段树)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-08T11:06:39+08:00">
                2019-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DP/" itemprop="url" rel="index">
                    <span itemprop="name">DP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>题目要使得最大值最小？考虑二分答案 对于每次二分答案（假设为x），<br> 如何判定x能否满足分为k份的要求呢？考虑动态规划<br> dp[i] = max(dp[j]) + 1; (sum[i] - sum[j] &lt;= x)<br> 令dp[i]表示前i个数最多能分成几段, 则 如果直接dp，时间复杂度为n^2，显然会TLE!  
 考虑用平衡树维护或者离散化后权值线段树维护，总体复杂度n*log(n)</p>
</blockquote>
<p>考虑一个答案，然后dp[i]表示分配前i本书最多可以分给几个人，然后如果无法以i结尾就不更新dp数组<br>然后把前缀和离散化，dp[i]=max(dp[j]+1),sum[i]-sum[j]&lt;=mid ，那么就用sum[j]&gt;=sum[i]-mid，<br>二分出最小的离散化值，权值树状数组维护下标表示的sum[j]能得到的最大dp[j]。<br>然后注意由于是要前i个完全分配，所以一定要有解的情况才更新dp[i]和权值树<br>线段树优化DP orz chklonglong和 int 没有对应 然后我连样例都跑不出来</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int maxn = 2e5 + 5;
const int INF = 0x3f3f3f3f;
const long long LINF = 0x3f3f3f3f3f3f3f3f;
typedef pair&lt;int, int&gt; P;

int cas, n, k;
int a[maxn];
ll sum[maxn], b[maxn], cnt;

int tree[maxn &lt;&lt; 2];
void build(int l, int r, int rt) {
    tree[rt] = 0;
    if(l == r) return ;
    int mid = l + r &gt;&gt; 1;
    build(l, mid, rt &lt;&lt; 1);
    build(mid + 1, r, rt &lt;&lt; 1 | 1);
}

void updata(int L, int l, int r, int rt, int val) {
    if(l == r) {
        tree[rt] = max(val, tree[rt]);
        return ;
    }
    int mid = l + r &gt;&gt; 1;
    if(L &lt;= mid) updata(L, l, mid, rt &lt;&lt; 1, val);
    else updata(L, mid + 1, r, rt &lt;&lt; 1 | 1, val);
    tree[rt] = max(tree[rt &lt;&lt; 1], tree[rt &lt;&lt; 1 | 1]);
}

int query(int L, int R, int l ,int r, int rt) {
    if(L &lt;= l &amp;&amp; R &gt;= r) return tree[rt];
    int mid = l + r &gt;&gt; 1;
    int res = 0;
    if(L &lt;= mid) res = query(L, R, l, mid, rt &lt;&lt; 1);
    if(R &gt; mid) res = max(res, query(L, R, mid + 1, r, rt &lt;&lt; 1 | 1));
    return res;
}

int dp[maxn];
bool chk(long long mid) {
    build(1, cnt, 1);
    int f = 0;
    for(int i = 1; i &lt;= n; i ++) dp[i] = 0;
    for(int i = 1; i &lt;= n; i ++) {
        int pos = lower_bound(b + 1, b + 1 + cnt, b[sum[i]]-mid)-b; // sum[j] 的位置 pos - cnt
        if(b[sum[i]] &lt;= mid) dp[i] = 1; // 默认 刚开始更新不了同时单独一个符合的也是一个人的
        int x = query(pos, cnt, 1, cnt, 1);
        if(x) dp[i] = x + 1;  // 拿之前同时符合位置的 最大值 + 1
        f = max(f, dp[i]);
        updata(sum[i], 1, cnt, 1, dp[i]); // sum[i] 更新 如果sum[i] 这个位置之前有更大的不更新
    }
    return f &gt;= k;
}

int main() {
    scanf(&quot;%d&quot;, &amp;cas);
    while(cas --) {
        scanf(&quot;%d %d&quot;, &amp;n, &amp;k);
        for(int i = 1; i &lt;= n; i ++)
            scanf(&quot;%d&quot;, a + i), sum[i] = sum[i - 1] + a[i], b[i] = sum[i];
        sort(b + 1, b + 1 + n);
        cnt = unique(b + 1, b + 1 + n) - b - 1;
        for(int i = 1; i &lt;= n; i ++)
            sum[i] = lower_bound(b + 1, b + 1 + cnt, sum[i]) - b;

        ll l = -1e14-5, r = 1e14+5;
        while(l &lt; r) {
            ll mid = l + r &gt;&gt; 1;
            if(chk(mid)) r=mid;
            else l=mid+1;
        }
        cout &lt;&lt; l &lt;&lt; endl;
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/08/2019HDU杭电多校第三场 HDU 6611 K Subsequence (最小费用最大流 + dijkstra 模版(处理负边))/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/08/2019HDU杭电多校第三场 HDU 6611 K Subsequence (最小费用最大流 + dijkstra 模版(处理负边))/" itemprop="url">2019HDU杭电多校第三场 HDU 6611 K Subsequence (最小费用最大流 + dijkstra 模版(处理负边))</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-08T08:56:52+08:00">
                2019-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/图论/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>唉 自己 spfaT了<br>之后又写了份 dj的 还是T了<br>只能说自己写的好丑啊 一直写spfa 突然不适</p>
<p>以下 标程扒的 以后当模板使用了</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; pii;
const int maxn = 1e4;
const int inf = 0x3f3f3f3f;
struct edge {
    int to, cap, cost, rev;
    edge() {}
    edge(int to, int _cap, int _cost, int _rev) :to(to), cap(_cap), cost(_cost), rev(_rev) {}
};
int V, H[maxn + 5], dis[maxn + 5], PreV[maxn + 5], PreE[maxn + 5];
vector&lt;edge&gt; G[maxn + 5];
void init(int n) {
    V = n;
    for (int i = 0; i &lt;= V; ++i)G[i].clear();
}
void AddEdge(int from, int to, int cap, int cost) {
    G[from].push_back(edge(to, cap, cost, G[to].size()));
    G[to].push_back(edge(from, 0, -cost, G[from].size() - 1));
}
int Min_cost_max_flow(int s, int t, int f, int&amp; flow) {
    int res = 0; fill(H, H + 1 + V, 0);
    while (f) {
        priority_queue &lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt; &gt; q;
        fill(dis, dis + 1 + V, inf);
        dis[s] = 0; q.push(pair&lt;int, int&gt;(0, s));
        while (!q.empty()) {
            pair&lt;int, int&gt; now = q.top(); q.pop();
            int v = now.second;
            if (dis[v] &lt; now.first)continue;
            for (int i = 0; i &lt; G[v].size(); ++i) {
                edge&amp; e = G[v][i];
                if (e.cap &gt; 0 &amp;&amp; dis[e.to] &gt; dis[v] + e.cost + H[v] - H[e.to]) {
                    dis[e.to] = dis[v] + e.cost + H[v] - H[e.to];
                    PreV[e.to] = v;
                    PreE[e.to] = i;
                    q.push(pair&lt;int, int&gt;(dis[e.to], e.to));
                }
            }
        }
        if (dis[t] == inf)break;
        for (int i = 0; i &lt;= V; ++i)H[i] += dis[i];
        int d = f;
        for (int v = t; v != s; v = PreV[v])d = min(d, G[PreV[v]][PreE[v]].cap);
        f -= d; flow += d; res += d*H[t];
        for (int v = t; v != s; v = PreV[v]) {
            edge&amp; e = G[PreV[v]][PreE[v]];
            e.cap -= d;
            G[v][e.rev].cap += d;
        }
    }
    return res;
}
int a[maxn];
int main()
{
    int t;
    scanf(&quot;%d&quot;,&amp;t);
    while(t--)
    {
        int n,k;
        scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
        for(register int i=1;i&lt;=n;++i) scanf(&quot;%d&quot;,&amp;a[i]);
        int ss=0,s=1,t=2*n+2,tt=2*n+3;
        init(tt+1);
        AddEdge(ss,s,k,0);
        AddEdge(t,tt,k,0);
        for(register int i=1;i&lt;=n;++i)
        {
            AddEdge(s,i+1,1,0);
            AddEdge(i+1+n,t,1,0);
            AddEdge(i+1,i+1+n,1,-a[i]);
            for(register int j=i+1;j&lt;=n;++j)
            {
                if(a[j]&gt;=a[i])
                {
                    AddEdge(1+i+n,1+j,1,0);
                }
            }
        }
        int ans=0;
        printf(&quot;%d\n&quot;,-Min_cost_max_flow(ss,tt,inf,ans));
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="ZHXU1998">
            
              <p class="site-author-name" itemprop="name">ZHXU1998</p>
              <p class="site-description motion-element" itemprop="description">等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZHXU1998</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
