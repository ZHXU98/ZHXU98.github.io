<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢">
<meta property="og:type" content="website">
<meta property="og:title" content="蒟蒻最后的倔强">
<meta property="og:url" content="http://zhxu98.github.io/page/4/index.html">
<meta property="og:site_name" content="蒟蒻最后的倔强">
<meta property="og:description" content="等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蒟蒻最后的倔强">
<meta name="twitter:description" content="等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://zhxu98.github.io/page/4/">





  <title>蒟蒻最后的倔强</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?58b7e016a3433eb1162126ec13ec1dbf";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蒟蒻最后的倔强</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">by-zhxu98</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/07/2019HDU杭电多校第二场 HDU 6599 I Love Palindrome String I题 回文树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/07/2019HDU杭电多校第二场 HDU 6599 I Love Palindrome String I题 回文树/" itemprop="url">2019HDU杭电多校第二场 HDU 6599 I Love Palindrome String I题 回文树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-07T13:38:49+08:00">
                2019-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/字符串/" itemprop="url" rel="index">
                    <span itemprop="name">字符串</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以下 回文树板子</p>
<pre><code>const int maxn = 100005;// n(空间复杂度o(n*ALP)),实际开n即可
const int ALP = 26;

struct PAM{ // 每个节点代表一个回文串
    int next[maxn][ALP]; // next指针,参照Trie树
    int fail[maxn]; // fail失配后缀链接
    int cnt[maxn]; // 此回文串出现个数
    int num[maxn];
    int len[maxn]; // 回文串长度
    int s[maxn]; // 存放添加的字符
    int last; //指向上一个字符所在的节点，方便下一次add
    int n; // 已添加字符个数
    int p; // 节点个数

    int newnode(int w){ // 初始化节点，w=长度
        for(int i=0;i&lt;ALP;i++)
            next[p][i] = 0;
        cnt[p] = 0;
        num[p] = 0;
        len[p] = w;
        return p++;
    }
    void init(){
        p = 0;
        newnode(0);
        newnode(-1);
        last = 0;
        n = 0;
        s[n] = -1; // 开头放一个字符集中没有的字符，减少特判
        fail[0] = 1;
    }
    int get_fail(int x){ // 和KMP一样，失配后找一个尽量最长的
        while(s[n-len[x]-1] != s[n]) x = fail[x];
        return x;
    }
    void add(int c){
        c -= &apos;a&apos;;
        s[++n] = c;
        int cur = get_fail(last);
        if(!next[cur][c]){
            int now = newnode(len[cur]+2);
            fail[now] = next[get_fail(fail[cur])][c];
            next[cur][c] = now;
            num[now] = num[fail[now]] + 1;
        }
        last = next[cur][c];
        cnt[last]++;
    }
    void count(){
        // 最后统计一遍每个节点出现个数
        // 父亲累加儿子的cnt,类似SAM中parent树
        // 满足parent拓扑关系
        for(int i=p-1;i&gt;=0;i--)
            cnt[fail[i]] += cnt[i];
    }
}pam;</code></pre><p>这道题 整段回文 和 前半段回文 就看出 前后是一样的 hash判断就好</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef unsigned long long ull; 
const int maxn = 300005;// n(?????o(n*ALP)),???n??
const int ALP = 27;
string st;
ull ha[maxn],pp[maxn];
int ans[maxn];

int get_hash(int l,int r){
    if(l == 0) return ha[r];
    return ha[r]-ha[l-1]*pp[r-l+1];
}

bool chk(int l,int r){
    int len=r-l+1;
    int mid=(l+r)&gt;&gt;1;
    if(len&amp;1) return get_hash(l,mid)==get_hash(mid,r);
    else return get_hash(l,mid)==get_hash(mid+1,r);
}

struct PAM{ 
    int next[maxn][ALP]; 
    int fail[maxn]; 
    int cnt[maxn]; 
    int num[maxn];
    int len[maxn]; 
    int s[maxn]; 
    int last;
    int n; 
    int p; 
    int idx[maxn * ALP];
    int newnode(int w){ 
        for(int i=0;i&lt;ALP;i++)
            next[p][i] = 0;
        cnt[p] = 0;
        num[p] = 0;
        len[p] = w;
        return p++;
    }
    void init(){
        p = 0;
        newnode(0);
        newnode(-1);
        last = 0;
        n = 0;
        s[n] = -1;
        fail[0] = 1;
    }
    int get_fail(int x){ 
        while(s[n-len[x]-1] != s[n]) x = fail[x];
        return x;
    }
    void add(int c){
        c -= &apos;a&apos;;
        s[++n] = c;
        int cur = get_fail(last);
        if(!next[cur][c]){
            int now = newnode(len[cur]+2);
            fail[now] = next[get_fail(fail[cur])][c];
            next[cur][c] = now;
            num[now] = num[fail[now]] + 1;
        }
        last = next[cur][c];
        cnt[last]++;
        idx[last] = n;
    }
    void count(){
        for(int i=p-1;i&gt;=0;i--)
              cnt[fail[i]] += cnt[i];
        for(int i = 2; i &lt; p ;i ++ ) {
            if(chk(idx[i] - len[i], idx[i] - 1)) {
                for(int j = idx[i] - len[i]; j &lt; idx[i];j ++) cout &lt;&lt; st[j] ;cout &lt;&lt; endl;
                ans[len[i]] += cnt[i];
            }
        }
    }
}pam;

int main(){
    pp[0] = 1;
    for(int i = 1; i &lt; maxn; i ++) pp[i] = pp[i - 1] * 131;
    while(cin &gt;&gt; st) {
        int len = st.size();
        for(int i = 0; i &lt;= len; i ++) ans[i] = 0;
        pam.init();
        for(int i = 0; i &lt; len; i ++) pam.add(st[i]);

        ha[0] = st[0];
        for(int i = 1; i &lt; len; i ++) 
            ha[i] = ha[i - 1] * 131 + st[i];
        pam.count();
        for(int i = 1; i &lt;= len; i ++) {
            if(i != 1) cout &lt;&lt; &quot; &quot;;
            cout &lt;&lt; ans[i];
        }
        cout &lt;&lt; endl;
    }
    return 0;

} </code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/07/《算法竞赛进阶指南》 0x6A 代码 + 杂谈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/07/《算法竞赛进阶指南》 0x6A 代码 + 杂谈/" itemprop="url">《算法竞赛进阶指南》 0x6A 代码 + 杂谈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-07T09:02:57+08:00">
                2019-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/题集/" itemprop="url" rel="index">
                    <span itemprop="name">题集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>舞动的晚会<br>我自己写的 建图可能写错了 导致后面输出的像是可行边 我也很迷 感觉没有检错图</p>
<blockquote>
<p>匹配边(i,j) j到i连边<br> 非匹配边 (i,j) i到j连边<br> 匹配的左点i (i,S)<br> 不匹配的左点i (S,i)<br> 匹配的右点j (T,j)<br> 不匹配的右点j (j,T)<br> 然后用Tarjan求强连通分量<br> (i,j)是可行边的条件：<br> (i,j)是匹配边 或者 i,j在同一个scc里<br> 那么总边数减去可行边数就是不可行边数，即答案。<br> 注意这个新图要包含源和汇，不能只在二分图两部之间连边，除非原最大匹配是一个完备匹配。</p>
</blockquote>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int maxn = 150000 + 100;

int n, m, k;
int s, t;
int head[maxn], depth[maxn], cur[maxn], cnt;
int nxt[maxn &lt;&lt; 2], to[maxn &lt;&lt; 2], cap[maxn &lt;&lt; 2];  

void ade(int a, int b, int c) {
    to[++cnt] = b;
    cap[cnt] = c;
    nxt[cnt] = head[a];
    head[a] = cnt;
}

bool bfs(){
    queue&lt;int&gt; que;
    que.push(s);
    memset(depth, 0, sizeof(depth));
    depth[s] = 1;
    while(!que.empty()) {
        int u = que.front(); que.pop();
        for(int i = head[u]; i != -1; i = nxt[i]) {
            if(cap[i] &gt; 0 &amp;&amp; depth[to[i]] == 0) {
                depth[to[i]] = depth[u] + 1;
                que.push(to[i]);
            }
        }
    }
    if(depth[t]) return 1;
    else return 0;
}

int dfs(int u, int dist) {
    if(u == t) return dist;
    for(int &amp;i = cur[u]; i != -1; i = nxt[i]) {
        if(depth[to[i]] == depth[u] + 1 &amp;&amp; cap[i] &gt; 0) {
            int tmp = dfs(to[i], min(dist, cap[i]));
            if(tmp &gt; 0) {
                cap[i] -= tmp;
                cap[i ^ 1] += tmp;
                return tmp; 
            }
        }
    }
    return 0;
}

int dinic() {
    int res = 0, d;
    while(bfs()) {
        for(int i = 0; i &lt; n + m + 5; i ++) cur[i] = head[i];
        while(d = dfs(s, INF)) res += d;
    }
    return res;
}

int dfn[maxn], low[maxn];
bool vis[maxn];
stack&lt;int&gt; stac;
int scc_cnt, idx, cmp[maxn];

int thead[maxn], tcnt;
int tto[maxn &lt;&lt; 2], tnxt[maxn &lt;&lt; 2];

void tade(int a, int b) {
    tto[++ tcnt] = b;
    tnxt[tcnt] = thead[a];
    thead[a] = tcnt;
}

void tarjan(int x) {
    dfn[x] = low[x] = ++idx;
    stac.push(x);
    vis[x]=true;
    for(int i = thead[x]; i; i = tnxt[i]) {
        int u = tto[i];
        if(!dfn[u]) {
            tarjan(u);
            low[x] = min(low[x], low[u]);
        } else if(vis[u])low[x] = min(low[x], dfn[u]);
    }//tarjan模板
    int k;
    if(low[x] == dfn[x]) {
        ++scc_cnt;
        do {
            k = stac.top();
            stac.pop();
            vis[k] = false;
            cmp[k] = scc_cnt;
        } while(x!=k);
    }
}

int a[maxn], b[maxn], e[maxn];

int main() {
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    memset(head, -1, sizeof(head));
    cnt = -1;
    for(int i = 1; i &lt;= k; i ++) {
        cin &gt;&gt; a[i] &gt;&gt; b[i];
        ade(a[i], b[i] + n, 1), e[i] = cnt;
        ade(b[i] + n, a[i], 0);
    }                                       
    s = 0, t = n + m + 1;
    for(int i = 1; i &lt;= n; i ++) ade(s, i, 1), ade(i, s, 0);
    for(int i = 1; i &lt;= m; i ++) ade(i + n, t, 1), ade(t, i + n, 0);
    dinic();

    for(int u = 0; u &lt;= n + m + 1; u ++) for(int i = head[u]; ~i; i = nxt[i])
            if(cap[i]) tade(u, to[i]);

    for(int i = 0; i &lt;= n + m + 1; i ++) 
        if(!dfn[i]) tarjan(i);

    int ans = k;
    for(int i = 1; i &lt;= k; i++) 
        if(cmp[a[i]] == cmp[b[i] + n] || !cap[e[i]])
            ans --;

    cout &lt;&lt; ans &lt;&lt; endl;
    for(int i = 1; i &lt;= k; i ++) {
        if(cmp[a[i]] != cmp[b[i] + n] &amp;&amp; cap[e[i]]) {
            cout &lt;&lt; i &lt;&lt; &quot; &quot;;
        }
    }
    cout &lt;&lt; endl;
    return 0;
}</code></pre><p>标称</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
const int inf = 0x3fffffff, u = 40010, w = 300010;
int head[u], ver[w], edge[w], Next[w], d[u], e[w], c[u], sta[u], ins[u], dfn[u], low[u];
int n, m, p, s, t, i, j, tot, maxflow, ans, x, y, scc, st, num;
char str[10];
vector&lt;int&gt; a[u];
queue&lt;int&gt; q;

void add(int x, int y, int z) {
    ver[++tot] = y, edge[tot] = z, Next[tot] = head[x], head[x] = tot;
    ver[++tot] = x, edge[tot] = 0, Next[tot] = head[y], head[y] = tot;
}

bool bfs() {
    memset(d, 0, sizeof(d));
    while (q.size()) q.pop();
    q.push(s);
    d[s] = 1;
    while (q.size()) {
        int x = q.front();
        q.pop();
        for (int i = head[x]; i; i = Next[i])
            if (edge[i] &amp;&amp; !d[ver[i]]) {
                q.push(ver[i]);
                d[ver[i]] = d[x] + 1;
                if (ver[i] == t) return 1;
            }
    }
    return 0;
}

int dinic(int x, int flow) {
    if (x == t) return flow;
    int rest = flow, k;
    for (int i = head[x]; i &amp;&amp; rest; i = Next[i])
        if (edge[i] &amp;&amp; d[ver[i]] == d[x] + 1) {
            k = dinic(ver[i], min(rest, edge[i]));
            if (!k) d[ver[i]] = 0;
            edge[i] -= k;
            edge[i ^ 1] += k;
            rest -= k;
        }
    return flow - rest;
}

void add2(int x, int y) {
    a[x].push_back(y);
}

void tarjan(int x) {
    dfn[x] = ++num;
    low[x] = num;
    sta[++st] = x;
    ins[x] = 1;
    int y;
    for (int i = 0; i&lt;a[x].size(); i++)
        if (!dfn[y = a[x][i]]) {
            tarjan(y);
            low[x] = min(low[x], low[y]);
        } else if (ins[y]) low[x] = min(low[x], dfn[y]);
    if (dfn[x] == low[x]) {
        scc++;
        do {
            y = sta[st];
            st--;
            ins[y] = 0;
            c[y] = scc;
        } while (x != y);
    }
}

int main() {
    while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; p) {
        memset(head, 0, sizeof(head));
        s = 0, t = n + m + 1;
        tot = 1;
        maxflow = 0;
        for (i = 1; i &lt;= n; i++) add(s, i, 1);
        for (i = 1; i &lt;= m; i++) add(i + n, t, 1);
        for (i = 1; i &lt;= p; i++) {
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            add(x, n + y, 1), e[i] = tot;
        }
        while (bfs())
            while (i = dinic(s, inf)) maxflow += i;
        for (i = s; i &lt;= t; i++) a[i].clear();
        for (i = 1; i &lt;= p; i++)
            if (!edge[e[i]]) add2(ver[e[i]], ver[e[i] ^ 1]);
            else add2(ver[e[i] ^ 1], ver[e[i]]);
        for (i = 1; i &lt;= n; i++)
            if (!edge[2 * i]) add2(i, s);
            else add2(s, i);
        for (i = 1; i &lt;= m; i++)
            if (!edge[2 * (n + i)]) add2(t, n + i);
            else add2(n + i, t);
        memset(dfn, 0, sizeof(dfn));
        memset(ins, 0, sizeof(ins));
        memset(c, 0, sizeof(c));
        st = num = scc = ans = 0;
        for (i = s; i &lt;= t; i++)
            if (!dfn[i]) tarjan(i);
        for (i = 1; i &lt;= p; i++)
            if (edge[e[i]] || c[ver[e[i]]] == c[ver[e[i] ^ 1]]) ans++;
        cout &lt;&lt; (ans = p - ans) &lt;&lt; endl;
        if (!ans) cout &lt;&lt; endl;
        for (i = 1; i &lt;= p; i++)
            if (!edge[e[i]] &amp;&amp; c[ver[e[i]]] != c[ver[e[i] ^ 1]])
                if (--ans) printf(&quot;%d &quot;, i);
                else printf(&quot;%d\n&quot;, i);
    }
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/06/2019HDU多校第五场 6630+permutation 2 (打表找规律)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/06/2019HDU多校第五场 6630+permutation 2 (打表找规律)/" itemprop="url">2019HDU多校第五场 6630	permutation 2 (打表找规律)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-06T15:03:46+08:00">
                2019-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数学/" itemprop="url" rel="index">
                    <span itemprop="name">数学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190806145441851.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190806145441851.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)<br>以下是我打的表。。。。。 ![在这里插入图片描述](<a href="https://img-" target="_blank" rel="noopener">https://img-</a><br>blog.csdnimg.cn/20190806145455906.png?x-oss-<br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/2019080614550026.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/2019080614550026.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)<br>眼瞎了 别笑orz<br>我们发现 第一行 除了最后一个就是解。。。。。<br>然后 l == 1 or r == 1 去错开一行 r - l + 1 就是要的解</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
#define N 1000010
using namespace std;
const int mod = 998244353;
int mp[15][15];
const int maxn = 1e5 + 5;
int a[maxn];

int main() {
//    int n;
//    cin &gt;&gt; n;
//    int a[12];
//    for(int i = 1; i &lt;= n; i ++) {
//        a[i] = i;
//    }
//
//    for(int x = 1; x &lt;= n; x ++) {
//        for(int y = x + 1; y &lt;= n; y ++) {
//            int ans = 0;
//            do {
//                int f = 1;
//                if(a[1] == x &amp;&amp; a[n] == y) {
//                    for(int z = 2; z &lt;= n; z ++) {
//                        if(abs(a[z] - a[z - 1]) &gt; 2)
//                            {f = 0; break;}
//                    }
//                    if(f) ans ++;
//                }
//            }while(next_permutation(a + 1, a + 1 + n));
//            mp[x][y] = mp[y][x] = ans;
//        }
//    }
//    cout &lt;&lt; &quot;    &quot;;
//    for(int i = 1; i &lt;= n; i ++)
//        cout &lt;&lt; &quot;  &quot;&lt;&lt; i &lt;&lt; &quot; &quot;;
//    cout &lt;&lt; endl;
//    cout &lt;&lt; endl;
//    for(int i = 1; i &lt;= n; i ++) {
//        cout &lt;&lt; i &lt;&lt; &quot;     &quot;;
//        for(int j = 1; j &lt;= n; j ++) {
//            cout &lt;&lt; mp[i][j] &lt;&lt; &quot;   &quot;;
//        }cout &lt;&lt; endl;
//    }
    int t;
    cin &gt;&gt; t;
    int n, l, r;

    a[0] = 0;
    a[1] = 1;
    a[2] = 1;
    a[3] = 1;
    for(int i = 4; i &lt; maxn; i ++) {
        a[i] = (a[i - 1] + a[i - 3]) % mod ;
    }
//    for(int i = 1; i &lt;= 15; i ++) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot; ; cout &lt;&lt; endl;
    while(t --) {
        cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;
        if(l != 1) l++;
        if(r != n) r--;
            cout &lt;&lt; a[r -  l + 1] &lt;&lt; endl;

    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/05/2019牛客暑期多校(第五场) 写题记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/05/2019牛客暑期多校(第五场) 写题记录/" itemprop="url">2019牛客暑期多校(第五场) 写题记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-05T17:07:13+08:00">
                2019-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/题集/" itemprop="url" rel="index">
                    <span itemprop="name">题集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="A-digits-2"><a href="#A-digits-2" class="headerlink" title="A digits 2"></a>A digits 2</h5><p>A题 找到 数字连续出现 同时是它倍数的 n 《100 输出长度也小于100*100<br>//水</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

int main(){
    int n, m;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i++) {
        cin &gt;&gt; m;
        int ans =0;
        for(int j = 1; j &lt;= m; j ++) {
            cout &lt;&lt; m ;
        }cout &lt;&lt; endl;
    }
    return 0;
}</code></pre><h5 id="B-generator-1"><a href="#B-generator-1" class="headerlink" title="B generator 1"></a>B generator 1</h5><p>B题 欧拉降幂死的体无全尸<br>我们每一位考虑 最后一位开始向前<br>每放入这个数 将之前的矩阵 ^ 10<br>就如同正常的 整数几次方 我们分开乘了<br>111 = （（（1 * 10 ） + 1 ）* 10 ）+ 1；</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
#define int long long
int mod ;

struct MAT{
    int a[5][5];
    MAT (){
        memset(a, 0, sizeof a);
    }
    void init() {
        for(int i = 1; i &lt;= 2; i ++) a[i][i] = 1;
    }

    friend MAT operator * (const MAT &amp;a, const MAT &amp;b) {
        MAT c;
        c.a[1][1] = c.a[2][2] = c.a[1][2] = c.a[2][1] = 0;
        for(int i = 1; i &lt;= 2; i ++) for(int k = 1; k &lt;= 2; k ++) for(int j = 1; j &lt;= 2; j ++)
            c.a[i][j] = (1ll * c.a[i][j] + 1ll * a.a[i][k] * b.a[k][j]) % mod;
        return c;
    }

    friend MAT operator ^ (MAT a, long long y) {
        MAT c;
        c.init();
        for(; y; y &gt;&gt;= 1) {
            if(y &amp; 1) c = c * a;
            a = a * a;
        }
        return c;
    } 
};

signed main() {
    int x0, x1, a, b;
    string s;
    cin &gt;&gt; x0 &gt;&gt; x1 &gt;&gt; a &gt;&gt; b &gt;&gt; s &gt;&gt; mod;
    MAT A; A.a[1][1] = a, A.a[1][2] = b, A.a[2][1] = 1, A.a[2][2] = 0;
    MAT B; B.a[1][1] = x1, B.a[1][2] = 0, B.a[2][1] = x0, A.a[2][2] = 0;
    for(int i = s.size() - 1; i &gt;= 0; i --) {
        if(s[i] - &apos;0&apos;) {
            MAT t = (A ^ (signed(s[i] - &apos;0&apos;)));
            B = t * B;
        }
        A = (A ^ 10);
    }
    cout &lt;&lt; B.a[2][1] &lt;&lt; endl;
    return 0;
}</code></pre><h4 id="F-maximum-clique-1"><a href="#F-maximum-clique-1" class="headerlink" title="F maximum clique 1"></a>F maximum clique 1</h4><p>我们要将一堆数字分开 找到集合里数字二进制1个数 相差 &gt;= 2 最多的集合 输出</p>
<p>我们考虑二分图 左边 是1 个数奇数 右边偶数<br>这样建图 我们在同一侧的 不管肿摸组合 他们都可以<br>找到 &lt; 2 之间 的 数字连边跑最大流<br>这样 我们二分图匹配 就能 把这些找到不要的情况<br>原图减去 这些 就是最大独立集合</p>
<p>至于输出 我们要考虑最后一次BFS depth数组 如果s能到达 就意味着 这个点并没有被和 t点一块割去<br>两边 同侧 而且 与之自己相连同边的 汇点 or 源点 就是 最大独立及</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 2e5 + 5;
const int N = 1e4 + 5;
const int INF = 0x3f3f3f3f;
int a[maxn], b[maxn];
int n, m;
int head[N], depth[N], cur[N], cnt, s, t;
int to[maxn &lt;&lt; 2], nxt[maxn &lt;&lt; 2], cap[maxn &lt;&lt; 2];

int resbit(int i) {
    int res = 0;
    while(i) res ++, i -= (i &amp; -i);
    return res;
}

bool chk(int i, int j) {
    int res = 0;
    int k = i ^ j;
    while(k) res++, k-=(k &amp; -k);
    return res &lt; 2;
}

void ade(int a, int b, int c) {
    to[++cnt] = b, cap[cnt] = c;
    nxt[cnt] = head[a], head[a] = cnt;
}

bool bfs(){
    queue&lt;int&gt; que;
    que.push(s);
    memset(depth, 0, sizeof(depth));
    depth[s] = 1;
    while(!que.empty()) {
        int u = que.front(); que.pop();
        for(int i = head[u]; i != -1; i = nxt[i]) {
            if(cap[i] &gt; 0 &amp;&amp; depth[to[i]] == 0) {
                depth[to[i]] = depth[u] + 1;
                que.push(to[i]);
            }
        }
    }
//    for(int i = 0; i &lt;= n + 1; i ++) {
//        cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt;depth[i] &lt;&lt; endl;
//    }
    if(depth[t]) return 1;
    else return 0;
}


int dfs(int u, int dist) {
    if(u == t) return dist;
    for(int &amp;i = cur[u]; i != -1; i = nxt[i]) {
        if(depth[to[i]] == depth[u] + 1 &amp;&amp; cap[i]) {
            int tmp = dfs(to[i], min(dist, cap[i]));
            if(tmp &gt; 0) {
                cap[i] -= tmp;
                cap[i ^ 1] += tmp;
                return tmp;
            }
        }
    }
    return 0;
}

int dinic() {
    int res = 0, d;
    while(bfs()) {
        for(int i = 0; i &lt; n + 5; i ++) cur[i] = head[i];
        while(d = dfs(s, INF)) res += d;
    }
    return res;
}

int main() {
    scanf(&quot;%d&quot;, &amp;n);
    cnt = -1;
    memset(head, -1, (n + 5) * sizeof(int));
    for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, a + i), b[i] = resbit(a[i]);

    s = 0, t = n + 1;
    for(int i = 1; i &lt;= n; i ++) {
        if(b[i] % 2 == 1) ade(s, i, 1), ade(i, s, 0);
        else ade(i, t, 1), ade(t, i, 0);

        for(int j = i + 1; j &lt;= n; j ++) {
            if(i == j) continue;
            if(chk(a[i], a[j])){
                if(b[i] % 2 == 1) ade(i, j, 1), ade(j, i, 0);
                else ade(j, i, 1), ade(i, j, 0);
            }
        }
    }
    int ans = dinic();

//    for(int i = 0; i &lt;= n + 1; i ++) {
//        cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt;depth[i] &lt;&lt; endl;
//    }
    int f = 0;
    printf(&quot;%d\n&quot;, n - ans);
    for(int i = 1; i &lt;= n; i ++) {
        if((b[i] % 2 == 1) ^ (depth[i] == 0)){
            if(f) cout &lt;&lt; &quot; &quot;;
            cout &lt;&lt; a[i];
            f = 1;
        }
    }cout &lt;&lt; endl;

    return 0;
}</code></pre><h5 id="G-subsequence-1"><a href="#G-subsequence-1" class="headerlink" title="G subsequence 1"></a>G subsequence 1</h5><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int maxn = 3e3 + 5;
const int mod = 998244353;
int n, m, cas;
int dp[maxn][maxn];
int f[maxn][maxn];

char s[maxn], t[maxn];

void init() {
    f[0][0] = f[1][0] = f[1][1] = 1;
    for(int i = 2; i &lt;= 3000; i ++) {
        f[i][0] = 1;
        for(int j = 1; j &lt;= i; j ++)
            f[i][j] = (f[i - 1][j] + f[i - 1][j - 1]) %mod;
    }
}

int main() {
    init();
    cin &gt;&gt; cas;
    while(cas --) {
        cin &gt;&gt; n &gt;&gt; m;
        cin &gt;&gt; (s + 1) &gt;&gt; (t + 1);
        int ans = 0;
        for(int i = 0; i &lt;= n; i ++) dp[i][0] = 1;

        for(int i = 1; i &lt;= n; i++)
            for(int j = 1; j &lt;= min(m, i); j++) {
                dp[i][j] = dp[i - 1][j];
                if(s[i] == t[j]) dp[i][j] = (1ll * dp[i][j] + dp[i - 1][j - 1]) % mod;
                if(s[i] &gt; t[j] ) {
                    ans = (1ll * ans + (ll)dp[i - 1][j - 1] * f[n - i][m - j]) % mod;
                }
            }
        for(int i = 1; i &lt;= n; i ++) {
            if(s[i] == &apos;0&apos;) continue;
            for(int j = m; j &lt;= n - i; j ++)
                ans = (1ll * ans + f[n - i][j]) % mod;
         }
         cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}</code></pre><h5 id="subsequence-2"><a href="#subsequence-2" class="headerlink" title="subsequence 2"></a>subsequence 2</h5><p>这 题是拓扑 orz<br>字符编号，这里每一个字符都保存一下他的位数和相对添加进来的位置就好了，<br>拓扑排序建边的时候建立相邻的边就好了， 如果能建 就是有解的</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0);
using namespace std;
typedef long long ll;
//#define int long long
const int maxn = 3e5 + 5;

int n, m, M;
int head[maxn], nums[30], deg[maxn], cnt;// 1e4 * 26 + 1e4 顶点极限
int to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1];

int getid(char s, int num) {
    return (s - &apos;a&apos;)*10000 + num;
}

int reid(int id) {
    return id / 10000 + &apos;a&apos;;
}

void ade(int a, int b) {
    to[++ cnt] = b;
    nxt[cnt] = head[a], head[a] = cnt;
}
string ans;
bool topsort() {
    ans = &quot;&quot;;
    queue&lt;int&gt; que;
    for(int i = 0; i &lt; 26; i ++) if(deg[i * 10000 + 1] == 0 &amp;&amp; nums[i]) que.push(i * 10000 + 1);
    while(!que.empty()) {
        int x = que.front(); que.pop();
        ans.push_back(reid(x));
        for(int i = head[x]; i; i = nxt[i]) {
            int y = to[i];
            if(-- deg[y] == 0) que.push(y);
        }
    }
    return ans.size() == n;
}

signed main() {
    fastio;
    cin &gt;&gt; n &gt;&gt; m;
    M = (m - 1) * m / 2;
    string s1, s2;
    bool flag = 0;
    for(int i = 1, len; i &lt;= M; i ++) {
        cin &gt;&gt; s1 &gt;&gt; len;
        if(len != 0) cin &gt;&gt; s2;
        if(flag) continue;
        int n0 = 0, n1 = 0, pre = -1, tmp;
        for(int j = 0; j &lt; len; j ++) {
            tmp = 0;
            nums[s2[j] - &apos;a&apos;] = 1;
            if(s2[j] == s1[0]) n0 ++,tmp = getid(s2[j], n0);
            else n1 ++,tmp = getid(s2[j], n1);
            if(pre != -1) {
                deg[tmp] ++;
                ade(pre, tmp);
            }
            pre = tmp;
        }
    }
    if(topsort()) cout &lt;&lt; ans &lt;&lt; endl;
    else cout &lt;&lt; -1 &lt;&lt; endl;
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/04/《算法竞赛进阶指南》 0x25 ~ 0x28 代码 + 杂谈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/04/《算法竞赛进阶指南》 0x25 ~ 0x28 代码 + 杂谈/" itemprop="url">《算法竞赛进阶指南》 0x25 ~ 0x28 代码 + 杂谈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-04T19:09:34+08:00">
                2019-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/题集/" itemprop="url" rel="index">
                    <span itemprop="name">题集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="0x25"><a href="#0x25" class="headerlink" title="0x25"></a>0x25</h3><p>推箱子。。。。。。。 是真的写废了。。。。</p>
<h4 id="矩阵距离"><a href="#矩阵距离" class="headerlink" title="矩阵距离"></a>矩阵距离</h4><p>这个就是常见点 一开始就把多元点 放入队列的写法</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1005;
const int dx[] = {1, 0, -1, 0};
const int dy[] = {0, 1, 0, -1};
typedef pair&lt;int, int&gt; P;

int n, m;
int ans[maxn][maxn];
struct node{
    int x, y, st;
};

queue&lt;node&gt; que;

bool chk(int x, int y) {
    return (x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; m || ans[x][y] != -1);
}

void bfs(){
    while(!que.empty()){
        node p = que.front(); que.pop();
        for(int i = 0; i &lt; 4; i ++) {
            int nx = p.x + dx[i];
            int ny = p.y + dy[i];
            if(chk(nx, ny)) continue;
            ans[nx][ny] = p.st + 1;
            que.push(node{nx, ny, p.st + 1});
        }
    }

}

int main(){
    memset(ans, -1, sizeof ans);
    cin &gt;&gt; n &gt;&gt; m;
    string str;
    for(int i = 1;i &lt;= n; i ++) {
        cin &gt;&gt; str;
        for(int j = 1; j &lt;= m; j ++) {
            if(str[j - 1] == &apos;1&apos;) ans[i][j] = 0, que.push(node{i, j, 0});
        }
    }
    bfs();
    for(int i = 1; i &lt;= n; i++){
        for(int j = 1; j &lt;= m; j ++) cout &lt;&lt; ans[i][j] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    } 
    return 0;
}</code></pre><h3 id="0x26"><a href="#0x26" class="headerlink" title="0x26"></a>0x26</h3><p>双端队列BFS<br>电路维修 权值只有 0 1 0 放前面提前出 1 放后面 以此减低复杂度<br>注意 每个点 对应的权值 改了好就</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; P;
const int maxn = 505;

const int dx[] = {1, -1, -1, 1};
const int dy[] = {1, -1, 1, -1};
const int ndx[] = {1, 0, 0, 1};
const int ndy[] = {1, 0, 1, 0};

int n, m;
char str[maxn][maxn];
bool vis[maxn][maxn];
int dis[maxn][maxn];

struct node{
    int x, y;
};

bool check(int x, int y) {return x &gt;= 0 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= m;}

void bfs(){
    deque&lt;node&gt; que;
    que.push_back(node{0, 0});
    memset(dis, 0x3f, sizeof dis);
    memset(vis, 0, sizeof vis);
    vis[0][0] = 1;
    dis[0][0] = 0;
    while(!que.empty()) {
        node p = que.front(); que.pop_front();
        for(int i = 0, t; i &lt; 4; i ++) {
            int nx = p.x + ndx[i], tx = p.x + dx[i];
            int ny = p.y + ndy[i], ty = p.y + dy[i];
            if(i &lt; 2) t = str[nx][ny] == &apos;/&apos; ? 1 : 0;
            else t = str[nx][ny] == &apos;/&apos; ? 0 : 1;
            if(check(tx, ty) &amp;&amp; !vis[tx][ty] &amp;&amp; dis[tx][ty] &gt; dis[p.x][p.y] + t){
                dis[tx][ty] = dis[p.x][p.y] + t;
                if(t) que.push_back(node{tx, ty});
                else que.push_front(node{tx, ty});
            }
        }
    }
    if(dis[n][m] != 0x3f3f3f3f) cout &lt;&lt; dis[n][m] &lt;&lt; endl;
    else cout &lt;&lt; &quot;NO SOLUTION&quot; &lt;&lt; endl;
}

int main(){
    int t;
    cin &gt;&gt; t;
    while(t--){
        cin &gt;&gt; n &gt;&gt; m;
        for(int i = 1; i &lt;= n; i ++ ) cin &gt;&gt; (str[i] + 1);
        bfs();
        // for(int i = 0; i &lt;= n; i ++) {
        //     for(int j = 0; j &lt;= m; j++) {
        //         cout &lt;&lt; dis[i][j] &lt;&lt; &quot; &quot;;
        //     }cout &lt;&lt; endl;
        // }
    }
    return 0;
}</code></pre><h4 id="优先队列BFS"><a href="#优先队列BFS" class="headerlink" title="优先队列BFS"></a>优先队列BFS</h4><p>我想起了DJ最短路。。</p>
<h5 id="Full-Tank"><a href="#Full-Tank" class="headerlink" title="Full Tank"></a>Full Tank</h5><p>这个 也是常见的 很像最短路 分层图一个写法</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e4 + 5;

int head[maxn], fcst[maxn], cnt;
int nxt[maxn * 20], to[maxn * 20], dis[maxn * 20];
bool vis[maxn][105];

struct node{
    int u, f, cst;
    bool operator &lt; (const node &amp; a) const {
        return cst &gt; a.cst;
    }
};

void ade(int a, int b, int v) {
    to[++cnt] = b, dis[cnt] = v;
    nxt[cnt] = head[a], head[a] = cnt;
    to[++cnt] = a, dis[cnt] = v;
    nxt[cnt] = head[b], head[b] = cnt;
}

int dj(int c, int s, int t){
    priority_queue&lt;node&gt; que;
    memset(vis, 0, sizeof vis);
    que.push(node{s, 0, 0});
    while(!que.empty()) {
        node p = que.top(); que.pop();
        if(p.u == t) return p.cst;
        if(vis[p.u][p.f]) continue;
        vis[p.u][p.f] = 1;
        if(p.f &lt; c &amp;&amp; !vis[p.u][p.f + 1]) {
            que.push(node{p.u, p.f + 1, p.cst + fcst[p.u]});
        }
        for(int i = head[p.u]; i; i = nxt[i]) {
            int v = to[i];
            if(p.f &gt;= dis[i] &amp;&amp; !vis[v][p.f - dis[i]]) {
                que.push(node{v, p.f - dis[i], p.cst});
            }
        }
    }
    return -1;
}

int main() {
    int n, m;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; n; i ++) cin &gt;&gt; fcst[i];
    for(int i = 1, a, b, c; i &lt;= m; i ++) 
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c, ade(a, b, c);
    cin &gt;&gt; m;
    for(int i = 1, c, s, t; i &lt;= m; i ++) {
        cin &gt;&gt; c &gt;&gt; s &gt;&gt; t;
        int ans = dj(c, s, t);
        if(ans == -1) cout &lt;&lt; &quot;impossible\n&quot;;
        else cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}</code></pre><h4 id="双向BFS"><a href="#双向BFS" class="headerlink" title="双向BFS"></a>双向BFS</h4><h5 id="噩梦"><a href="#噩梦" class="headerlink" title="噩梦"></a>噩梦</h5><p>对着3个会动的分别极限BFS 每个人论者进行一次 鬼先走<br>省去去 一起跑 状态太多的存储 也是BFS一个有效方法</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int maxn = 800 + 5;
const int INF = 0x3f3f3f3;
const int cx[] = {-1, 0, 1, 0};
const int cy[] = {0, 1, 0, -1};
string str;
int n, m, cas;
char mp[maxn][maxn];

struct node{
    int x, y, sp;
    node(int _x, int _y, int _sp){
        x = _x, y = _y, sp = _sp;
    }
};
queue&lt;node&gt; G, Z, M;

bool chkZ(int x, int y) {
    return (x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; m || mp[x][y] == &apos;Z&apos;);
}

bool chkH(int x, int y) {
    if((x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; m)) return 1;
    if(mp[x][y] == &apos;X&apos; || mp[x][y] == &apos;Z&apos;) return 1;
    return 0; 
}

void pt(){
    for(int i = 1; i &lt;= n; i++) {
        for(int j = 1; j &lt;= m; j ++) {
            cout &lt;&lt; mp[i][j] &lt;&lt; &quot; &quot;;
        }cout &lt;&lt; endl;
    }
}

int sol(){
    while(Z.size()) {
        int time = Z.front().sp;
    //    cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl;pt();cout &lt;&lt; endl;
        while(!Z.empty() &amp;&amp; Z.front().sp &lt; time + 2) {
            node p = Z.front(); Z.pop();
            for(int i = 0; i &lt; 4; i ++) {
                int nx = p.x + cx[i], ny = p.y + cy[i];
                if(chkZ(nx, ny)) continue;
                mp[nx][ny] = &apos;Z&apos;;
                Z.push(node(nx, ny, p.sp + 1));
             }
        }
    //    pt();cout &lt;&lt; endl;
        time = M.front().sp;
        while(!M.empty() &amp;&amp; M.front().sp &lt; time + 3) {
            node p = M.front(); M.pop();
            if(mp[p.x][p.y] == &apos;Z&apos;) continue;
            for(int i = 0; i &lt; 4; i ++) {
                int nx = p.x + cx[i], ny = p.y + cy[i];
                if(chkH(nx, ny)) continue;
                if(mp[nx][ny] == &apos;M&apos;) continue;
                if(mp[nx][ny] == &apos;G&apos;) return p.sp / 3 + 1;
                mp[nx][ny] = &apos;M&apos;;
                M.push(node(nx, ny, p.sp + 1));
             }
        }
        //    pt();cout &lt;&lt; endl;
        time = G.front().sp;
        while(!G.empty() &amp;&amp; G.front().sp &lt; time + 1) {
            node p = G.front(); G.pop();
            if(mp[p.x][p.y] == &apos;Z&apos;) continue;
            for(int i = 0; i &lt; 4; i ++) {
                int nx = p.x + cx[i], ny = p.y + cy[i];
                if(chkH(nx, ny)) continue;
                if(mp[nx][ny] == &apos;G&apos;) continue;
                if(mp[nx][ny] == &apos;M&apos;) return p.sp + 1;
                mp[nx][ny] = &apos;G&apos;;
                G.push(node(nx, ny, p.sp + 1));
             }
        }
        //    pt();cout &lt;&lt; endl;
    } 
    return -1;
}

signed main(){
    cin &gt;&gt; cas;
    while(cas --) {
        while(!Z.empty()) Z.pop();
        while(!G.empty()) G.pop();
        while(!M.empty()) M.pop();
        cin &gt;&gt; n &gt;&gt; m;
        for(int i = 1; i &lt;= n; i ++) {
            cin &gt;&gt; str;
            for(int j = 1; j &lt;= m; j ++){
                mp[i][j] = str[j - 1];
                if(str[j - 1] == &apos;G&apos;) G.push(node(i, j, 0));
                if(str[j - 1] == &apos;Z&apos;) Z.push(node(i, j, 0));
                if(str[j - 1] == &apos;M&apos;) M.push(node(i, j, 0));
            }
        }
        cout &lt;&lt; sol() &lt;&lt; endl;
    }
    return 0; 
}</code></pre><h2 id="Astar"><a href="#Astar" class="headerlink" title="Astar"></a>Astar</h2><p>加上估值函数的 BFS A*  
估值函数不能大于实际价值就好<br>估的越好 我们越能从队列里取出 最优的状态 减低复杂度</p>
<h4 id="第K短路"><a href="#第K短路" class="headerlink" title="第K短路"></a>第K短路</h4><p>正常跑最短路 如果补终止 那么 这个点 第几次出现 就是第K短路上的路径和</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
//#define int long long
using namespace std;
const int maxn = 1000 + 10;
const int maxe = 1e5 + 10;
const int INF = 0x3f3f3f3;
typedef pair&lt;int, int&gt; P;

int n, m, s, t, k;
int head[maxn], cnt;
int nxt[maxe &lt;&lt; 1], to[maxe &lt;&lt; 1], dis[maxe &lt;&lt; 1];
void ade(int a, int b, int v) {
    to[++ cnt] = b, dis[cnt] = v;
    nxt[cnt] = head[a], head[a] = cnt;
}

int rhead[maxn], rcnt;
int rnxt[maxe &lt;&lt; 1], rto[maxe &lt;&lt; 1], rdis[maxe &lt;&lt; 1];
void rade(int a, int b, int v) {
    rto[++ rcnt] = b, rdis[rcnt] = v;
    rnxt[rcnt] = rhead[a], rhead[a] = rcnt;
}

int f[maxn];
bool vis[maxn];
void dj(int s, int t) {
    memset(f, 0x3f, sizeof f);
    f[s] = 0;
    priority_queue&lt;P&gt; que;
    que.push(P(0, s));
    while(!que.empty()) {
        P p = que.top(); que.pop();
        int u = p.second;
        if(vis[u]) continue;
        vis[u] = 1;
        for(int i = rhead[u]; i; i = rnxt[i]) {
            int v = rto[i];
            if(f[v] &gt; f[u] + rdis[i]) {
                f[v] = f[u] + rdis[i];
                que.push(P(-f[v], v));
            } 
        }
    }
}

struct node{
    int u, f, g;
    bool operator &lt; (const node &amp; a) const {
        return f + g &gt; a.f + a.g;
    }
};

int Astar(int s, int t, int k) {
    int counts = 0;
    priority_queue&lt;node&gt; que;
    if(s == t) k ++;
    que.push(node{s, 0, 0});
    while(!que.empty()) {
        node p = que.top(); que.pop();
        int u = p.u;
        if(u == t) counts++;
        if(counts == k) return p.g;
        for(int i = head[u]; i; i = nxt[i]) {
            int v = to[i];
            que.push(node{v, 0, dis[i] + p.g});
        }
    }
    return -1;
}

signed main() {
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1, a, b, c; i &lt;= m; i ++) {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        ade(a, b, c), rade(b, a, c);
    }
    cin &gt;&gt; s &gt;&gt; t &gt;&gt; k;
    dj(t, s);
//    for(int i = 1; i &lt;= n; i ++) cout &lt;&lt; f[i] &lt;&lt; &quot; &quot; ; cout &lt;&lt; endl;
    cout &lt;&lt; Astar(s, t, k) &lt;&lt; endl;
    return 0;
}</code></pre><h3 id="八数码-问题"><a href="#八数码-问题" class="headerlink" title="八数码 问题"></a>八数码 问题</h3><p>其实 这里还可以加上 逆序对优化 排除一些无解的情况</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 362880 + 100;
const int fac[] = {1,1,2,6,24,120,720,5040,40320,362880};

bool vis[maxn];
const int cx[] = {-1, 1, 0, 0};
const int cy[] = {0, 0, -1, 1};
const char op[] = {&apos;u&apos;,&apos;d&apos;,&apos;l&apos;,&apos;r&apos;};
const int endsta = 0;
char path[maxn];
int pre[maxn];

struct node {
    int sta, g, f;
    int s[9], loc;
    bool operator &lt; (const node&amp; a) const {
        return g + f &gt; a.g + a.f;
    }
};

int cantor(int *a) {
    int x = 0;
    for (int i = 0; i &lt; 9; ++i) {
        int tmp = 0;
        for (int j = i + 1; j &lt; 9; ++j)
            if (a[j] &lt; a[i])
                tmp++;
        x += fac[9 - i - 1] * tmp;
    }
    return x;
}

int dis_f(int *s) {
    int res = 0;
    for(int i = 0; i &lt; 9; i ++)
        if(s[i] != 9) {
            int x = i/3, y = i%3;
            int xx = (s[i] - 1)/3, yy = (s[i]  - 1)%3;
            res += abs(x - xx) + abs(y - yy);
        }
    return res;
}

priority_queue&lt;node&gt;que;
bool astar(node begins) {
    begins.sta = cantor(begins.s);
    begins.g = 0, begins.f = dis_f(begins.s);
    pre[begins.sta] = -1;
    vis[begins.sta] = 1;
    que.push(begins);
    node tmp,now;
    while(!que.empty()) {
        node now = que.top();
        que.pop();
        if(now.sta == endsta) return 1;
        int x = now.loc / 3, y = now.loc % 3;
        for(int i = 0; i &lt; 4; i ++) {
            int nx = x + cx[i];
            int ny = y + cy[i];
            if(nx &lt; 0 || nx &gt; 2 || ny &lt; 0 || ny &gt; 2) continue;
            tmp = now;
            tmp.s[x * 3 + y] = tmp.s[nx * 3 + ny];
            tmp.s[nx * 3 + ny] = 9;
            tmp.sta = cantor(tmp.s);
            if(vis[tmp.sta]) continue;
            vis[tmp.sta] = 1;
            tmp.loc = nx * 3 + ny;
            tmp.g ++;
            tmp.f = dis_f(tmp.s);
            pre[tmp.sta] = now.sta;
            path[tmp.sta] = op[i];
            que.push(tmp);
        }
    }
    return 0;
}

void print(int sta) {
    if(pre[sta] == -1) return ;
    print(pre[sta]);
    printf(&quot;%c&quot;, path[sta]);
}

int main() {
    node begins;
    char pt;
    for(int i = 0; i &lt; 9; i ++ ) {
        scanf(&quot; %c&quot;, &amp;pt);
        if(pt == &apos;x&apos;) begins.s[i] = 9, begins.loc = i;
        else begins.s[i] = pt - &apos;0&apos;;
    }
    if(!astar(begins)) puts(&quot;unsolvable&quot;);
    else print(endsta), puts(&quot;&quot;);
    return 0;
}</code></pre><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA*"></a>IDA*</h2><h4 id="排书"><a href="#排书" class="headerlink" title="排书"></a>排书</h4><p>这个估值函数 我一开始写的不太对了 一直T 跪了 有点难</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
const int maxn = 25;
int n;

struct node{
    int a[maxn];
    int reh(){
        int cnt = 0;
        if ( a[1] != 1 ) ++cnt;
        if ( a[n] != n ) ++cnt;
        for ( int i = 1; i &lt; n; ++i )
                if ( a[i] + 1 != a[i + 1] ) ++cnt;
        return ceil( cnt / 3.0 );
    }

    bool chk() {
        for(int i = 1; i &lt; n; i ++) 
            if(a[i] + 1 != a[i + 1]) return 0;
        return 1;
    }

    node move(int l, int r, int len) {
        node b = *this;
        for(int i = len + l; i &lt;= r; i ++) b.a[i - len] = b.a[i]; 
        for(int i = r - len + 1; i &lt;= r; i ++) b.a[i] = a[i + l - r + len - 1];
        return b;
   }
}ts;

int flag;

void dfs(node x, int h,int limit) {
    if(flag || x.reh() + h &gt; limit) return;
    if(x.chk()) {flag = 1; return ;}
    for(int len = 1; len &lt; n; len ++) 
        for(int i = 1; i + len - 1 &lt;= n; i ++) 
            for(int j = i + len; j &lt;= n; j ++) 
            dfs(x.move(i, j, len), h + 1, limit);
}

int main() {
    int t; cin &gt;&gt; t;
    while(t --) {
        cin &gt;&gt; n;
        for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; ts.a[i];
        flag = 0;
        for(int i = 0; i &lt; 5; i ++) {
            dfs(ts, 0, i);
            if(flag) {
                cout &lt;&lt; i &lt;&lt; endl;
                break;
            }
        }
        if(!flag) cout &lt;&lt; &quot;5 or more&quot; &lt;&lt; endl;
    }
    return 0;
}</code></pre><p>待续。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/04/《算法竞赛进阶指南》 0x68 ~ 0x67 代码 + 杂谈/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/04/《算法竞赛进阶指南》 0x68 ~ 0x67 代码 + 杂谈/" itemprop="url">《算法竞赛进阶指南》 0x68 ~ 0x67 代码 + 杂谈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-04T17:26:59+08:00">
                2019-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/题集/" itemprop="url" rel="index">
                    <span itemprop="name">题集</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="二分图最大匹配"><a href="#二分图最大匹配" class="headerlink" title="二分图最大匹配"></a>二分图最大匹配</h2><p>之前 一直没有学匈牙利 只写DINIC 匈牙利也挺简单的 关键是好写多了orz</p>
<h5 id="关押罪犯"><a href="#关押罪犯" class="headerlink" title="关押罪犯"></a>关押罪犯</h5><p><a href="https://blog.csdn.net/qq_40831340/article/details/88821278" target="_blank" rel="noopener"> https://blog.csdn.net/qq_40831340/article/details/88821278
</a></p>
<h4 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h4><p>我依稀的记得 第一次见到是DP来着</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 105;
const int cx[] = {-1, 0, 1, 0};
const int cy[] = {0, 1, 0, -1};

int n, k;
bool mp[maxn][maxn], vis[maxn * maxn];

int head[maxn * maxn], match[maxn * maxn], cnt;
int nxt[maxn * maxn &lt;&lt; 2], to[maxn * maxn &lt;&lt; 2];


void ade(int a, int b) {
    to[++cnt] = b;
    nxt[cnt] = head[a], head[a] = cnt;
}

int ids(int i, int j) {
    return (i) * n + j;
}

bool chk(int i, int j) {
    if(i &lt; 1 || i &gt; n || j &lt; 1 || j &gt; n) return 0;
    if(mp[i][j]) return 0;
    return 1;
}

bool dfs(int x) {
    for(int i = head[x], y; i; i = nxt[i]) {
        if(!vis[y = to[i]]) {
            vis[y] = 1;
            if(!match[y] || dfs(match[y])) {
                match[y] = x; return true;
            }
        }
    }
    return false;
}

int main() {
    cin &gt;&gt; n &gt;&gt; k;
    for(int i = 1, a, b; i &lt;= k; i ++) {
        cin &gt;&gt; a &gt;&gt; b;
        mp[a][b] = 1;
    }

    for(int i = 1; i &lt;= n; i ++) {
        for(int j = (i % 2 ? 1 : 2); j &lt;= n; j += 2) {
            for(int z = 0; z &lt; 4; z ++) {
                if(chk(i + cx[z], j + cy[z]))
                    ade(ids(i, j), ids(i + cx[z], j + cy[z])), ade(ids(i + cx[z], j + cy[z]), ids(i, j));
            }
        }
    }

    int ans = 0;
    for(int i = 1; i &lt;= n; i ++) {
        for(int j = (i % 2 ? 1 : 2); j &lt;= n; j += 2) {
            if(mp[i][j]) continue;
            memset(vis, 0, sizeof vis);
            if(dfs(ids(i, j))) ans ++;
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</code></pre><h5 id="车的放置"><a href="#车的放置" class="headerlink" title="车的放置"></a>车的放置</h5><p>把行和列当 左右匹配点</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 205;
const int cx[] = {-1, 0, 1, 0};
const int cy[] = {0, 1, 0, -1};

int n, m, k;
bool mp[maxn][maxn], vis[maxn * maxn];

int head[maxn * maxn], match[maxn * maxn], cnt;
int nxt[maxn * maxn &lt;&lt; 2], to[maxn * maxn &lt;&lt; 2];


void ade(int a, int b) {
    to[++cnt] = b;
    nxt[cnt] = head[a], head[a] = cnt;
}

bool chk(int i, int j) {
    if(i &lt; 1 || i &gt; n || j &lt; 1 || j &gt; n) return 0;
    if(mp[i][j]) return 0;
    return 1;
}

bool dfs(int x) {
    for(int i = head[x], y; i; i = nxt[i]) {
        if(!vis[y = to[i]]) {
            vis[y] = 1;
            if(!match[y] || dfs(match[y])) {
                match[y] = x; return true;
            }
        }
    }
    return false;
}

int main() {
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    for(int i = 1, a, b; i &lt;= k; i ++) {
        cin &gt;&gt; a &gt;&gt; b;
        mp[a][b] = 1;
    }

    for(int i = 1; i &lt;= n; i ++) {
        for(int j = 1; j &lt;= m; j ++) {
            if(!mp[i][j]) ade(i, j + n),ade(j + n, i);
        }
    }

    int ans = 0;
    for(int i = 1; i &lt;= n; i ++) {
            memset(vis, 0, sizeof vis);
            if(dfs(i)) ans ++;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}</code></pre><h5 id="导弹防御塔"><a href="#导弹防御塔" class="headerlink" title="导弹防御塔"></a>导弹防御塔</h5><p><a href="https://blog.csdn.net/qq_40831340/article/details/97746759" target="_blank" rel="noopener"> https://blog.csdn.net/qq_40831340/article/details/97746759
</a></p>
<h5 id="二分图-带权匹配"><a href="#二分图-带权匹配" class="headerlink" title="二分图 带权匹配"></a>二分图 带权匹配</h5><p>一般费用流最大价值 边取反处理<br>补上 蚂蚁那道题 既然线不相交 那样 他们之间距离就会保持最小</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
using namespace std;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int maxn = 2e4 + 10;

int n, m, s, t;
int head[maxn], cnt;
int nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1], cap[maxn &lt;&lt; 1];
double cost[maxn &lt;&lt; 1];
int ans[maxn];

void ade(int a, int b, int w, double c) {
    to[cnt] = b, cost[cnt] = c, cap[cnt] = w;
    nxt[cnt] = head[a], head[a] = cnt++;
}

bool vis[maxn];
double dis[maxn];
int flow[maxn], pre[maxn], last[maxn];

bool spfa() {
    queue&lt;int&gt; que;
    memset(flow, 0x3f, sizeof(flow));
    memset(vis, 0, sizeof(vis));
    fill(dis, dis + 2 * n + 3, 1e12);
    que.push(s);
    vis[s] = 1;
    dis[s] = 0;
    pre[t] = -1;
    flow[s] = INF;
    while(!que.empty()) {
        int now = que.front(); que.pop();
        vis[now] = 0;
        for(int i = head[now]; ~i ; i = nxt[i]) {
            if(cap[i] &amp;&amp; dis[to[i]] &gt; dis[now] + cost[i]) {
                dis[to[i]] = dis[now] + cost[i];
                pre[to[i]] = now;
                last[to[i]] = i;
                flow[to[i]] = min(flow[now], cap[i]);
                if(!vis[to[i]]) {
                    vis[to[i]] = 1;
                    que.push(to[i]);
                }
            }
        }
    }
    return pre[t] != -1;
}

double mincost;
int maxflow;

void MCMF() {
    while(spfa()) {
        int now = t;
        maxflow += flow[t];
        mincost += 1.0 * flow[t] * dis[t];
        while(now != s) {
            cap[last[now]] -= flow[t];
            cap[last[now] ^ 1] += flow[t];
            now = pre[now];
        }
    }
}

struct point {
    int x, y;
} a[105], b[105];

double redis(int i, int j) {
    return sqrt((a[i].x - b[j].x) * (a[i].x - b[j].x) + (a[i].y - b[j].y) * (a[i].y - b[j].y));
}

signed main() {
    fastio;
    memset(head, -1, sizeof(head));
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i].x &gt;&gt; a[i].y;
    for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; b[i].x &gt;&gt; b[i].y;
    s = 0, t = 2 * n + 1;

    for(int i = 1; i &lt;= n; i++) {
        ade(s, i, 1, 0), ade(i, s, 0, 0);
        ade(i + n, t, 1, 0), ade(t, i + n, 0, 0);
    }

    for(int i = 1; i &lt;= n; i ++) {
        for(int j = 1; j &lt;= n; j ++) {
            double len = redis(i, j);
            ade(i, j + n, 1, len), ade(j + n, i, 0, -len);
        }
    }
    MCMF();

    for(int u = 1; u &lt;= n; u++) {
        for(int i = head[u]; ~i; i = nxt[i]) {
            if(cap[i] == 0) ans[u] = to[i] - n;
        }
    }

    for(int i = 1; i &lt;= n; i++) {
        cout &lt;&lt; ans[i] &lt;&lt; endl;
    }
    // cout &lt;&lt; maxflow &lt;&lt; &quot; &quot; &lt;&lt; mincost &lt;&lt; endl;
    return 0;
}</code></pre><h2 id="二分图覆盖"><a href="#二分图覆盖" class="headerlink" title="二分图覆盖"></a>二分图覆盖</h2><p>最小点覆盖 = 最大匹配<br>相对于二分图匹配完的边 每个边上二者至少选一个 覆盖所有边</p>
<h5 id="任务机器"><a href="#任务机器" class="headerlink" title="任务机器"></a>任务机器</h5><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e3 + 5;

int n, m, k;
int head[maxn &lt;&lt; 1], match[maxn &lt;&lt; 1], cnt;
int nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1];
bool vis[maxn &lt;&lt; 1];

void ade(int a, int b) {
    to[++cnt] = b;
    nxt[cnt] = head[a], head[a] = cnt;
}

bool dfs(int x) {
    for(int i = head[x], y; i; i = nxt[i]) {
        if(!vis[y = to[i]]){
            vis[y] = 1;
            if(!match[y] || dfs(match[y])){
                match[y] = x; return true;
            }
        }
    } 
    return false;
}

int main() {
    while(cin &gt;&gt; n &amp;&amp; n) {
        cin &gt;&gt; m &gt;&gt; k;
        memset(head, 0, sizeof head);
        memset(match, 0, sizeof match);
        cnt = 0;
        for(int i = 1, a, b, c; i &lt;= k; i ++) {
            cin &gt;&gt; c &gt;&gt; a &gt;&gt; b;
            if(a == 0 || b == 0) continue;
            ade(a, b + n + 1), ade(b + n + 1, a);
        }
        int ans = 0;
        for(int i = 1; i &lt;= n; i ++){
            memset(vis, 0, sizeof vis);
            if(dfs(i)) ans ++ ;
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    }

    return 0;
}</code></pre><h5 id="泥泞的区域"><a href="#泥泞的区域" class="headerlink" title="泥泞的区域"></a>泥泞的区域</h5><p>与网络流一样 还是建图是最难写的地方。。。。。</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e3 + 5;

int n, m;
char mp[maxn][maxn];
int h[maxn][maxn], l[maxn][maxn];
int head[maxn], match[maxn], cnt;
int nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1];
bool vis[maxn];

void ade(int a, int b) {
    to[++ cnt] = b;
    nxt[cnt] = head[a], head[a] = cnt;
}

bool dfs(int x) {
    for(int i = head[x], y; i; i = nxt[i]) {
        if(!vis[y = to[i]]) {
            vis[y] = 1;
            if(!match[y] || dfs(match[y])) {
                match[y] = x; return true;
            }
        }
    }
    return false;
}

int main() {
    scanf (&quot;%d %d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i ++) scanf(&quot;%s&quot;, mp[i] + 1);
    int tot = 0;
    for(int i = 1; i &lt;= n; i ++) {
        for(int j = 1; j &lt;= m; j ++) {
            if(mp[i][j] == &apos;*&apos;) {
                if(mp[i][j - 1] == &apos;*&apos;) h[i][j] = tot;
                else h[i][j] = ++tot;
            }
        }
    }

    for(int i = 1; i &lt;= m; i ++) {
        for(int j = 1; j &lt;= n; j ++) {
            if(mp[j][i] == &apos;*&apos;) {
                if(mp[j - 1][i] == &apos;*&apos;) l[j][i] = tot;
                else l[j][i] = ++tot;
            }
        }
    }

    for(int i = 1; i &lt;= n; i ++) {
        for(int j = 1; j &lt;= m; j ++) {
            if(l[i][j] &amp;&amp; h[i][j]) {
                ade(l[i][j], h[i][j]), ade(h[i][j], l[i][j]);
            }
        }
    }
    // for(int i = 1; i &lt;= n; i ++) {
    //     for(int j = 1; j &lt;=m;j ++) {
    //         cout &lt;&lt; h[i][j] &lt;&lt; &quot; &quot;;
    //     }cout &lt;&lt; endl;
    // }

    // for(int i = 1; i &lt;= n; i ++) {
    //     for(int j = 1; j &lt;=m;j ++) {
    //         cout &lt;&lt; l[i][j] &lt;&lt; &quot; &quot;;
    //     }cout &lt;&lt; endl;
    // }

    int ans = 0;
    for(int i = 1; i &lt;= tot; i ++) {
        memset(vis, 0, sizeof vis);
        if(dfs(i)) ans ++;
    }
    cout &lt;&lt; ans / 2&lt;&lt; endl;
    return 0;
}</code></pre><h2 id="二分图最大独立集"><a href="#二分图最大独立集" class="headerlink" title="二分图最大独立集"></a>二分图最大独立集</h2><p>任何点之间 都没有边链接</p>
<h5 id="骑士放置"><a href="#骑士放置" class="headerlink" title="骑士放置"></a>骑士放置</h5><pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e5 + 5;

int n, m, k;
int mp[105][105];
int head[maxn], match[maxn], cnt;
int nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1];
bool vis[maxn];

const int cx[10]={-1, -2, -1, -2, 1, 2, 1, 2};
const int cy[10]={-2, -1, 2, 1, -2, -1, 2, 1};

int ids(int i, int j) {
    return (i - 1) * m + j;
}

bool chk(int x, int y) {
    if(x &lt; 1 || y &lt; 1 || x &gt; n || y &gt; m || mp[x][y]) return 1;
    else return 0;
}

void ade(int a, int b) {
    to[++ cnt] = b;
    nxt[cnt] = head[a], head[a] = cnt;
}

bool dfs(int x) {
    for(int i = head[x], y; i; i = nxt[i]) {
        if(!vis[y = to[i]]) {
            vis[y] = 1;
            if(!match[y] || dfs(match[y])) {
                match[y] = x; return true;
            }
        }
    }
    return false;
}

int main() {
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    for(int i = 1, a, b; i &lt;= k; i ++) {
        cin &gt;&gt; a &gt;&gt; b;
        mp[a][b] = 1;
    }

    for(int i = 1; i &lt;= n; i ++) {
        for(int j = 1; j &lt;= m; j ++) {
            if(mp[i][j]) continue;
            for(int z = 0; z &lt; 8; z ++) {
                int nx = i + cx[z], ny = j + cy[z];
                if(chk(nx, ny)) continue;
                ade(ids(i, j), ids(nx, ny));
            }
        }
    }
    int ans = 0;
    for(int i = 1; i &lt;= n; i ++) {
        for(int j = 1; j &lt;= m; j ++ ) {
            if(mp[i][j]) continue;
            memset(vis, 0, sizeof vis);
            if(dfs(ids(i, j))) ans ++;
        }
    }
    cout &lt;&lt; n * m - ans/2 - k &lt;&lt; endl;
    return 0;
}</code></pre><h5 id="ANT"><a href="#ANT" class="headerlink" title="ANT"></a>ANT</h5><p>带权二分图匹配 费用流写法</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
using namespace std;
typedef long long ll;
const int INF = 0x3f3f3f3f;
const int maxn = 2e4 + 10;

int n, m, s, t;
int head[maxn], cnt;
int nxt[maxn &lt;&lt; 1], to[maxn &lt;&lt; 1], cap[maxn &lt;&lt; 1];
double cost[maxn &lt;&lt; 1];
int ans[maxn];

void ade(int a, int b, int w, double c) {
    to[cnt] = b, cost[cnt] = c, cap[cnt] = w;
    nxt[cnt] = head[a], head[a] = cnt++;
}

bool vis[maxn];
double dis[maxn];
int flow[maxn], pre[maxn], last[maxn];

bool spfa() {
    queue&lt;int&gt; que;
    memset(flow, 0x3f, sizeof(flow));
    memset(vis, 0, sizeof(vis));
    fill(dis, dis + 2 * n + 3, 1e12);
    que.push(s);
    vis[s] = 1;
    dis[s] = 0;
    pre[t] = -1;
    flow[s] = INF;
    while(!que.empty()) {
        int now = que.front(); que.pop();
        vis[now] = 0;
        for(int i = head[now]; ~i ; i = nxt[i]) {
            if(cap[i] &amp;&amp; dis[to[i]] &gt; dis[now] + cost[i]) {
                dis[to[i]] = dis[now] + cost[i];
                pre[to[i]] = now;
                last[to[i]] = i;
                flow[to[i]] = min(flow[now], cap[i]);
                if(!vis[to[i]]) {
                    vis[to[i]] = 1;
                    que.push(to[i]);
                }
            }
        }
    }
    return pre[t] != -1;
}

double mincost;
int maxflow;

void MCMF() {
    while(spfa()) {
        int now = t;
        maxflow += flow[t];
        mincost += 1.0 * flow[t] * dis[t];
        while(now != s) {
            cap[last[now]] -= flow[t];
            cap[last[now] ^ 1] += flow[t];
            now = pre[now];
        }
    }
}

struct point {
    int x, y;
} a[105], b[105];

double redis(int i, int j) {
    return sqrt((a[i].x - b[j].x) * (a[i].x - b[j].x) + (a[i].y - b[j].y) * (a[i].y - b[j].y));
}

signed main() {
    fastio;
    memset(head, -1, sizeof(head));
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i].x &gt;&gt; a[i].y;
    for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; b[i].x &gt;&gt; b[i].y;
    s = 0, t = 2 * n + 1;

    for(int i = 1; i &lt;= n; i++) {
        ade(s, i, 1, 0), ade(i, s, 0, 0);
        ade(i + n, t, 1, 0), ade(t, i + n, 0, 0);
    }

    for(int i = 1; i &lt;= n; i ++) {
        for(int j = 1; j &lt;= n; j ++) {
            double len = redis(i, j);
          //  cout &lt;&lt; len &lt;&lt; endl;
            ade(i, j + n, 1, len), ade(j + n, i, 0, -len);
        }
    }
    MCMF();

    for(int u = 1; u &lt;= n; u++) {
        for(int i = head[u]; ~i; i = nxt[i]) {
            if(cap[i] == 0) ans[u] = to[i] - n;
        }
    }

    for(int i = 1; i &lt;= n; i++) {
        cout &lt;&lt; ans[i] &lt;&lt; endl;
    }    
    // cout &lt;&lt; maxflow &lt;&lt; &quot; &quot; &lt;&lt; mincost &lt;&lt; endl;
    return 0;
}</code></pre><p>有向无环图最小路径点覆盖 待续</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/07/31/2019HDU多校第二场 HDU 6598 Harmonious Army (最小割)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/31/2019HDU多校第二场 HDU 6598 Harmonious Army (最小割)/" itemprop="url">2019HDU多校第二场 HDU 6598 Harmonious Army (最小割)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-31T19:19:04+08:00">
                2019-07-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/图论/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>还是第一次见到网络流 还能这么见图的 找最小割 看最大匹配价值的<br>mark 学习了<br>割图 肯定分成要不和s连 要不和t连<br>如果多个点 之间还有价值 同时在一个集合中 比如把 a， b 割了<br>总价值 - 最小割 我们会把e算进去 不丢掉点与点之间的价值<br>割边的时候 这些情况都照顾到了<br>我们解方程建边 算最小割<br>总价值 剪掉这个最小割 就是我们匹配的最大价值<br>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190731190712775.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190731190712775.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)<br>注释部分 跑300ms 还是自己板子好啊 才90ms</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define inf 0x3f3f3f3f

const int N = 515;
const int M = 6e4 + 10;

int head[N], depth[N], cur[N], cnt = 1;
int nxt[M &lt;&lt; 1], to[M &lt;&lt; 1], cap[M &lt;&lt; 1];

void ade(int a, int b, int c) {
    to[++ cnt] = b, cap[cnt] = c;
    nxt[cnt] = head[a], head[a] = cnt;
    to[++ cnt] = a, cap[cnt] = 0;
    nxt[cnt] = head[b], head[b] = cnt;
}

bool bfs(int s, int t) {
    memset(depth, 0, sizeof depth);
    queue&lt;int&gt; que;
    depth[s] = 1;
    que.push(s);
    while(!que.empty()) {
        int u = que.front(); que.pop();
        for(int i = head[u]; i; i = nxt[i]) {
            int v = to[i];
            if(!cap[i] || depth[v]) continue;
            depth[v] = depth[u] + 1;
            que.push(v);
        }
    }
    return depth[t];
}

//long long dfs(int s, int t, int flow) {
//    if(s == t) return flow;
//    long long ret = 0;
//    for(int i = head[s]; flow &amp;&amp; i; i = nxt[i]) {
//        int v = to[i];
//        if(depth[v] == depth[s] + 1 &amp;&amp; cap[i]) {
//            long long tmp = dfs(v, t, min(flow, cap[i]));
//            cap[i] -= tmp;
//            cap[i ^ 1] += tmp;
//            flow -= tmp;
//            ret += tmp;
//        }
//    }
//    if(!ret) depth[s] = 0;
//    return ret;
//}

long long dfs(int u, int t,int dist){
    if(u == t) return dist;
    for(int&amp; i=cur[u];i;i=nxt[i]){
        if(depth[to[i]]==depth[u]+1&amp;&amp;cap[i]){
            long long tmp=dfs(to[i], t, min(dist,cap[i]));
            if(tmp&gt;0){
                cap[i]-=tmp;
                cap[i^1]+=tmp;
                return tmp;
            }
        }
    }
    return 0;
}

//
//long long dinic(int s, int t) {
//    long long ret = 0;
//    while(bfs(s, t)){
//        ret += dfs(s, t, inf);
//    }
//    return ret;
//}

long long dinic(int s, int t){
    long long res=0,d;
    while(bfs(s, t)){
        for(int i=0;i&lt; 504;i++) cur[i]=head[i];
        while(d = dfs(s, t,inf)) res+=d;
    }
    return res;
}

int main() {
    int n, m, s, t, a, b, c, u, v;
    while(~scanf(&quot;%d %d&quot;, &amp;n, &amp;m)) {
        cnt = 1;
        memset(head, 0, sizeof head);
        s = n + 1, t = n + 2;
        long long sum = 0;
        while(m--) {
            scanf(&quot;%d%d%d%d%d&quot;, &amp;u, &amp;v, &amp;a, &amp;b, &amp;c);
            ade(s, u, a + b);
            ade(s, v, a + b);
            ade(u, t, b + c);
            ade(v, t, b + c);
            ade(u, v, -2 * b + a + c);
            ade(v, u, -2 * b + a + c);
            sum += a + b + c;
        }
        long long ans = round((2.0 * sum - dinic(s, t)) / 2);
        printf(&quot;%lld\n&quot;,ans);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/07/31/2019HDU多校第二场 HDU-6602 Longest Subarray (线段树 + 思维)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/31/2019HDU多校第二场 HDU-6602 Longest Subarray (线段树 + 思维)/" itemprop="url">2019HDU多校第二场 HDU-6602 Longest Subarray (线段树 + 思维)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-31T10:52:53+08:00">
                2019-07-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/树型结构/" itemprop="url" rel="index">
                    <span itemprop="name">树型结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>题意： 长度为n的序列，求最大的子序列长度，要求子序列中所出现的数字个数&gt;=k。</p>
<p>思路： 枚举右边界r，线段树维护左边界l的范围。<br>对于每一个数a[r]来说，我们可以清楚的知道 l 可以在什么地方</p>
<p>放入一个 a[r] 对于 i 位置 c - 1数据不需要出现<br>对于它之前出现的 我们是要选择r这个位置的数据的 所以我们要把 它前一个数据位置 到 r - 1 先 -1<br>选择r位置 就把之前位置在的地方a[r] 数据出现减去</p>
<p>离a[r]最近的 同一个数据数子 位置为 P1，<br>离a[r]第k远的 同一个数据数字 位置 P2，<br>它这个数据之后的下一位 P3<br>当 a[r] 加入 p2 ~ p3 位置 就对a[r] 数据 合法了 区间 + 1；<br>右边 就是 p1 ~ r 这个区间 与之前 1 ~ p2 ~ p3 区间 对应<br>最后查询区间个数&gt;=c的最左边的边界l即可。</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e5 + 10;

int tree[maxn &lt;&lt; 2], lazy[maxn &lt;&lt; 2];
vector&lt;int&gt; vec[maxn];
int n, C, k;
int a[maxn], pos[maxn];

void push_up(int rt) {
    tree[rt] = max(tree[rt &lt;&lt; 1], tree[rt &lt;&lt; 1 | 1]);
}

void push_down(int rt) {
    if(lazy[rt] == 0) return ;
    tree[rt &lt;&lt; 1] += lazy[rt];
    lazy[rt &lt;&lt; 1] += lazy[rt];
    tree[rt &lt;&lt; 1 | 1] += lazy[rt];
    lazy[rt &lt;&lt; 1 | 1] += lazy[rt];
    lazy[rt] = 0;
}

void build(int l, int r, int rt) {
    tree[rt] = lazy[rt] = 0;
    if(l == r) return ;
    int mid = l + r &gt;&gt; 1;
    build(l, mid, rt &lt;&lt; 1);
    build(mid + 1, r, rt &lt;&lt; 1 | 1);
}

void updata(int L, int R, int l, int r, int rt, int val) {
    if(L &gt; R) return ;
    if(L &lt;= l &amp;&amp; R &gt;= r) {
        tree[rt] += val;
        lazy[rt] += val;
        return ;
    }
    push_down(rt);
    int mid = l + r &gt;&gt; 1;
    if(L &lt;= mid) updata(L, R, l, mid, rt &lt;&lt; 1, val);
    if(R &gt; mid) updata(L, R, mid + 1, r, rt &lt;&lt; 1 | 1, val);
    push_up(rt);
}

int query(int l, int r, int rt) {
    if(tree[rt] &lt; C) return 0;
    if(l == r) return l;
    push_down(rt);
    int mid = l + r &gt;&gt; 1;
    if(tree[rt &lt;&lt; 1] &gt;= C) return query(l, mid, rt &lt;&lt; 1);
    if(tree[rt &lt;&lt; 1 | 1] &gt;= C) return query(mid + 1, r, rt &lt;&lt; 1 | 1) ;
}

int main() {
    while(~scanf(&quot;%d%d%d&quot;, &amp;n, &amp;C, &amp;k)) {
        for(int i = 1; i &lt;= C; i++)
            vec[i].clear(), vec[i].emplace_back(0);
        int ans = 0;
        build(1, n, 1);
        for(int i = 1, x; i &lt;= n; i++) {
            scanf(&quot;%d&quot;, &amp;x);
            updata(i, i, 1, n, 1, C - 1);
            updata(vec[x].back() + 1, i - 1, 1, n, 1, -1);
            vec[x].emplace_back(i);
            int t = vec[x].size() - k - 1;
            if(t &gt;= 0) updata(vec[x][t] + 1, vec[x][t + 1], 1, n, 1, 1);
            int j = query(1, n, 1);
            if(j) ans = max(ans, i - j + 1);
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/07/30/2019HDU多校第三场 G Find the answer (二分树状数组)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/30/2019HDU多校第三场 G Find the answer (二分树状数组)/" itemprop="url">2019HDU多校第三场 G Find the answer (二分树状数组)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-30T19:04:29+08:00">
                2019-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/思维/" itemprop="url" rel="index">
                    <span itemprop="name">思维</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>二分 树状数组 离散化<br>这题 wa了好多发 最后发现二分从0开始就好了<br>问了一圈人 就我二分乱搞<br>题意 就是 给了你 N 长度序列 你选前 I 个 他们和必须小于 M 你可以让其中某些数字变成0<br>让他们 最后和小于 M （前I个 不包括I）</p>
<p>所以 我考虑 离散化 + 树状数组存对应位置 + 1 和 树状数组维护他们的和<br>这样一来 就存在单调性 可二分了<br>二分树状数组 M - A[I] 大小<br>如果大于 我们 把大于位置之后个数的直接输出就好<br>然后 在把这个数据补充到树状数组中 对应位置 +1</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const int maxn = 2e5 + 5;

long long c[maxn];
int num[maxn];
int a[maxn], b[maxn], ct[maxn];
int n, m, t, cpt;

long long queval(int x){
    long long res = 0;
    for(; x; x -= x&amp;(-x)) res += c[x];
    return res;
}

void add(int x, int y){
    for(;x &lt;= n + 1; x += x &amp; (-x)) c[x] += y;
}

void addd(int x, int y){
    for(;x &lt;= n + 1; x += x &amp; (-x)) num[x] += y;
}

int quenum(int x){
    int res = 0;
    for(; x; x -= x&amp;(-x)) res += num[x];
    return res;
}
int que(int x) {
    //cout &lt;&lt; queval(x) - queval(x - 1) &lt;&lt; endl;
    cout &lt;&lt; quenum(n) &lt;&lt; &quot;   &quot; &lt;&lt; quenum(x) &lt;&lt; endl ;
}

bool chk(int mid) {
//    cout &lt;&lt; mid &lt;&lt; &quot;  sum &quot; &lt;&lt; queval(mid) &lt;&lt; endl;
    return queval(mid) &lt;= m - cpt; 
}

signed main(){
    scanf(&quot;%d&quot;, &amp;t);
    while(t --) {
        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
        memset(c, 0, (n + 5) * sizeof(long long)) ;
        memset(num, 0, (n + 5) * sizeof(int)) ;
        for(int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]), b[i] = a[i] , ct[i] = 0;
        sort(b + 1, b + 1 + n);
        for(int i = 1; i &lt;= n; i ++) {
            int pos = lower_bound(b + 1, b + 1 + n, a[i]) - b;
            if(ct[pos] == 0) ct[pos] = pos;
            int rt = pos;
            pos = ct[pos];
            ct[rt] = pos + 1;
            cpt = a[i];
        //    cout &lt;&lt; pos &lt;&lt; endl;    
            int l = 0, r = n + 1;
            while(l &lt; r) {
                int mid = l + r + 1 &gt;&gt; 1;
                if(chk(mid)) l = mid;
                else r = mid - 1;
            } 
            //cout &lt;&lt; l &lt;&lt; &quot; p    &quot; ;
            printf(&quot;%d&quot;, quenum(n) - quenum(l)); 
        //    que(l);

             add(pos, a[i]);
            //que(pos);
            addd(pos, 1);
            printf(&quot; &quot;);
        } puts(&quot;&quot;);
    }
    return 0;
}</code></pre><p>心疼自己 wa 好几发 如果 不是从0 就会出现错误orz<br>样例<br>5 5<br>4 4 4 4 4</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/07/30/2019 杭电多校第一场 I - String HDU - 6586 字符串处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/30/2019 杭电多校第一场 I - String HDU - 6586 字符串处理/" itemprop="url">2019 杭电多校第一场 I - String HDU - 6586 字符串处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-30T09:32:36+08:00">
                2019-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/贪心/" itemprop="url" rel="index">
                    <span itemprop="name">贪心</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>给了你一个字符串 要求你给出 长度为 k 的 子序列 同时要满足 输入 每个字母出现次数的 区间<br>我们贪心 + 枚举 就是不太好写</p>
<p>我们处理出每个字母之后下次出现的位置 同时记录之后个数</p>
<p>我们K次枚举26个字母是否可以放入<br>之前位置合法 就将队列里面 之前位置扔了<br>如果这个字符放入 我们每一个 字母 z<br>l[z] - num[z]， 0 长度和 大于剩下位置 就是非法的<br>同时 R[z] - num[z] 最多放入还不够 k - i 位也是非法的</p>
<p>合法的直接放入字符串 进入下一层 不然就重复 如果26次还不可以 输出-1</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;

const int maxn = 1e5 + 5;
char s[maxn];
int sum[maxn][27];
int num[27];
int L[27], R[27];
int k;
queue&lt;int&gt; que[27];

int main() {
    while(cin &gt;&gt; s &gt;&gt; k){
        string ans;
        int len = strlen(s);
        for(int i = 0; i &lt; 26; i ++){
            cin &gt;&gt; L[i] &gt;&gt; R[i];
            num[i] = 0;
            while(!que[i].empty()) que[i].pop();
            sum[len][i] = 0;
        } 
        for(int i = 0; i &lt; len; i ++) que[s[i] - &apos;a&apos;].push(i);
        for(int i = len - 1; i &gt;=0; i --) {
            for(int j = 0; j &lt; 26; j ++) sum[i][j] = sum[i + 1][j];
            sum[i][s[i] - &apos;a&apos;] ++;
        }

        bool flag = 0;
        int pos = -1;
        for(int i = 1; i &lt;= k; i ++ ) {
            flag = 0;
            for(int j = 0; j &lt; 26; j ++ ) {
                if(num[j] &gt;= R[j]) continue;
                while(!que[j].empty() &amp;&amp; que[j].front() &lt;= pos) que[j].pop();
                if(!que[j].empty()) {
                    int ok = 1;
                    num[j] ++;
                    for(int z = 0; z &lt; 26; z ++ ) {
                        if(sum[que[j].front() + 1][z] + num[z] &lt; L[z]) {
                            ok = 0;
                            break;
                        }
                    }
                    if(ok) {
                        int lma = 0, lmi = 0;
                        for(int z = 0; z &lt; 26; z ++ ) lmi += max(L[z] - num[z], 0);
                        for(int z = 0; z &lt; 26; z ++ ) lma += (R[z] - num[z])
                        if(lmi &gt; k - i || lma &lt; k - i) ok = 0;
                    }

                    if(ok == 0) num[j] --;
                    else{
                        pos = que[j].front();
                        ans.push_back(j + &apos;a&apos;);
                        flag = 1;
                        break;
                    }
                }
            }
            if(flag == 0) break;
        }
        if(flag) {
            for(int i = 0; i &lt; ans.size(); i ++) cout &lt;&lt; ans[i] ;puts(&quot;&quot;);
        }else cout &lt;&lt; -1 &lt;&lt; endl;
    }
    return 0; 
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="ZHXU1998">
            
              <p class="site-author-name" itemprop="name">ZHXU1998</p>
              <p class="site-description motion-element" itemprop="description">等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZHXU1998</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
