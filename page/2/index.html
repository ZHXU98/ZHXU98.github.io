<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢">
<meta property="og:type" content="website">
<meta property="og:title" content="蒟蒻最后的倔强">
<meta property="og:url" content="http://zhxu98.github.io/page/2/index.html">
<meta property="og:site_name" content="蒟蒻最后的倔强">
<meta property="og:description" content="等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="蒟蒻最后的倔强">
<meta name="twitter:description" content="等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://zhxu98.github.io/page/2/">





  <title>蒟蒻最后的倔强</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?58b7e016a3433eb1162126ec13ec1dbf";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">蒟蒻最后的倔强</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">by-zhxu98</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/19/2019 牛客多校第十场 B Coffee Chicken (数学 思维)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/19/2019 牛客多校第十场 B Coffee Chicken (数学 思维)/" itemprop="url">2019 牛客多校第十场 B Coffee Chicken (数学 思维)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T14:49:29+08:00">
                2019-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数学/" itemprop="url" rel="index">
                    <span itemprop="name">数学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190819143242941.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190819143242941.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)<br>类似 斐波那契数列<br>这个字符在coffe 还是 chicken<br>我们只需要 每次减去 dp[n - 2] 判断它在那个串中 能减去就意味是每个串重新换了减去 ad–<br>不然-=2</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
const ll maxn=1e3+10;
ll dp[maxn];

int main() {
    dp[1] = 6, dp[2] = 7;
    for(ll i=3; i&lt;=60; i++) dp[i]=dp[i-1]+dp[i-2];
    ll t;
    cin&gt;&gt;t;
    string x[4]= {&quot;&quot;,&quot;*COFFEE&quot;,&quot;*CHICKEN&quot;};
    while(t--) {
        ll n,k;
        cin&gt;&gt;n&gt;&gt;k;
        string ans=&quot;&quot;;
        while(n&gt;60) n-=2;
        for(ll i=0; i&lt;10; i++) {
            ll m=k+i,ad=n;
            if(m &gt; dp[ad]) break;
            while(1) {
                if(ad&lt;=2) break;
                if(m&gt;dp[ad-2]) m-=dp[ad-2],ad--;
                else ad=ad-2;
            }
            ans=ans+x[ad][m];
        }
        cout&lt;&lt;ans&lt;&lt;endl;
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/19/2019牛客多校 H Stammering Chemists (模拟)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/19/2019牛客多校 H Stammering Chemists (模拟)/" itemprop="url">2019牛客多校 H Stammering Chemists (模拟)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T13:53:20+08:00">
                2019-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/基本算法/" itemprop="url" rel="index">
                    <span itemprop="name">基本算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190819135104662.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190819135104662.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)<br>这题找到他们的不同特征判断就好了<br>题意还说 不是下面的 随便输出 就可以少盘一种了 虽然也没有少写啥<br>第一个 连边 只有2个是出现1次的<br>4 和 5 用 2个 3边 和 一个4边 判断</p>
<p>2 和 3 我dfs2边 3 的话 4深度出现2次 剩下的直接出 2图就好</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;

int f[100];
int n, m;

string str = &quot;*COFFEECHICKEN&quot;;

int head[10], cnt;
int nxt[15], to[15];

void ade(int a, int b) {
    to[++cnt] = b;
    nxt[cnt] = head[a], head[a] = cnt;
}

int d[15];
void dfs(int x, int fa, int dep){
    d[x] = dep;
    for(int i = head[x]; i; i = nxt[i]) {
        if(to[i] == fa) continue;
        dfs(to[i], x, dep + 1);
    }
}
int du[15];
signed main() {
    int cas;
    cin &gt;&gt; cas;
    while(cas --) {
        memset(head, 0, sizeof head);
        cnt = 0;
        memset(du, 0, sizeof du);
        int du1 = 0, du2 = 0, du3 = 0, du4 = 0;
        for(int i = 1, a, b; i &lt;= 5; i ++) {
            cin &gt;&gt; a &gt;&gt; b;
            ade(a, b), ade(b, a);
            du[a] ++, du[b] ++;
        }

        for(int i = 1; i &lt;= 6; i ++) {
            if(du[i] == 1) du1 ++;
            if(du[i] == 2) du2 ++;
            if(du[i] == 3) du3 ++;
            if(du[i] == 4) du4 ++;
        }
    //  cout &lt;&lt; du1 &lt;&lt; &quot; &quot; &lt;&lt; du2 &lt;&lt; &quot; &quot; &lt;&lt; du3 &lt;&lt; &quot; &quot; &lt;&lt; du4 &lt;&lt; endl;
        if(du4 != 0) {
            cout &lt;&lt; &quot;2,2-dimethylbutane&quot; &lt;&lt; endl;
        }else if(du3 == 2) {
            cout &lt;&lt; &quot;2,3-dimethylbutane&quot; &lt;&lt; endl;
        }else if(du1 == 2 &amp;&amp; du2 == 4) {
            cout &lt;&lt; &quot;n-hexane&quot; &lt;&lt; endl;
        }else {
            memset(d, 0, sizeof d);
            int rt = 1;
            dfs(rt, 0, 1);
            int tmp = 0;
            for(int i = 1; i &lt;= 6; i ++) {
            //  cout &lt;&lt; d[i] &lt;&lt; &quot;  &quot;;
                if(d[i] &gt; tmp) rt = i, tmp = d[i];
            }
            memset(d, 0, sizeof d);
            dfs(rt, 0, 1);
            int d4 = 0, d5 = 0;
            for(int i = 1; i &lt;= 6; i ++) {
            //  cout &lt;&lt; d[i] &lt;&lt; &quot;  &quot;;
                if(d[i] == 4) d4 ++;
            }
            //cout &lt;&lt; d4 &lt;&lt; endl;
            if(d4 == 2) {
                cout &lt;&lt; &quot;3-methylpentane&quot; &lt;&lt; endl;
            }else {
                cout &lt;&lt; &quot;2-methylpentane&quot; &lt;&lt; endl;
            }
        }

    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/19/2019年牛客多校第八场 Explorer (线段树+可撤销并查集)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/19/2019年牛客多校第八场 Explorer (线段树+可撤销并查集)/" itemprop="url">2019年牛客多校第八场 Explorer (线段树+可撤销并查集)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T13:12:25+08:00">
                2019-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/线段树/" itemprop="url" rel="index">
                    <span itemprop="name">线段树</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190819125622308.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190819125622308.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)<br>线段树 上套每个区间可以有哪些并查集<br>一直向下 如果已经有大区间的管道到n 这个点覆盖区间线段树 往下就不必要走了<br>然后学会了 安秩合并(启发式搜索) 不能压缩路径 我们把大的合并到小的上面 就使得 长的 被查询的的路径 尽可能慢的长 这样不压缩路径 不超时 的完成<br>我们合并 和 实现撤销的操作</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
#define fastio ios::sync_with_stdio(false);cin.tie(0)
const int maxn = 2e5 + 10;

int n, m, ans;
struct edge {
    int u, v, l, r;
} e[maxn];
int b[maxn &lt;&lt; 1];
vector&lt;int&gt; tree[maxn &lt;&lt; 2];

void updata(int L, int R, int l, int r, int rt, int x) {
    if(L &lt;= l &amp;&amp; r &lt;= R) {
        tree[rt].push_back(x);
        return ;
    }
    int mid = l + r &gt;&gt; 1;
    if(L &lt;= mid) updata(L, R, l, mid, rt &lt;&lt; 1, x);
    if(R &gt; mid) updata(L, R, mid + 1, r, rt &lt;&lt; 1 | 1, x);
}

int siz[maxn], fa[maxn];
int finds(int x) {
    return x == fa[x] ? x : finds(fa[x]);
}

void query(int l, int r, int rt) {
    vector&lt;int&gt; vec;
    for(int i = 0; i &lt; tree[rt].size(); i ++) {
        int x = tree[rt][i];
        int fau = finds(e[x].u), fav = finds(e[x].v);
        if(fau != fav) {
            if(siz[fau] &lt; siz[fav]) swap(fau, fav);
            fa[fav] = fau; // 只增加小的查询代价
            siz[fau] += siz[fav];
            vec.push_back(fav);
        }
    }
    if(finds(1) == finds(n)) ans += b[r + 1] - b[l];
    else if(l &lt; r) {
        int mid = l + r &gt;&gt; 1;
        query(l, mid, rt &lt;&lt; 1);
        query(mid + 1, r, rt &lt;&lt; 1 | 1);
    }
    for(int i = 0; i &lt; vec.size(); i ++) fa[vec[i]] = vec[i];
    vec.clear();
}


int main() {
    fastio;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt;= n + 5; i ++) fa[i] = i, siz[i] = 1;
    for(int i = 1; i &lt;= m; i ++) {
        cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].l &gt;&gt; e[i].r;
        b[i * 2 - 1] = e[i].l, b[i * 2] = e[i].r + 1;
    }
    sort(b + 1, b + 1 + 2 * m);
    int cnt = unique(b + 1, b + 1 + 2 * m) - b - 1;
    for(int i = 1; i &lt;= m; i ++) {
        int p1 = lower_bound(b + 1, b + 1 + cnt, e[i].l) - b;
        int p2 = lower_bound(b + 1, b + 1 + cnt, e[i].r + 1) - b - 1;
        updata(p1, p2, 1, cnt, 1, i);
    }
    query(1, cnt, 1);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;</code></pre><p>这是一开始的暴力代码 2333 真暴力啊</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef pair&lt;int, int&gt; P;
const int maxn = 1e5 + 5;

int n, m;
int head[maxn], cnt;
int to[maxn &lt;&lt; 1], nxt[maxn &lt;&lt; 1], ls[maxn &lt;&lt; 1], rs[maxn &lt;&lt; 1];

map&lt;pair&lt;P, int&gt;, int&gt; vis;
typedef pair&lt;P, int&gt; PP;

void ade(int a, int b, int c, int d) {
    to[++cnt] = b, ls[cnt] = c, rs[cnt] = d;
    nxt[cnt] = head[a], head[a] = cnt;
}

struct node{
    int u;
    int l, r;
};

queue &lt;node&gt; que;

struct NN{
    int l, r;
    bool operator &lt; (const NN &amp; a) const {
        return l &lt; a.l || (l == a.l &amp;&amp; r &lt; a.r);
    }
};
vector &lt;NN&gt; ans;
void bfs() {
    que.push(node{1, 0, (int)1e9});

    while(!que.empty()) {
        node p = que.front(); que.pop();
//        if()
        if(vis.find(PP(P(p.l, p.r), p.u)) != vis.end()) continue;
        vis[PP(P(p.l, p.r), p.u)] = 1;

        for(int i =head[p.u]; i; i = nxt[i]) {
            int v= to[i];

            int l = p.l, r = p.r;

            l = max(l, ls[i]), r = min(rs[i], r);

            if(l &gt; r) continue;
            if(vis.find(PP(P(l, r), v)) != vis.end() ) continue;

            que.push(node{v, l, r});
            if(v == n) {
                ans.push_back(NN{l, r});
            }
        }
    }
}

signed main(){
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for(int i = 1, a, b, c, d; i &lt;= m; i ++) {
        scanf(&quot;%d %d %d %d&quot;, &amp;a, &amp;b, &amp; c, &amp;d);
        ade(a, b, c, d), ade(b, a, c, d);
    }

    bfs();
    if(ans.size()==0){
        cout&lt;&lt;0&lt;&lt;endl;
        return 0;
    }
    sort(ans.begin(), ans.end());

    int pre = ans[0].r;
    long long tot = ans[0].r - ans[0].l + 1;
//  cout &lt;&lt; ans[0].l &lt;&lt; &quot; &quot; &lt;&lt; ans[0].r &lt;&lt; endl;

//      cout &lt;&lt; ans[i].l &lt;&lt; &quot; &quot; &lt;&lt; ans[i].r &lt;&lt; endl;

    for(int i=1;i&lt;ans.size();i++){
        if(pre&gt;=ans[i].l){
            if(ans[i].r&lt;=pre){
                continue;
            }else{
                tot+=ans[i].r-pre;
                pre=ans[i].r;
            }
        }else{
            tot+=ans[i].r-ans[i].l+1;
            pre=ans[i].r;
        }
    }
    //cout &lt;&lt; tot &lt;&lt; endl;
    printf(&quot;%lld\n&quot;, tot);
    //cout &lt;&lt; ans.size() &lt;&lt; endl;
    return 0;
}
/*
4 4
1 2 1 10
1 3 5 15
2 4 1 10
3 4 5 15
*/</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/19/2019n牛客多校第八场 B Beauty Values (DP or 找规律)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/19/2019n牛客多校第八场 B Beauty Values (DP or 找规律)/" itemprop="url">2019n牛客多校第八场 B Beauty Values (DP or 找规律)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T12:24:52+08:00">
                2019-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DP/" itemprop="url" rel="index">
                    <span itemprop="name">DP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>f(i)=f(i-1)+i-(vis[a[i]]?vis[a[i]]:0)<br>公式怎么出来的呢?考虑 由1-i 如果 第i个数字出现过,那么他对前一个出现过的i维护的区间是没有贡献的,只有vis[i]-i有贡献.<br>如果没出现过肯定 是前面维护的 都+1:</p>
<p>有人可以看出 是总ans不断减 现在数据之前出现过所有同样数据(不止当前这个)出现的位置 和</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int long long

int a[100005];
int k[100005];
signed main(){
    int n;
    scanf(&quot;%lld&quot;,&amp;n);
    int ans=0;
    for(int i=1;i&lt;=n;i++){
        scanf(&quot;%lld&quot;,&amp;a[i]);
        ans=ans+i*(i+1)/2;
    }
    int sum=0,num=0;
    for(int i=1;i&lt;=n;i++){
        if(k[a[i]]==0) k[a[i]]=i;
        else {
            sum+=k[a[i]];
            k[a[i]]=i;
        }
        ans-=sum;
    }
    printf(&quot;%lld\n&quot;,ans);
}



#include &lt;bits/stdc++.h&gt;
using namespace std;
typedef  long long ll;
const int maxn=1e5+8;
ll n,m,k;
ll num[maxn];
int vis[maxn];
ll dp[maxn];
int main()
{
   ll sum=0;
   scanf(&quot;%lld&quot;,&amp;n);
   for(int i=1;i&lt;=n;i++) scanf(&quot;%lld&quot;,&amp;num[i]);
   for(int i=1;i&lt;=n;i++)
   {
        dp[i]=dp[i-1]+i-(vis[num[i]]?vis[num[i]]:0);
        vis[num[i]]=i;
   }
   for(int i=1;i&lt;=n;i++)
     sum+=dp[i];
   printf(&quot;%lld\n&quot;,sum);
   return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/19/2019 牛客暑假多校第八场 A All-one Matrices/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/19/2019 牛客暑假多校第八场 A All-one Matrices/" itemprop="url">2019 牛客暑假多校第八场 A All-one Matrices</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-19T11:46:51+08:00">
                2019-08-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190819114352471.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190819114352471.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)<br>第3次了 关于最大01矩阵的<br>这次找 尽可能大 不相互包含的<br>寻找策略是 下一层1的长度 不等于我当前这层长度<br>剩下的依然是 单调栈维护1矩阵 左右到哪里</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 3000 + 10;

int n, m;
int a[maxn][maxn], dp[maxn][maxn];
int vis[maxn][maxn];
int l[maxn], r[maxn], sum[maxn][maxn];
int que[maxn], head;

signed main() {
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i++){
        for(int j = 1; j &lt;= m; j ++) {
            scanf(&quot;%1d&quot;, &amp;a[i][j]);
            sum[i][j] = sum[i][j - 1] + a[i][j];
            if(a[i][j] == 1) dp[i][j] = dp[i - 1][j] + 1;
            else dp[i][j] = 0;
        }
    }

    int ans = 0;
    for(int i = 1; i &lt;= n; i ++) {
        head = 0; que[++head] = 0;
        for(int j = 1; j &lt;= m; j ++) {
            while(head &gt; 0 &amp;&amp; dp[i][j] &lt;= dp[i][que[head]]) head--;
            l[j] = que[head] + 1;
            que[++head] = j;
        }
        head = 0; que[++head] = m + 1;
        for(int j = m; j &gt;= 1; j --) {
            while(head &gt; 0 &amp;&amp; dp[i][j] &lt;= dp[i][que[head]]) head--;
            r[j] = que[head] - 1;
            que[++head] = j;
        }

        for(int j = 1; j &lt;= m; j ++) {
            if(dp[i][j] == 0) continue;
            if(sum[i][r[j]] - sum[i][l[j] - 1] != r[j] - l[j] + 1) continue;
            if(vis[l[j]][r[j]] == i) continue; //标记K层
            if(sum[i + 1][r[j]] - sum[i + 1][l[j] - 1] == r[j] - l[j] + 1) continue;
            ans ++;
            vis[l[j]][r[j]] = i;
        }
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/17/2019HDU多校第六场 6635 Nonsense Time (LIS 记录路径)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/17/2019HDU多校第六场 6635 Nonsense Time (LIS 记录路径)/" itemprop="url">2019HDU多校第六场 6635 Nonsense Time (LIS 记录路径)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-17T09:26:12+08:00">
                2019-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DP/" itemprop="url" rel="index">
                    <span itemprop="name">DP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>Problem Description
You a given a permutation p1,p2,…,pn of size n. Initially, all elements in p are frozen. There will be n stages that these elements will become available one by one. On stage i, the element pki will become available.

For each i, find the longest increasing subsequence among available elements after the first i stages.


Input
The first line of the input contains an integer T(1≤T≤3), denoting the number of test cases.

In each test case, there is one integer n(1≤n≤50000) in the first line, denoting the size of permutation.

In the second line, there are n distinct integers p1,p2,...,pn(1≤pi≤n), denoting the permutation.

In the third line, there are n distinct integers k1,k2,...,kn(1≤ki≤n), describing each stage.

It is guaranteed that p1,p2,...,pn and k1,k2,...,kn are generated randomly.


Output
For each test case, print a single line containing n integers, where the i-th integer denotes the length of the longest increasing subsequence among available elements after the first i stages.


Sample Input
1
5
2 5 3 1 4
1 4 5 3 2


Sample Output
1 1 2 3 3</code></pre><p>题意概<br>一开始数组锁了 每次我们每次选择 一个位置解放 问最长上升长度</p>
<p>这样 其实 我们只要倒着来 每次锁一个数 看看他在不在 之前lis里面 在的重新求一次<br>因为这题是随机数据 没有卡 暴力过了。。。、</p>
<p>以下 去掉vis 就是正常求LIS 的板子了</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
const int maxn = 5e4 + 5;
using namespace std;
int a[maxn], b[maxn], c[maxn], d[maxn];
bool vis[maxn];
int used[maxn], path[maxn], n;
int LIS() { // d[]存LIS， a[]原数组
    int len = 0;
    for (int i = 1; i &lt;= n; i ++) {
        if(vis[a[i]]) continue; //
        int it = lower_bound(d, d + len, a[i]) - d;
        if (it == len) {
            d[len++] = a[i];
            path[i] = len;
        } else {
            d[it] = a[i];
            path[i] = it + 1;
        }
    }
    fill(used, used + n + 1, 0);
    int tmp = len;
    for (int i = n; i &gt;= 1; --i) {
        if(vis[a[i]]) continue;//
        if (path[i] == tmp) used[i] = 1, tmp--;
    }// 倒序打印也行 少个used
    return len;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0);
    int T;
    scanf(&quot;%d&quot;, &amp;T);
    while (T--) {
        scanf(&quot;%d&quot;, &amp;n);
        fill(vis, vis+n+1, 0);
        for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]);
        for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;b[i]);
        c[n] = LIS();
        for (int i = n-1; i &gt;= 1; --i) {
            vis[a[b[i+1]]] = -1;
            if (used[a[b[i+1]]] == 0) c[i] = c[i+1];
            else c[i] = LIS();
        }
        for (int i = 1; i &lt;= n; ++i) {
            if (i &gt; 1) printf(&quot; &quot;);
            printf(&quot;%d&quot;, c[i]);
        }
        puts(&quot;&quot;);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/17/线段树进阶总结二  (区间取模开根)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/17/线段树进阶总结二  (区间取模开根)/" itemprop="url">线段树进阶总结二  (区间取模开根)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-17T08:44:26+08:00">
                2019-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/线段树/" itemprop="url" rel="index">
                    <span itemprop="name">线段树</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="P4145-上帝造题的七分钟2-花神游历各国"><a href="#P4145-上帝造题的七分钟2-花神游历各国" class="headerlink" title="P4145 上帝造题的七分钟2 / 花神游历各国"></a>P4145 上帝造题的七分钟2 / 花神游历各国</h2><p><a href="https://www.luogu.org/problem/P4145" target="_blank" rel="noopener"> 洛谷 区间开根 </a></p>
<p>最多开几次根就变成1了 这里我们选择 维护区间 和 如果区间和等于区间长度 不更新<br>不等于 更新到底 反正最多跟新不了几次<br>正好问的也是区间和。。</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;
typedef long long ll;

const int maxn = 100050;
ll n, k;

ll tree[maxn &lt;&lt; 2];

void pushup(int rt) {
    tree[rt] = tree[rt &lt;&lt; 1] + tree[rt &lt;&lt; 1 | 1];
}

void build(int l, int r, int rt) {
    if(l == r) {
        scanf(&quot;%lld&quot;, &amp;tree[rt]);
        return ;
    }
    int m = (l + r) &gt;&gt; 1;
    build(l, m, rt &lt;&lt; 1);
    build(m + 1, r, rt &lt;&lt; 1 | 1);
    pushup(rt);
}

void update(int L, int R, int l, int r, int rt) {
    if(L &lt;= l &amp;&amp; r &lt;= R &amp;&amp; tree[rt] == (ll)(r - l + 1)) return;
    if(l == r) {
        tree[rt] = sqrt(1.0 * tree[rt]);
        return;
    }
    int m = (l + r) &gt;&gt; 1;
    if(L &lt;= m)
        update(L, R, l, m, rt &lt;&lt; 1);
    if(R &gt; m)
        update(L, R, m + 1, r, rt &lt;&lt; 1 | 1);
    pushup(rt);
}

ll query(int L, int R, int l, int r, int rt) {
    if(L &lt;= l &amp;&amp; r &lt;= R) return tree[rt];
    int m = (l + r) &gt;&gt; 1;
    ll res = 0;
    if(L &lt;= m)
        res += query(L, R, l, m, rt &lt;&lt; 1);
    if(R &gt; m)
        res += query(L, R, m + 1, r, rt &lt;&lt; 1 | 1);
    return res;
}

int main() {
    cin &gt;&gt; n;
    build(1, n, 1);
    cin &gt;&gt; k;
    for(int i = 0; i &lt; k; i++) {
        int cmd, l, r;
        cin &gt;&gt; cmd &gt;&gt; l &gt;&gt; r;
        if(r &lt; l) swap(r, l);
        if(cmd == 0) update(l, r, 1, n, 1);
        if(cmd == 1) printf(&quot;%lld\n&quot;, query(l, r, 1, n, 1));
    }
    return 0;
}</code></pre><h2 id="区间取模"><a href="#区间取模" class="headerlink" title="区间取模"></a>区间取模</h2><p>CF - 438D<br><a href="https://codeforces.com/problemset/problem/438/D" target="_blank" rel="noopener"> https://codeforces.com/problemset/problem/438/D
</a><br>和上面一样 其实也就是看最大值 取模 只要能取 就一定让 当前数据 减低一半<br>所以接着暴力更</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;
typedef long long ll;

const int maxn = 100050;
ll n, k;

ll tree[maxn &lt;&lt; 2], mas[maxn &lt;&lt; 2];

void pushup(int rt) {
    tree[rt] = tree[rt &lt;&lt; 1] + tree[rt &lt;&lt; 1 | 1];
    mas[rt] = max(mas[rt &lt;&lt; 1], mas[rt &lt;&lt; 1 | 1]);
}

void build(int l, int r, int rt) {
    if(l == r) {
        scanf(&quot;%lld&quot;, &amp;tree[rt]);
        mas[rt] = tree[rt];
        return ;
    }
    int m = (l + r) &gt;&gt; 1;
    build(l, m, rt &lt;&lt; 1);
    build(m + 1, r, rt &lt;&lt; 1 | 1);
    pushup(rt);
}

void update(int L, int R, int l, int r, int rt, int p) {
    if(L &lt;= l &amp;&amp; r &lt;= R &amp;&amp; mas[rt] &lt; p) return;
    if(l == r) {
        tree[rt] = tree[rt] % p;
        mas[rt] = tree[rt];
        return;
    }
    int m = (l + r) &gt;&gt; 1;
    if(L &lt;= m) update(L, R, l, m, rt &lt;&lt; 1, p);
    if(R &gt; m) update(L, R, m + 1, r, rt &lt;&lt; 1 | 1, p);
    pushup(rt);
}

void upd(int L, int l, int r, int rt, int val) {
    if(l == r) {
        tree[rt] = val;
        mas[rt] = val;
        return;
    }
    int m = (l + r) &gt;&gt; 1;
    if(L &lt;= m) upd(L, l, m, rt &lt;&lt; 1, val);
    else upd(L, m + 1, r, rt &lt;&lt; 1 | 1, val);
    pushup(rt);
}

ll query(int L, int R, int l, int r, int rt) {
    if(L &lt;= l &amp;&amp; r &lt;= R) return tree[rt];
    int m = (l + r) &gt;&gt; 1;
    ll res = 0;
    if(L &lt;= m) res += query(L, R, l, m, rt &lt;&lt; 1);
    if(R &gt; m) res += query(L, R, m + 1, r, rt &lt;&lt; 1 | 1);
    return res;
}

int main() {
    cin &gt;&gt; n &gt;&gt; k;
    build(1, n, 1);
    for(int i = 0; i &lt; k; i++) {
        int cmd, l, r, p;
        cin &gt;&gt; cmd &gt;&gt; l &gt;&gt; r;
        if(cmd == 3) upd(l, 1, n, 1, r);
        if(cmd == 2) cin &gt;&gt; p, update(l, r, 1, n, 1, p);
        if(cmd == 1) printf(&quot;%lld\n&quot;, query(l, r, 1, n, 1));
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/16/线段树进阶总结一 DFS序 欧拉序(括号序)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/16/线段树进阶总结一 DFS序 欧拉序(括号序)/" itemprop="url">线段树进阶总结一 DFS序 欧拉序(括号序)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T19:53:38+08:00">
                2019-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/线段树/" itemprop="url" rel="index">
                    <span itemprop="name">线段树</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="DFS序"><a href="#DFS序" class="headerlink" title="DFS序"></a>DFS序</h2><p>前置的几道题</p>
<p>线段树DFS序 1 单点更新 区间查询<br><a href="https://blog.csdn.net/qq_40831340/article/details/84501232" target="_blank" rel="noopener">https://blog.csdn.net/qq_40831340/article/details/84501232</a><br>线段树DFS序 2 区间子树更新 单点查<br><a href="https://blog.csdn.net/qq_40831340/article/details/84501478" target="_blank" rel="noopener">https://blog.csdn.net/qq_40831340/article/details/84501478</a></p>
<p>以上都是关于统计 跟改子树的</p>
<h2 id="欧拉序"><a href="#欧拉序" class="headerlink" title="欧拉序"></a>欧拉序</h2><p>这里我们可以处理出 关于树上路径的<br>虽然我觉得 都是DFS搞这数组也没有啥大区别</p>
<h5 id="树上操作"><a href="#树上操作" class="headerlink" title="树上操作"></a>树上操作</h5><p><a href="https://www.luogu.org/problem/P3178" target="_blank" rel="noopener">https://www.luogu.org/problem/P3178</a><br>其实我代码没有过样例 能过题的原因 是我读错题了 样例是父亲指向儿子 可是数据全是 儿子指向父亲 23333<br>我可能是出题人以外知道这个事情的人了<br>这次我们要处理 树上路径问题 要是像之前2篇博客内样 肯定不行 我们选择要剪掉 out 的才好<br>不能再把他们压在一个结构体了 当然 我之前那样写 也是没有想过会有这样的问题</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
#define int long long
using namespace std;
const int maxn = 2e5 + 10;

int n, m, val[maxn];
int head[maxn], cnt;
int to[maxn], nxt[maxn];

void ade(int a, int b) {
    to[++ cnt] = b;
    nxt[cnt] = head[a], head[a] = cnt;
}

int seq[maxn &lt;&lt; 1], inout[maxn &lt;&lt; 1];
int ind[maxn &lt;&lt; 1], outs[maxn &lt;&lt; 1], tot;

int ss;
void dfs(int u) {
    seq[++ tot] = u, inout[tot] = 1, ind[u] = tot;
    for(int i = head[u]; i; i = nxt[i]) 
        dfs(to[i]),ss ++;
    seq[++ tot] = u, inout[tot] = -1, outs[u] = tot;
}

struct node {
    int sum, lazy, flag;
} tree[maxn &lt;&lt; 3];

void push_up(int rt) {
    tree[rt].sum = tree[rt &lt;&lt; 1].sum + tree[rt &lt;&lt; 1 | 1].sum;
    tree[rt].flag = tree[rt &lt;&lt; 1].flag + tree[rt &lt;&lt; 1 | 1].flag;
}

void push_down(int rt) {
    tree[rt &lt;&lt; 1].sum += tree[rt &lt;&lt; 1].flag * tree[rt].lazy;
    tree[rt &lt;&lt; 1].lazy += tree[rt].lazy;
    tree[rt &lt;&lt; 1 | 1].sum += tree[rt &lt;&lt; 1 | 1].flag * tree[rt].lazy;
    tree[rt &lt;&lt; 1 | 1].lazy += tree[rt].lazy;
    tree[rt].lazy = 0;
}

void build(int l, int r, int rt) {
    if(l == r) {
        tree[rt].flag = inout[l];
        tree[rt].sum = inout[l] * val[seq[l]];
        return ;
    }
    int mid = l + r &gt;&gt; 1;
    build(l, mid, rt &lt;&lt; 1);
    build(mid + 1, r, rt &lt;&lt; 1 | 1);
    push_up(rt);
}

void updata(int L, int R, int l, int r, int rt, int val) {
    if(L &lt;= l &amp;&amp; R &gt;= r) {
        tree[rt].sum += tree[rt].flag * val;
        tree[rt].lazy += val;
        return ;
    }
    if(tree[rt].lazy) push_down(rt);
    int mid = l + r &gt;&gt; 1;
    if(L &lt;= mid) updata(L, R, l, mid, rt &lt;&lt; 1, val);
    if(R &gt; mid) updata(L, R, mid + 1, r, rt &lt;&lt; 1 | 1, val);
    push_up(rt);
}

int query(int L, int R, int l, int r, int rt) {
    if(L &lt;= l &amp;&amp; R &gt;= r) {
        return tree[rt].sum;
    }
    if(tree[rt].lazy) push_down(rt);
    int mid = r + l &gt;&gt; 1;
    int res = 0;
    if(L &lt;= mid) res += query(L, R, l, mid, rt &lt;&lt; 1);
    if(R &gt; mid) res += query(L, R, mid + 1, r, rt &lt;&lt; 1 | 1);
    return res;
}

signed main() {
    scanf(&quot;%lld %lld&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i ++ ) scanf(&quot;%lld&quot;, &amp;val[i]);
    for(int i = 1, a, b; i &lt; n; i ++){
            scanf(&quot;%lld %lld&quot;, &amp;a, &amp;b), ade(b, a);
    }

    int N = n &lt;&lt; 1;
    dfs(1);
    build(1, N, 1);
    int op, x, a;

    while(m --) {
        scanf(&quot;%lld %lld&quot;, &amp;op, &amp;x);
        if(op == 1) {
            scanf(&quot;%lld&quot;, &amp;a);
            updata(ind[x], ind[x], 1, N, 1, a);
            updata(outs[x], outs[x], 1, N, 1, a);
        } else if(op == 2) {
            scanf(&quot;%lld&quot;, &amp;a);
            updata(ind[x], outs[x], 1, N, 1, a);
        } else {
            printf(&quot;%lld\n&quot;, query(1, ind[x], 1, N, 1));
        }
    }
    return 0;
}</code></pre><h4 id="树上路径-区间查-单点改"><a href="#树上路径-区间查-单点改" class="headerlink" title="树上路径 区间查 单点改"></a>树上路径 区间查 单点改</h4><p>接下来就是我们 dfs建立括号序列 如果让路上某个点+v<br>路径询问 我们增加了多少<br>就可以考虑 根节点 到 u 根节点到 v 我们再减去 2倍根节点 到 lca 再加上 lca</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
//#define int long long
using namespace std;
const int maxn = 2e5 + 10;

int n, m, val[maxn];
int head[maxn], cnt;
int to[maxn], nxt[maxn];

void ade(int a, int b) {
    to[++ cnt] = b;
    nxt[cnt] = head[a], head[a] = cnt;
}

int seq[maxn &lt;&lt; 1], inout[maxn &lt;&lt; 1];
int ind[maxn &lt;&lt; 1], outs[maxn &lt;&lt; 1], tot;

void dfs(int u, int pre) {
    seq[++ tot] = u, inout[tot] = 1, ind[u] = tot;
    for(int i = head[u]; i; i = nxt[i])
        if(pre != to[i]) dfs(to[i], u);
    seq[++ tot] = u, inout[tot] = -1, outs[u] = tot;
}

struct node {
    int sum, flag;
} tree[maxn &lt;&lt; 2];

void push_up(int rt) {
    tree[rt].sum = tree[rt &lt;&lt; 1].sum + tree[rt &lt;&lt; 1 | 1].sum;
}

void build(int l, int r, int rt) {
    if(l == r) {
        tree[rt].flag = inout[l];
        tree[rt].sum = inout[l] * val[seq[l]];
        return ;
    }
    int mid = l + r &gt;&gt; 1;
    build(l, mid, rt &lt;&lt; 1);
    build(mid + 1, r, rt &lt;&lt; 1 | 1);
    push_up(rt);
}

void updata(int L, int l, int r, int rt, int val) {
    if(l == r) {
        tree[rt].sum = tree[rt].flag * val;
        return ;
    }
    int mid = l + r &gt;&gt; 1;
    if(L &lt;= mid) updata(L, l, mid, rt &lt;&lt; 1, val);
    else updata(L, mid + 1, r, rt &lt;&lt; 1 | 1, val);
    push_up(rt);
}

int query(int L, int R, int l, int r, int rt) {
    if(L == 0) return 0;
    if(L &lt;= l &amp;&amp; R &gt;= r) {
        return tree[rt].sum;
    }
    int mid = r + l &gt;&gt; 1;
    int res = 0;
    if(L &lt;= mid) res += query(L, R, l, mid, rt &lt;&lt; 1);
    if(R &gt; mid) res += query(L, R, mid + 1, r, rt &lt;&lt; 1 | 1);
    return res;
}

int fa[maxn][30], depth[maxn];
int lg[maxn];

void lca_dfs(int x,int pre) {
    depth[x] = depth[pre] + 1;
    fa[x][0] = pre;
    for(int i = 1; (1 &lt;&lt; i) &lt;= depth[x]; i ++)
        fa[x][i] = fa[fa[x][i - 1]][i - 1];
    for(int i = head[x]; i; i = nxt[i])
        if(to[i] != pre) {
            lca_dfs(to[i], x);
        }
}

int LCA(int x,int y) {
    if(depth[x] &lt; depth[y]) swap(x, y);
    while(depth[x] &gt; depth[y]) x = fa[x][lg[depth[x] - depth[y]] - 1];
    if(x == y) return x;
    for(int k = lg[depth[x]] - 1; k &gt;= 0; k --) {
        if(fa[x][k] != fa[y][k]) {
            x = fa[x][k], y = fa[y][k];
        }
    }
    return fa[x][0];
}

signed main() {
    freopen(&quot;in.in&quot;, &quot;r&quot;, stdin);
    freopen(&quot;a.out&quot;,&quot;w+&quot;,stdout);
    for(int i = 1; i &lt; maxn; i ++) lg[i] = lg[i - 1] + (1 &lt;&lt; lg[i - 1] == i);
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i ++ ) scanf(&quot;%d&quot;, &amp;val[i]);
    for(int i = 1, a, b; i &lt; n; i ++)
        scanf(&quot;%d %d&quot;, &amp;a, &amp;b), ade(a, b), ade(b, a);

    int N = n &lt;&lt; 1;
    dfs(1, 0);
    build(1, N, 1);
    lca_dfs(1, 0);
    fa[1][0] = 0;
    int op , u, v;
    while(m --) {
        scanf(&quot;%d %d %d&quot;, &amp;op, &amp;u, &amp;v);
        if(op == 1) {
            updata(ind[u], 1, N, 1, v);
            updata(outs[u], 1, N, 1, v);
        } else {
            int lca = LCA(u, v);
            printf(&quot;%d\n&quot;, \
                   query(1, ind[u], 1, N, 1) + \
                   query(1, ind[v], 1, N, 1) - \
                   2 * query(1, ind[lca], 1, N, 1) + \
                   query(ind[lca], ind[lca], 1, N, 1) \
                  );
        }
    }
    return 0;
}</code></pre><p>区间改 就特别需要debug能力拉 orz 之后补上</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/16/牛客 小白月赛16 小雨坐地铁 （分层最短路+优化建图）2019暑期多校训练营（第六场）D move/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/16/牛客 小白月赛16 小雨坐地铁 （分层最短路+优化建图）2019暑期多校训练营（第六场）D move/" itemprop="url">牛客 小白月赛16 小雨坐地铁 （分层最短路|优化建图）2019暑期多校训练营（第六场）D move</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T10:27:13+08:00">
                2019-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/图论/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>![在这里插入图片描述](<a href="https://img-blog.csdnimg.cn/20190816101623587.png?x-oss-" target="_blank" rel="noopener">https://img-blog.csdnimg.cn/20190816101623587.png?x-oss-</a><br>process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwODMxMzQw,size_16,color_FFFFFF,t_70)</p>
<h4 id="一种优化分层图建图方法"><a href="#一种优化分层图建图方法" class="headerlink" title="一种优化分层图建图方法"></a>一种优化分层图建图方法</h4><p>直接暴力建这样线特别乱得图 因为中转得关系 我们得暴力扫完这些中转<br>用一个虚拟点代表中专 这样建就 直接处理得换线得问题了</p>
<blockquote>
<p>考虑分层图最短路。<br> 很容易想到建 m 层图，如果多条地铁线都经过同一个点，则在这些点之间暴力两两连边，这样连边是 O(nm^2)的，可能会超时。<br> 我们可以多建一层虚点，所有点到它对应的虚点不需要代价，从虚点到它对应的点需要对应的代价，这样就可以优化到 O(nm) 建图。最后跑一边最短路就好了。</p>
</blockquote>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long ll;
typedef pair&lt;int, int&gt; P;
const int maxn = 1e3 + 5;

int n, m, s, t;
int head[500 * maxn], cnt;
int to[maxn * 1000], nxt[maxn * 1000], val[maxn * 1000];

void ade(int a, int b, int c) {
    to[++ cnt] = b, val[cnt] = c;
    nxt[cnt] = head[a], head[a] = cnt;
}

bool vis[maxn * 500];
int dis[maxn * 500];
void dijkstra(){
    priority_queue&lt;P&gt; que;
    que.push(P(0, s));
    memset(dis, 0x3f, sizeof dis);
    dis[s] = 0;
    while(!que.empty()) {
        P p = que.top(); que.pop();
        int u = p.second;
        if(u == t) {
            cout &lt;&lt; -p.first &lt;&lt; endl;
            return ;
        }
        if(vis[u]) continue;
        vis[u] = 1;
        for(int i = head[u]; i; i = nxt[i]) {
            int v = to[i];
            if(dis[v] &gt; dis[u] + val[i]) {
                dis[v] = dis[u] + val[i];
                que.push(P(-dis[v], v));
            }
        }
    }
    cout &lt;&lt; -1 &lt;&lt; endl;
}

int main(){
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;
    for(int i = 1, a, b, c; i &lt;= m; i ++) {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        for(int j = 1, u, v; j &lt;= c; j ++) {
            cin &gt;&gt; v;
            if(j &gt; 1)
                ade((i - 1) * n + u, (i - 1) * n + v, b), \
                ade((i - 1) * n + v, (i - 1) * n + u, b);

            ade((i - 1) * n + v, m * n + v, 0), \
            ade(m * n + v, (i - 1) * n + v, a);
            u = v;
        }
    }
    t = n * m + t;
    s = n * m + s;
    dijkstra();
    return 0;
}</code></pre><h4 id="牛客-多校-6场-D题-move"><a href="#牛客-多校-6场-D题-move" class="headerlink" title="牛客 多校 6场 D题 move"></a>牛客 多校 6场 D题 move</h4><p>选择 K个变费用0 这个图建立起 没有什么边得互相限制<br>只有处理K<br>所以就不像上面呢样难了 只有K层图 每次图都一样 限制得K 只改变这次路得费用</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 1e3 + 10;
int cas, n, m;
int a[maxn];

bool chk(int mid) {
    bool vis[maxn] = {0};
    int res = 0, v = 0;
    for(int i = 1; i &lt;= m; i ++) {
        v = 0;
        for(int j = n; j &gt;= 1; j --) {
            if(mid - v &gt;= a[j] &amp;&amp; !vis[j]) {
                vis[j] = 1;
                v += a[j];
                res ++;
            }
        }
    }
    if(res != n) return 1;
    else return 0;
}

int main() {
    scanf(&quot;%d&quot;, &amp;cas);
    for(int kk = 1; kk &lt;= cas; kk ++) {
        scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
        int sum = 0;
        for(int i = 1; i &lt;= n; i++) {
            scanf(&quot;%d&quot;, a + i);
            sum += a[i];
        }
        sort(a + 1, a + 1 + n);
        int l = sum / m, r = a[n] + sum / m;
        while(chk(l)) l ++;
        printf(&quot;Case #%d: %d\n&quot;, kk, l);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhxu98.github.io/2019/08/16/2019牛客多校第九场 H Cutting Bamboos (二分主席树)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ZHXU1998">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="蒟蒻最后的倔强">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/16/2019牛客多校第九场 H Cutting Bamboos (二分主席树)/" itemprop="url">2019牛客多校第九场 H Cutting Bamboos (二分主席树)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T08:26:39+08:00">
                2019-08-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/树型结构/" itemprop="url" rel="index">
                    <span itemprop="name">树型结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>看到题解说二分 心里也有数了。。。。。</p>
<h2 id="H-Cutting-Bamboos"><a href="#H-Cutting-Bamboos" class="headerlink" title="H Cutting Bamboos"></a>H Cutting Bamboos</h2><p>给了一些高度得柱子 每区间你可以坎y次 y次之后 必须砍没有了<br>没有砍 总长度得一样 问第x次砍得高度在哪里<br>因为砍得次数 和 每次砍得总长度是一定得 我们二分高度<br>这样 剩下得总长度 就可以用来做二分 得判断了<br>小于高度得总距离 和高于 高度得数量 * mid 就是我们剩下得距离</p>
<pre><code>#include &lt;bits/stdc++.h&gt;
using namespace std;
const int maxn = 2e5 + 10;
const double dmax = 1e9 + 1;
const double eps = 1e-8;

int n, m;
int a[maxn], b[maxn], cnt;
long long sum[maxn];
struct node {
    int lc, rc;
    long long sum;
    int cnt;
} tree[maxn * 20];
int tot, root[maxn];

int build(int l, int r) {
    int p = ++ tot;
    if(l == r) return p;
    int mid = l + r &gt;&gt; 1;
    tree[p].lc = build(l, mid);
    tree[p].rc = build(mid + 1, r);
    return p;
}

int ins(int now, int l, int r, int x, long long val) {
    int p = ++ tot;
    tree[p] = tree[now];
    if(l == r) {
        tree[p].sum += val;
        tree[p].cnt += 1;
        return p;
    }
    int mid = l + r &gt;&gt; 1;
    if(x &lt;= mid) tree[p].lc = ins(tree[now].lc, l, mid, x, val);
    else tree[p].rc = ins(tree[now].rc, mid + 1, r, x, val);
    tree[p].sum = tree[tree[p].lc].sum + tree[tree[p].rc].sum;
    tree[p].cnt = tree[tree[p].lc].cnt + tree[tree[p].rc].cnt;
    return p;
}

long long ask_sum(int p, int q, int l, int r, int L, int R) {
    if(R &lt; L) return 0;
    if(L &lt;= l &amp;&amp; r &lt;= R) return tree[p].sum - tree[q].sum;
    int mid = l + r &gt;&gt; 1;
    long long res = 0;
    if(L &lt;= mid) res += ask_sum(tree[p].lc, tree[q].lc, l, mid, L, R);
    if(R &gt; mid) res += ask_sum(tree[p].rc, tree[q].rc, mid + 1, r, L, R);
    return res;
}

int ask_cnt(int p, int q, int l, int r, int L, int R) {
    if(R &lt; L) return 0;
    if(L &lt;= l &amp;&amp; r &lt;= R) return tree[p].cnt - tree[q].cnt;
    int mid = l + r &gt;&gt; 1;
    int res = 0;
    if(L &lt;= mid) res += ask_cnt(tree[p].lc, tree[q].lc, l, mid, L, R);
    if(R &gt; mid) res += ask_cnt(tree[p].rc, tree[q].rc, mid + 1, r, L, R);
    return res;
}

bool chk(int l, int r, double mid, double tall) {
    int pos = lower_bound(b + 1, b + 1 + cnt, ceil(mid)) - b;
    int k = ask_cnt(root[r], root[l - 1], 1, cnt, pos, cnt);
    long long presum = ask_sum(root[r], root[l - 1], 1, cnt, 1, pos - 1);
    if(1.0 * presum + k * mid &gt; tall) return 0;
    else return 1;
}

signed main() {
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i ++)
        cin &gt;&gt; a[i], sum[i] = sum[i - 1] + a[i], b[i] = a[i];

    sort(b + 1, b + 1 + n);
    cnt = unique(b + 1, b + 1 + n) - b - 1;
    root[0] = build(1, cnt);
    for(int i = 1; i &lt;= n; i ++) {
        int pos = lower_bound(b + 1, b + 1 + cnt, a[i]) - b;
        root[i] = ins(root[i - 1], 1, cnt, pos, 1ll * a[i]);
    }

    while(m --) {
        int L, R, X, Y;
        cin &gt;&gt; L &gt;&gt; R &gt;&gt; X &gt;&gt; Y;
        double l = 0, r = dmax;
        double tall = 1.0 * (1.0 * sum[R] - sum[L - 1]) / Y * (Y - X);
        while(r - l &gt; eps) {
            double mid = (l + r) / 2;
            if( chk(L, R, mid, tall) ) l = mid;
            else r = mid;
        }
        printf(&quot;%.12lf\n&quot;, l);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/uploads/avatar.png" alt="ZHXU1998">
            
              <p class="site-author-name" itemprop="name">ZHXU1998</p>
              <p class="site-description motion-element" itemprop="description">等到有一天我认识到自己是炮灰连蒟蒻都不算的时候.... //我该怎么办呢</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">82</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZHXU1998</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
